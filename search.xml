<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Aboout c++11</title>
    <url>/2023/07/19/Aboout-c-11/</url>
    <content><![CDATA[<p>C++11 的特性主要包括下⾯⼏个⽅⾯：</p>
<ul>
<li>提⾼运⾏效率的语⾔特性：右值引⽤、泛化常量表达式</li>
<li>原有语法的使⽤性增强：初始化列表、统⼀的初始化语法、类型推导、范围 for 循环、Lambda 表达式、final和 override、构造函数委托</li>
<li>语⾔能⼒的提升：空指针 nullptr、default 和 delete、⻓整数、静态 assert</li>
<li>C++ 标准库的更新：智能指针、正则表达式、哈希表等<br>以下选出部分了解或者用过得</li>
</ul>
<a id="more"></a>

<ol>
<li>空指针<br>nullptr比之前的NULL写法更加严谨，避免了不同编译器对于NULL的不同定义，所以在代码中在能使用nullptr的时候不应用NULL</li>
<li>Lambda表达式<br>简化的匿名函数，可以对其作用域类的变量进行捕捉，例如可以在注册回调函数时使用</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerChangeCallback</span><span class="params">(<span class="keyword">const</span> change_call_back&amp; callback)</span></span>&#123;</span><br><span class="line">    mChangeCallback = callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use lambda as a callback function</span></span><br><span class="line">object-&gt;registerChangeCallback(</span><br><span class="line">    <span class="comment">// capture object by using &#x27;this&#x27;</span></span><br><span class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; msg) &#123; <span class="comment">//do somthing with msg &#125;;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>右值引用<br>这部分出自：<a href="http://c.biancheng.net/view/7829.html">http://c.biancheng.net/view/7829.html</a><br>前面提到，其实 C++98/03 标准中就有引用，使用 “&amp;” 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用。</li>
</ol>
<p>注意，虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b = num;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p>
<p>为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。<br>话说，C++标准委员会在选定右值引用符号时，既希望能选用现有 C++ 内部已有的符号，还不能与 C++ 98 /03 标准产生冲突，最终选定了 2 个 ‘&amp;’ 表示右值引用。</p>
<p>需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>程序输出结果为 100。</p>
<ol start="4">
<li><p>常量表达式constexpr<br>很实用的一个改动</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> NUM = <span class="number">10</span>; </span><br></pre></td></tr></table></figure></li>
<li><p>类型推导<br>满分好评，auto非常好用，不需要在纠结写对类型名。decltype日常使用较少</p>
</li>
<li><p>范围的for循环<br>又是很实用的，常常和auto一起用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; type : type_list) &#123;</span><br><span class="line">    <span class="comment">// do something with type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>构造函数委托<br>复用底层构造函数</p>
</li>
<li><p>final和override<br>显示的提醒编译器进行检查(warning or error)，可以使得代码更健壮</p>
</li>
<li><p>智能指针<br>shared_ptr, uniq_ptr。shared_ptr非常常用，但是也容易造成内存泄漏</p>
</li>
</ol>
<p>10 优化了map, multimap, set, multiset的插入查询效率 O(lgn) –&gt; O(1)</p>
]]></content>
      <tags>
        <tag>面试</tag>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask音频文件上传以及文档部分摘录</title>
    <url>/2021/02/21/Flask%E9%9F%B3%E9%A2%91%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%BB%A5%E5%8F%8A%E6%96%87%E6%A1%A3%E9%83%A8%E5%88%86%E6%91%98%E5%BD%95/</url>
    <content><![CDATA[<p>Flask-uploads上传文件并不复杂，但是有些问题文档中没有说的详细，使用的时候可能会遇到问题，另外摘录了一部分Flask文档，内容包括：蓝图、装饰器、模板、文件上传、缓存、表单验证</p>
 <a id="more"></a>

<h3 id="Flask-uploads上传音频文件"><a href="#Flask-uploads上传音频文件" class="headerlink" title="Flask-uploads上传音频文件"></a>Flask-uploads上传音频文件</h3><p>Flask-uploads上传音频文件大致流程如下：</p>
<ol>
<li><p>结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">|--uploads</span><br><span class="line">|    |--views.py</span><br><span class="line">|    |--models.py</span><br><span class="line">|--templates/</span><br><span class="line">|    |--upload/</span><br><span class="line">|       |--upload.html</span><br><span class="line">|--app.py</span><br><span class="line">|--config.py</span><br></pre></td></tr></table></figure></li>
<li><p>在view中新建UploadSet实例，UploadSet代码在下面。需要这样配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">audios= UploadSet(<span class="string">&#x27;audios&#x27;</span>)  <span class="comment"># UploadSet的源码见后面</span></span><br></pre></td></tr></table></figure>
<p>第一个参数name需要注意的有两点：一是参数名不能有下划线，二是name需要与后续配置参数一致，默认name是files，extensions和default_dest在config.py中配置，这里配置的extensions会被configuration中的<code>UPLOADED_X_ALLOW</code> and <code>UPLOADED_X_DENY</code> 配置覆盖（X对应这里实例中name的大写，保持一致，默认的name是files，所以默认的configuration就是UPLOADED_FILES_ALLOW这种格式 ）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadSet</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name=<span class="string">&#x27;files&#x27;</span>, extensions=DEFAULTS, default_dest=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> name.isalnum():</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Name must be alphanumeric (no underscores)&quot;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.extensions = extensions</span><br><span class="line">        self._config = <span class="literal">None</span></span><br><span class="line">        self.default_dest = default_dest</span><br></pre></td></tr></table></figure></li>
<li><p>配置config.py和app.py，这里需要在app初始化的时候配置好环境，其中存储路径是必选的，否则会报错找不到配置<br>可以在config.py中配置然后引入app.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span>:</span></span><br><span class="line">    UPLOADED_AUDIOS_DEST = path  <span class="comment"># AUDIOS对应UploadSet中name的大写</span></span><br><span class="line">    UPLOADED_AUDIOS_ALLOW = [<span class="string">&#x27;mp3&#x27;</span>, <span class="string">&#x27;wav&#x27;</span>]  <span class="comment"># 合法的文件后缀</span></span><br></pre></td></tr></table></figure>
<p>也可以在app.py中这样配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app.config[<span class="string">&#x27;MAX_CONTENT_LENGTH&#x27;</span>] = <span class="number">32</span> * <span class="number">1024</span> * <span class="number">1024</span>  <span class="comment"># 最大上传文件大小</span></span><br></pre></td></tr></table></figure></li>
<li><p>将配置导入app，在app.py中configure_uploads(app, audios)，如果有多个UploadSet的实例，可以使用configure_uploads(app, [audios, other_instance, ….])，这里需要from flask_uploads import configure_uploads，同时导入audios所在的模块，如果configure_uploads报错，需要检查前两步，一般是name出错或者配置的位置不对导致循环import</p>
</li>
<li><p>如果要存入本地db可以在models.py建表（可选）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadAudio</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;uploadaudio&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, autoincrement=<span class="literal">True</span>, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">256</span>), unique=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    path = db.Column(db.String)</span><br><span class="line">    url = db.Column(db.String)</span><br><span class="line">    create_time = db.Column(db.DateTime, default=datetime.utcnow)</span><br></pre></td></tr></table></figure></li>
<li><p>上传HTML页面，这里也可以使用FlaskForm（使用FlaskForm需要在蓝图下新建forms.py）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Upload new Audio Files<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">POST</span> <span class="attr">enctype</span>=<span class="string">multipart/form-data</span> <span class="attr">action</span>=<span class="string">&quot;&#123;&#123; url_for(&#x27;upload_audio&#x27;) &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">file</span> <span class="attr">name</span>=<span class="string">audio</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在views.py中编写处理函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_audio</span>():</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;audio&#x27;</span> <span class="keyword">in</span> request.files:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            filename = audios.save(request.files[<span class="string">&#x27;audio&#x27;</span>])</span><br><span class="line">        <span class="keyword">except</span> UploadNotAllowed :</span><br><span class="line">            flash(<span class="string">&quot;File format is not allowed!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> render_template(<span class="string">&#x27;upload.html&#x27;</span>)</span><br><span class="line">        url = <span class="string">&#x27;&#x27;</span>  <span class="comment"># todo get url</span></span><br><span class="line">        rec_audio = UploadAudio(name=filename,</span><br><span class="line">                                  path=os.path.join(</span><br><span class="line">                                      current_app.config[<span class="string">&#x27;UPLOADED_AUDIOS_DEST&#x27;</span>], filename),</span><br><span class="line">                                  url=url)</span><br><span class="line">        db.session.add(rec_audio)</span><br><span class="line">        db.session.commit</span><br><span class="line">        flash(<span class="string">&quot;audio saved.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;show_audios&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;upload.html&#x27;</span>)</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h2 id="Flask文档部分摘录"><a href="#Flask文档部分摘录" class="headerlink" title="Flask文档部分摘录"></a>Flask文档部分摘录</h2><h3 id="运行应用-开发模式"><a href="#运行应用-开发模式" class="headerlink" title="运行应用-开发模式"></a>运行应用-开发模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“在 Linux and Mac 下：</span><br><span class="line"></span><br><span class="line">$ export FLASK_APP&#x3D;flaskr</span><br><span class="line">$ export FLASK_ENV&#x3D;development</span><br><span class="line">$ flask run</span><br><span class="line">在 Windows 下，使用 set 代替 export ：</span><br><span class="line"></span><br><span class="line">&gt; set FLASK_APP&#x3D;flaskr</span><br><span class="line">&gt; set FLASK_ENV&#x3D;development</span><br><span class="line">&gt; flask run”</span><br></pre></td></tr></table></figure>
<h3 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h3><p>Blueprint 是一种组织一组相关视图及其他代码的方式。蓝图方式是把视图及其他代码注册到蓝图，然后在工厂函数中把蓝图注册到应用。相当于区分不同prefix前缀的url访问。蓝图可以多次注册</p>
<p>步骤1：bp = Blueprint(‘auth’, _<em>name_</em>, url_prefix=’/auth’)<br>这里创建了一个名称为 ‘auth’ 的 Blueprint 。和应用对象一样， 蓝图需要知道是在哪里定义的，因此把 <strong>name\</strong> 作为函数的第二个参数。 url_prefix 会添加到所有与该蓝图关联的 URL 前面。</p>
<p>步骤2：使用 app.register_blueprint() 导入并注册 蓝图。新的代码放在工厂函数的尾部返回应用之前。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flaskr/__init__.py</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span>():</span></span><br><span class="line">    app = ...</span><br><span class="line">    <span class="comment"># existing code omitted</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">from</span> . <span class="keyword">import</span> auth</span><br><span class="line">    app.register_blueprint(auth.bp)</span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line">认证蓝图将包括注册新用户、登录和注销视图</span><br></pre></td></tr></table></figure>
<h4 id="注册蓝图"><a href="#注册蓝图" class="headerlink" title="注册蓝图"></a>注册蓝图</h4><p>可以这样注册蓝图:</p>
<p>from flask import Flask<br>from yourapplication.simple_page import simple_page</p>
<p>app = Flask(<strong>name</strong>)<br>app.register_blueprint(simple_page)<br>以下是注册蓝图后形成的规则:</p>
<blockquote>
<blockquote>
<blockquote>
<p>app.url_map<br>Map([&lt;Rule ‘/static/&lt;filename&gt;’ (HEAD, OPTIONS, GET) -&gt; static&gt;,<br> &lt;Rule ‘/&lt;page&gt;‘ (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;,<br> &lt;Rule ‘/‘ (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;])<br>第一条很明显，是来自于应用本身的用于静态文件的。后面两条是用于蓝图 simple_page 的 show 函数的。你可以看到，它们的前缀都是蓝图的名称，并 且使用一个点（ . ）来分隔。</p>
</blockquote>
</blockquote>
</blockquote>
<p>蓝图还可以挂接到不同的位置:</p>
<p>app.register_blueprint(simple_page, url_prefix=’/pages’)<br>这样就会形成如下规则:</p>
<blockquote>
<blockquote>
<blockquote>
<p>app.url_map<br>Map([&lt;Rule ‘/static/&lt;filename&gt;‘ (HEAD, OPTIONS, GET) -&gt; static&gt;,<br> &lt;Rule ‘/pages/&lt;page&gt;‘ (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;,<br> &lt;Rule ‘/pages/‘ (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;])<br>总之，你可以多次注册蓝图，但是不一定每个蓝图都能正确响应。是否能够多次注册 实际上取决于你的蓝图是如何编写的，是否能根据不同的位置做出正确的响应。</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="验证登录-装饰器"><a href="#验证登录-装饰器" class="headerlink" title="验证登录-装饰器"></a>验证登录-装饰器</h3><p>先看装饰器的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把@log放到now()函数的定义处，相当于执行了语句：</span></span><br><span class="line"><span class="comment"># now = log(now)</span></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span>():</span></span><br><span class="line">    print(datetime.datetime.now())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本质上，decorator就是一个返回函数的高阶函数。</span></span><br><span class="line"><span class="comment"># 1、需要@语法</span></span><br><span class="line"><span class="comment"># 2、需要运行被装饰函数实现</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    f = now</span><br><span class="line">    f()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要验证登录的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flaskr/auth.py</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_required</span>(<span class="params">view</span>):</span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">view</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped_view</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> g.user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;auth.login&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapped_view</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 可以这样使用 (需要import对应模块) </span></span><br><span class="line"><span class="comment"># view_index = login_required(view_index)</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="meta">@route(<span class="params"><span class="string">&#x27;/index&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view_index</span>():</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><h4 id="模板替换"><a href="#模板替换" class="headerlink" title="模板替换"></a>模板替换</h4><figure class="highlight plain"><figcaption><span>extends 'base.html' %&#125;``` 告诉 Jinja 这个模板基于基础模板，并且需要替换 相应的块。所有替换的内容必须位于``` &#123;% block %&#125; ```标签之内。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">也就是说要替换的内容都放在&#96;&#96;&#96;&#123;% ... %&#125;&#96;&#96;&#96;这里面</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">flaskr&#x2F;templates&#x2F;auth&#x2F;register.html</span><br><span class="line"></span><br><span class="line"># &#123;% extends &#39;base.html&#39; %&#125; 告诉 Jinja 这个模板基于基础模板，并且需要替换 相应的块。所有替换的内容必须位于 &#123;% block %&#125; 标签之内。</span><br><span class="line"></span><br><span class="line">&#123;% extends &#39;base.html&#39; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block header %&#125;</span><br><span class="line">  &lt;h1&gt;&#123;% block title %&#125;Register&#123;% endblock %&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">  &lt;form method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;username&quot;&gt;Username&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input name&#x3D;&quot;username&quot; id&#x3D;&quot;username&quot; required&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;password&quot;&gt;Password&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; id&#x3D;&quot;password&quot; required&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Register&quot;&gt;</span><br><span class="line">  &lt;&#x2F;form&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>缺省情况下，以下全局变量可以在 Jinja2 模板中使用：</p>
<p>config<br>当前配置对象（ flask.config ）<br>request<br>当前请求对象（ flask.request ）。 在没有活动请求环境情况下渲染模板时，这个变量不可用。session<br>当前会话对象（ flask.session ）。 在没有活动请求环境情况下渲染模板时，这个变量不可用。g<br>请求绑定的全局变量（ flask.g ）。 在没有活动请求环境情况下渲染模板时，这个变量不可用。</p>
<p>url_for()<br>flask.url_for() 函数。</p>
<p>get_flashed_messages()<br>flask.get_flashed_messages() 函数。</p>
<h4 id="自动转义"><a href="#自动转义" class="headerlink" title="自动转义"></a>自动转义</h4><p>有三种方法可以控制自动转义：</p>
<ul>
<li>在 Python 代码中，可以在把 HTML 字符串传递给模板之前，用 Markup 对象封装。一般情况下推荐使用这个方法。</li>
<li>在模板中，使用 |safe 过滤器显式把一个字符串标记为安全的 HTML （例如：  ）。</li>
<li>临时关闭整个系统的自动转义。<br>  在模板中关闭自动转义系统可以使用 <code>&#123;% autoescape %&#125;</code> 块：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% autoescape false %&#125; </span><br><span class="line"> 		&lt;p&gt;autoescaping is disabled here</span><br><span class="line">    &lt;p&gt;&#123;&#123; will_not_be_escaped &#125;&#125;</span><br><span class="line">&#123;% endautoescape %&#125;</span><br></pre></td></tr></table></figure>


<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>文件上传的基本原理实际上很简单，基 本上是：一个带有 enctype=multipart/form-data 的 &lt;form&gt; 标记，标记中含有 一个 &lt;input type=file&gt; 。<br>应用通过请求对象的 files 字典来访问文件。<br>使用文件的 save() [<a href="https://werkzeug.palletsprojects.com/en/0.15.x/datastructures/#werkzeug.datastructures.FileStorage.save]">https://werkzeug.palletsprojects.com/en/0.15.x/datastructures/#werkzeug.datastructures.FileStorage.save]</a> 方法把文件 永久地保存在文件系统中。<br>简介</p>
<p>让我们从一个基本的应用开始，这个应用上传文件到一个指定目录，并把文件显示给 用户。以下是应用的前导代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, flash, request, redirect, url_for</span><br><span class="line"><span class="keyword">from</span> werkzeug.utils <span class="keyword">import</span> secure_filename</span><br><span class="line"></span><br><span class="line">UPLOAD_FOLDER = <span class="string">&#x27;/path/to/the/uploads&#x27;</span></span><br><span class="line">ALLOWED_EXTENSIONS = &#123;<span class="string">&#x27;txt&#x27;</span>, <span class="string">&#x27;pdf&#x27;</span>, <span class="string">&#x27;png&#x27;</span>, <span class="string">&#x27;jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>, <span class="string">&#x27;gif&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">&#x27;UPLOAD_FOLDER&#x27;</span>] = UPLOAD_FOLDER</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allowed_file</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;.&#x27;</span> <span class="keyword">in</span> filename <span class="keyword">and</span> \</span><br><span class="line">           filename.rsplit(<span class="string">&#x27;.&#x27;</span>, <span class="number">1</span>)[<span class="number">1</span>].lower() <span class="keyword">in</span> ALLOWED_EXTENSIONS</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_file</span>():</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># check if the post request has the file part</span></span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> <span class="string">&#x27;file&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> request.files:</span><br><span class="line">​            flash(<span class="string">&#x27;No file part&#x27;</span>)</span><br><span class="line">​            <span class="keyword">return</span> redirect(request.url)</span><br><span class="line">​        file = request.files[<span class="string">&#x27;file&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># if user does not select file, browser also</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># submit an empty part without filename</span></span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> file.filename == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">​            flash(<span class="string">&#x27;No selected file&#x27;</span>)</span><br><span class="line">​            <span class="keyword">return</span> redirect(request.url)</span><br><span class="line">​        <span class="keyword">if</span> file <span class="keyword">and</span> allowed_file(file.filename):</span><br><span class="line">​            filename = secure_filename(file.filename)</span><br><span class="line">​            file.save(os.path.join(app.config[<span class="string">&#x27;UPLOAD_FOLDER&#x27;</span>], filename))</span><br><span class="line">​            <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;uploaded_file&#x27;</span>,</span><br><span class="line">​                                    filename=filename))</span><br><span class="line">​    <span class="keyword">return</span> <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;!doctype html&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Upload new File&lt;/title&gt;</span></span><br><span class="line"><span class="string">    &lt;h1&gt;Upload new File&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;form method=post enctype=multipart/form-data&gt;</span></span><br><span class="line"><span class="string">      &lt;input type=file name=file&gt;</span></span><br><span class="line"><span class="string">      &lt;input type=submit value=Upload&gt;</span></span><br><span class="line"><span class="string">    &lt;/form&gt;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>限制文件上传尺寸</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, Request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">&#x27;MAX_CONTENT_LENGTH&#x27;</span>] = <span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br></pre></td></tr></table></figure>
<h6 id="推荐扩展：Flask-Uploads实现文件上传"><a href="#推荐扩展：Flask-Uploads实现文件上传" class="headerlink" title="推荐扩展：Flask-Uploads实现文件上传"></a>推荐扩展：Flask-Uploads实现文件上传</h6><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Flask 本身不提供缓存，但是 Flask-Caching [<a href="https://flask-caching.readthedocs.io/en/latest/]">https://flask-caching.readthedocs.io/en/latest/]</a> 扩展可以。 Flask-Caching 支持多种后端，甚至可以支持你自己开发的后端。</p>
<h3 id="WTForms表单验证"><a href="#WTForms表单验证" class="headerlink" title="WTForms表单验证"></a>WTForms表单验证</h3><h4 id="创建表单"><a href="#创建表单" class="headerlink" title="创建表单"></a>创建表单</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> Form, BooleanField, StringField, PasswordField, validators</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegistrationForm</span>(<span class="params">Form</span>):</span></span><br><span class="line">    username = StringField(<span class="string">&#x27;Username&#x27;</span>, [validators.Length(<span class="built_in">min</span>=<span class="number">4</span>, <span class="built_in">max</span>=<span class="number">25</span>)])</span><br><span class="line">    email = StringField(<span class="string">&#x27;Email Address&#x27;</span>, [validators.Length(<span class="built_in">min</span>=<span class="number">6</span>, <span class="built_in">max</span>=<span class="number">35</span>)])</span><br><span class="line">    password = PasswordField(<span class="string">&#x27;New Password&#x27;</span>, [</span><br><span class="line">        validators.DataRequired(),</span><br><span class="line">        validators.EqualTo(<span class="string">&#x27;confirm&#x27;</span>, message=<span class="string">&#x27;Passwords must match&#x27;</span>)</span><br><span class="line">    ])</span><br><span class="line">    confirm = PasswordField(<span class="string">&#x27;Repeat Password&#x27;</span>)</span><br><span class="line">    accept_tos = BooleanField(<span class="string">&#x27;I accept the TOS&#x27;</span>, [validators.DataRequired()])</span><br></pre></td></tr></table></figure>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/register&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>():</span></span><br><span class="line">    form = RegistrationForm(request.form)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span> <span class="keyword">and</span> form.validate():</span><br><span class="line">        user = User(form.username.data, form.email.data,</span><br><span class="line">                    form.password.data)</span><br><span class="line">        db_session.add(user)</span><br><span class="line">        flash(<span class="string">&#x27;Thanks for registering&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;login&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;register.html&#x27;</span>, form=form)</span><br></pre></td></tr></table></figure>
<h4 id="对应的HTML"><a href="#对应的HTML" class="headerlink" title="对应的HTML"></a>对应的HTML</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># WTForms 替我们完成了一半表单生成工作。为了做得更好， 我们可以写一个宏，通过这个宏渲染带有一个标签的字段和错误列表（如果有的话）。</span><br><span class="line"></span><br><span class="line"># 以下是一个使用宏的示例 _formhelpers.html 模板：</span><br><span class="line"></span><br><span class="line">&#123;% macro render_field(field) %&#125;</span><br><span class="line">  &lt;dt&gt;&#123;&#123; field.label &#125;&#125;</span><br><span class="line">  &lt;dd&gt;&#123;&#123; field(**kwargs)|safe &#125;&#125;  # WTForms 返回标准的 Python unicode 字符串，因此我们 必须使用 |safe 过滤器告诉 Jinja2 这些数据已经经过 HTML 转义了。</span><br><span class="line">  &#123;% if field.errors %&#125;</span><br><span class="line">    &lt;ul class&#x3D;errors&gt;</span><br><span class="line">    &#123;% for error in field.errors %&#125;</span><br><span class="line">      &lt;li&gt;&#123;&#123; error &#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  &lt;&#x2F;dd&gt;</span><br><span class="line">&#123;% endmacro %&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对应的模板"><a href="#对应的模板" class="headerlink" title="对应的模板"></a>对应的模板</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 以下是使用了上面的 _formhelpers.html 的 register.html 模板：</span><br><span class="line"></span><br><span class="line">&#123;% from &quot;_formhelpers.html&quot; import render_field %&#125;</span><br><span class="line">&lt;form method&#x3D;post&gt;</span><br><span class="line">  &lt;dl&gt;</span><br><span class="line">    &#123;&#123; render_field(form.username) &#125;&#125;</span><br><span class="line">    &#123;&#123; render_field(form.email) &#125;&#125;</span><br><span class="line">    &#123;&#123; render_field(form.password) &#125;&#125;</span><br><span class="line">    &#123;&#123; render_field(form.confirm) &#125;&#125;</span><br><span class="line">    &#123;&#123; render_field(form.accept_tos) &#125;&#125;</span><br><span class="line">  &lt;&#x2F;dl&gt;</span><br><span class="line">  &lt;p&gt;&lt;input type&#x3D;submit value&#x3D;Register&gt;</span><br><span class="line">&lt;&#x2F;form&gt;”</span><br></pre></td></tr></table></figure>


<p>来源以及参考：</p>
<ul>
<li><a href="https://dormousehole.readthedocs.io/en/latest/">Flask中文文档</a></li>
<li><a href="https://pythonhosted.org/Flask-Uploads/">Flask-Uploads文档</a></li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>Flask</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM垃圾回收、类加载以及双亲委派模型</title>
    <url>/2021/01/12/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%BB%A5%E5%8F%8A%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>JVM阻断了程序员直接与内存直接的交互，所以理解它的工作方式可以更好的理解程序的运行</p>
<a id="more"></a>

<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>大部分的垃圾回收器新生代基于from+to的复制算法，而在老年代使用标记整理避免碎片，CMS比较特殊，G1可以单独考虑</p>
<hr>
<table>
<thead>
<tr>
<th>垃圾回收算法</th>
<th>新生代</th>
<th>老年代</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>标记清除算法</td>
<td></td>
<td>CMS(Sweep)</td>
<td></td>
</tr>
<tr>
<td>复制算法</td>
<td>Serial/ParNew/Parallel Scavenge</td>
<td></td>
<td>G1每两个Region来看</td>
</tr>
<tr>
<td>标记-整理算法</td>
<td></td>
<td>Serial 收集器/ParNew/Parallel Scavenge</td>
<td>G1总体来看</td>
</tr>
<tr>
<td>分代收集算法</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.jpg" alt="GJYKoj"></p>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>从类加载机制流程图中可以看出两点：</p>
<ul>
<li>反射：本地实现和Java实现，初始使用本地实现，超过阀值调用Java实现是动态生成字节码=&gt;加载=&gt;验证=&gt;解析….的流程</li>
<li>动态代理：代理类为接口生成二进制的字节流，经过类加载流程<ul>
<li>Spring AOP：运行时生成代理的二进制字节流，此字节流需要重新经过类加载流程</li>
<li>AspectJ：加载时将代理的二进制字节流与类糅合</li>
</ul>
</li>
</ul>
<p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.jpg" alt="GJYQFs"></p>
<h3 id="双亲委派模型破坏"><a href="#双亲委派模型破坏" class="headerlink" title="双亲委派模型破坏"></a>双亲委派模型破坏</h3><ul>
<li>基础的类调用用户自定义的接口：基础的类必然由启动类加载器加载，但是自定义接口不能被启动类加载器识别加载</li>
<li>OSGi的热部署：降低模块与父类加载器的耦合，除了基础的公共部分由父类加载，其他的部分由平级加载，实现模块的热插拔</li>
</ul>
<p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/JVM/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.jpg" alt="GJYuwQ"></p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li><p>方法在字节码输入流中是作为符号引用出现的，虚拟机在想要执行，只能先解析。静态方法和私有方法因为是在编译时就可以确定执行的具体类型的，所以在类加载的解析过程中会解析成直接的引用。有两种方法不能直接解析：</p>
<ul>
<li>invokevirtual：虚方法，见下面重写</li>
<li>invokedynamic：动态方法在类加载的时候并不能直接解析，给与用户虚拟机的方法调用权。Java本身是一个静态语言，这是为了Lambda表达式以及运行在虚拟机上的其他动态语言准备的</li>
</ul>
</li>
<li><p>静态解析-重载与向上转型：Runtime类型向Apparent类型转型，这种转型在java中更像是为了编译的需要，所以这段Human man = new Man()中的man在编译时就会被解析成Human这种Apparent类型。当然man在执行重载方法的时候仍会动态的决定执行哪个方法，只不过这个Apparent类型在同样签名下会优先执行</p>
</li>
<li><p>动态解析-重写：重写更像是真正意义上的</p>
<p>  多</p>
<p>  态，它的执行流程如下：</p>
<ul>
<li>找到栈顶实际类型C</li>
<li>C中校验签名与权限</li>
<li>上一步失败后递归向上寻找并校验签名与权限</li>
<li>上一步还是失败跑出异常</li>
</ul>
</li>
</ul>
<h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><ul>
<li>为什么选择泛型擦除：二进制向后兼容性。避免增加一套平行的泛型</li>
<li>在字节码层面，而非代码层面：代码可用，字节码不可用，所以意味着反射这些代码层面的可用，而字节码层面抛开上下文是无法直接判断如 List&lt; Integer &gt; 和 List&lt; String &gt;</li>
<li>强制行擦除而非继承实现</li>
</ul>
<h3 id="前端编译器优化"><a href="#前端编译器优化" class="headerlink" title="前端编译器优化"></a>前端编译器优化</h3><p>插入式注解工作原理：类似于劫持了部分语法分析与符号表的交互，在JVM正常的语法分析之外，插入了增加的注解部分字节码，并更新了符号表</p>
<ul>
<li>泛型擦除</li>
<li>desugar</li>
<li>条件编译</li>
<li>常量优化</li>
</ul>
<h3 id="后端编译优化-即时编译和提前编译都属于后端，下面主要是即时编译"><a href="#后端编译优化-即时编译和提前编译都属于后端，下面主要是即时编译" class="headerlink" title="后端编译优化(即时编译和提前编译都属于后端，下面主要是即时编译)"></a>后端编译优化(即时编译和提前编译都属于后端，下面主要是即时编译)</h3><ul>
<li>分层编译、栈上替换</li>
<li>动态的分支预测</li>
<li>公共表达式消除、常量折叠、空值消除</li>
<li>装箱消除、逃逸分析、锁消除、锁膨胀</li>
<li>内联</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法与c++实现</title>
    <url>/2021/01/13/KMP%E7%AE%97%E6%B3%95%E4%B8%8Ec-%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>KMP算法在考研的时候就觉得很难理解，现在重看还是很有难度，在我理解它像动态规划一样使用了一个额外的空间来存储比较过程中的状态，但是它状态转移计算的方式在实现的时候有一些triky </p>
<a id="more"></a>

<ul>
<li>next数组用来存储比较过程中的状态以便于在比较失败的时候回溯</li>
<li>比较是前一位的字符，next数组记录的是当前位置</li>
<li>在计算next数组的时候只需要模式串p，也就是说next数组实质上记录的是模式串对自身在当前下标下首尾是否有重合</li>
<li>next数组和nextval数组都是比模式串p的长度长1位</li>
</ul>
<h3 id="c-代码实现"><a href="#c-代码实现" class="headerlink" title="c++代码实现"></a>c++代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用KMP：</span></span><br><span class="line"><span class="comment"> * 1、新建长度比p长1的next数组 讨论3种情况</span></span><br><span class="line"><span class="comment"> *      初始化：i=1, j=0, next[0]=0, next[1]=0</span></span><br><span class="line"><span class="comment"> *      从第一个字符和第二个字符开始比较：</span></span><br><span class="line"><span class="comment"> *            1、 j == 0              ---&gt;  next[i+1] = 1</span></span><br><span class="line"><span class="comment"> *            2、 p第j个数 == s第i个数  ---&gt; next[i+1] = j+1</span></span><br><span class="line"><span class="comment"> *            3、 p第j个数 != s第i个数  ---&gt; j按照next规则回退</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2、新建长度比p长1的nextval数组 进一步优化</span></span><br><span class="line"><span class="comment"> * 3、next数组和nextval数组的前2个值是固定的 0 0</span></span><br><span class="line"><span class="comment"> * 4、match比较s和p，匹配规则同next匹配规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*   </span></span><br><span class="line"><span class="comment"> *    1 2 3 4 5 6 7   ：下标</span></span><br><span class="line"><span class="comment"> *    A B A A B C A   ：字符</span></span><br><span class="line"><span class="comment"> *  0 0 1 1 2 2 3 1   ：next数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    1 2 3</span></span><br><span class="line"><span class="comment"> *    A A B</span></span><br><span class="line"><span class="comment"> *  0 0 1 2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   1、next数组的长度是 p.size() + 1，第一个数和最后一个数不被检测(求next数组的时候最后一个被比较的是size-2，size-1已经无法跳转了)</span></span><br><span class="line"><span class="comment"> *      i代表的是s遍历的位置(第几个数,也就是下标为[i-1],实际上比较的也是这个下标位置,例如第1个数，下标为0)</span></span><br><span class="line"><span class="comment"> *   同理j代表的是p遍历的位置(第几个数,也就是下标为[j-1],实际上比较的也是这个下标位置,例如第2个数，下标为1)</span></span><br><span class="line"><span class="comment"> *      初始化 i = 1， j = 0 //错位比较, 且默认 next[1] = 0, next[2] = 1</span></span><br><span class="line"><span class="comment"> *      第二个位置比较出错，从第一个数开始重新比较，这点与暴力解是相同的</span></span><br><span class="line"><span class="comment"> *    2、i=1, j=0 =&gt; i=2, j=1 =&gt; 比较p[1]和p[0]的值，</span></span><br><span class="line"><span class="comment"> *          如果相同例如      AAB</span></span><br><span class="line"><span class="comment"> *          则 next[3] = 2,代表如果：</span></span><br><span class="line"><span class="comment"> *          j = 3,在比较p第3个数(下标j-1=2)时比较失败，则j=next[3]=2，下次跳转去比较第二个数(下标j-1=1)</span></span><br><span class="line"><span class="comment"> *    3、后续j回退最多退到0，但是next[i]的赋值不可能小于1，代表最差也是从第一个数开始比较</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    情况可以分为：</span></span><br><span class="line"><span class="comment"> *    1、 j == 0  ---&gt;  next[i+1] = 1</span></span><br><span class="line"><span class="comment"> *    2、 p第j个数 == s第i个数  ---&gt; next[i+1] = j+1</span></span><br><span class="line"><span class="comment"> *    3、 p第j个数 != s第i个数  ---&gt; j按照next规则回退</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;next)</span></span>&#123;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span> ; i &lt; p.size() ; ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || p[i<span class="number">-1</span>] == p[j<span class="number">-1</span>])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*              1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment"> *              A B A B A A A B A</span></span><br><span class="line"><span class="comment"> * next       0 0 1 1 2 3 4 2 2 3</span></span><br><span class="line"><span class="comment"> * nextval    0 0 1 0 1 0 4 2 1 0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * if( p[j] == p[next[j]]) nextval[j] = nextval[next[j]]</span></span><br><span class="line"><span class="comment"> * if( p[j] != p[next[j]]) nextval[j] = next[j]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nextval</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;p, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;next, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nextval)</span></span>&#123;</span><br><span class="line">    nextval = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(next.begin(), next.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= p.size(); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[j<span class="number">-1</span>] == p[next[j] - <span class="number">1</span>])&#123;</span><br><span class="line">            nextval[j] = nextval[next[j]];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nextval[j] = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;next)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * KMP算法遇到不匹配不是抛弃不可能的组合，而是尽可能去尝试可能的组合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * s为主串，匹配下标是i， p为模式串，匹配下标是j</span></span><br><span class="line"><span class="comment">     * 终止条件是如果p最后一个字符串也匹配通过 or s的字符已经被匹配完</span></span><br><span class="line"><span class="comment">     * 匹配的方式与求next数组的方式是相同的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> compare_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; i &lt;= s.size() &amp;&amp; j &lt;= p.size() ; ) &#123;</span><br><span class="line">        ++compare_cnt;</span><br><span class="line">        <span class="keyword">if</span> ( j == <span class="number">0</span> || s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] )&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                --compare_cnt;<span class="comment">//j==0的时候没有发生比较</span></span><br><span class="line">            &#125;</span><br><span class="line">            ++j;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;compare &quot;</span> &lt;&lt; compare_cnt &lt;&lt; <span class="string">&quot; times &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; p.size())&#123;</span><br><span class="line">        <span class="keyword">return</span> i - p.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">&quot;aaaaaaacaaaaaaaab&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> p = <span class="string">&quot;aaaaaaaab&quot;</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(p.size()+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    get_next(p, next);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextval;</span><br><span class="line">    get_nextval(p, next, nextval);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n:next)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n:nextval)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---- use next -------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    match(s, p, next);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---- use nextval ----&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    match(s, p, nextval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>KMP</tag>
        <tag>字符串查找</tag>
      </tags>
  </entry>
  <entry>
    <title>SAT问题和DPLL算法</title>
    <url>/2021/01/12/SAT%E9%97%AE%E9%A2%98%E5%92%8CDPLL%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>SAT百科的解释是：在计算机科学中，布尔可满足性问题（有时称为命题可满足性问题，缩写为SATISFIABILITY或SAT）是确定是否存在满足给定布尔公式的解释的问题。也就是说给定一个逻辑命题，判断是否存在<strong>一组</strong>解(变量取True or False)使得命题结果为True。例如： P /\ Q 就是SAT的，当P、Q都为T的时候命题为T。SAT问题如果用暴力解法的话需要对每一个变量分别取T或者F然后判断逻辑命题的值，n个变量的时间复杂度为O(2^n)，这显然是无法接受的。SAT问题也是第一个被证明为<a href="https://baike.baidu.com/item/NP-Complete/15961931?fr=aladdin">NPC问题</a></p>
 <a id="more"></a>

<h2 id="DPLL"><a href="#DPLL" class="headerlink" title="DPLL"></a>DPLL</h2><p>SAT问题在常规暴力解下时间复杂度是不可满足的，DPLL算法将命题拆分成若干个子命题的合取，然后采用试错回溯的方法判断命题是否是可满足的，最坏情况下仍是指数级别的复杂度，但是在一般情况下通过选取变量的顺序(可以按照出现次数由高到低)进行简化</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>自动化解决大致需要以下几个步骤：建模成逻辑命题 =&gt; 转换蕴含式( P-&gt;Q 转换为 !P / Q) =&gt; 转换为否定范式NNF( !(P/\Q) 转换为!P / !Q ) =&gt; 转换为合取范式cnf ( 类似于这种若干个自命题的合取(p1 / !p2) /\ (p3 / !p4) ) 。转换蕴含式是简化最终每个自命题的判断逻辑，因为蕴含式与否定和合取的组合是等价的 。转换为否定范式NNF的作用是让否定直接作用在单个命题上，这样当p1取值为T或者F的时候可以直接计算消去这个否定。转换为合取范式cnf的作用是当计算的当前子命题是F的时候剩余的子命题就无需计算了整个命题肯定是F</p>
<h3 id="z3下的DPLL"><a href="#z3下的DPLL" class="headerlink" title="z3下的DPLL"></a>z3下的DPLL</h3><p>z3是由微软公司开发的一个优秀的SMT求解器（也就定理证明器），它能够检查逻辑表达式的可满足性。<br>dpll的大致思路如图：<img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4/dpll_1587958789244.jpg" alt="dpll"><br>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpll(P)&#123;</span><br><span class="line">  if(P&#x3D;&#x3D;T)</span><br><span class="line">    return sat;</span><br><span class="line">  if(P&#x3D;&#x3D;F)</span><br><span class="line">    return unsat;</span><br><span class="line"></span><br><span class="line">  unitProp(P);  &#x2F;&#x2F; unit prop and simplify P</span><br><span class="line">  x &#x3D; select_atomic(P); &#x2F;&#x2F; choose an atomic prop</span><br><span class="line">  if(dpll(P[x|-&gt;T])) &#x2F;&#x2F; splitting</span><br><span class="line">    return sat;</span><br><span class="line">  return dpll(P[x|-&gt;F]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于python-z3库的DPLL算法实现"><a href="#基于python-z3库的DPLL算法实现" class="headerlink" title="基于python z3库的DPLL算法实现"></a>基于python z3库的DPLL算法实现</h3><p>首先改写原逻辑命题成CNF形式，然后D-compiler部分是根据cnf转换规则转换为合取子命题，众多的合取命题就可以使用DPLL算法处理了，在拆分的过程中这里没有按照变量的多少而是总是简单选择第一个变量进行赋值传播。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Rules <span class="keyword">for</span> converting into CNF:</span><br><span class="line">C(p)     = p</span><br><span class="line">C(~p)   = ~p</span><br><span class="line">C(P/\Q) = C(P) /\ C(Q)</span><br><span class="line">C(P\/Q) = D(C(P), C(Q))</span><br><span class="line"></span><br><span class="line">D(P=P1/\P2, Q)  = D(P1, Q) /\ D(P2, Q)</span><br><span class="line">D(P, Q=Q1/\Q2) = D(P, Q1) /\ D(P, Q2)</span><br><span class="line">D(P, Q)              = P \/ Q</span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># In this problem, you will implement the DPLL algorithm as discussed</span></span><br><span class="line"><span class="comment"># in the class.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># a utility class to represent the code you should fill in.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">########################################</span></span><br><span class="line"><span class="comment"># This bunch of code declare the syntax for the propositional logic, we</span></span><br><span class="line"><span class="comment"># repeat here:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">P ::= p</span></span><br><span class="line"><span class="string">    | T</span></span><br><span class="line"><span class="string">    | F</span></span><br><span class="line"><span class="string">    | P /\ P</span></span><br><span class="line"><span class="string">    | P \/ P</span></span><br><span class="line"><span class="string">    | P -&gt; P</span></span><br><span class="line"><span class="string">    | ~P</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prop</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropVar</span>(<span class="params">Prop</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, var</span>):</span></span><br><span class="line">        self.var = var</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropTrue</span>(<span class="params">Prop</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropFalse</span>(<span class="params">Prop</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropAnd</span>(<span class="params">Prop</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, left, right</span>):</span></span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropOr</span>(<span class="params">Prop</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, left, right</span>):</span></span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropImplies</span>(<span class="params">Prop</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, left, right</span>):</span></span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropNot</span>(<span class="params">Prop</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, p</span>):</span></span><br><span class="line">        self.prop = p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#####################</span></span><br><span class="line"><span class="comment"># We define pretty printing function.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left_paren</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;(&#x27;</span>, sep=<span class="string">&#x27;&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right_paren</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;)&#x27;</span>, sep=<span class="string">&#x27;&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改了not的print</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pp</span>(<span class="params">prop</span>):</span></span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropVar:</span><br><span class="line">        print(prop.var, sep=<span class="string">&#x27;&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropTrue:</span><br><span class="line">        print(<span class="string">&#x27;True&#x27;</span>, sep=<span class="string">&#x27;&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropFalse:</span><br><span class="line">        print(<span class="string">&#x27;False&#x27;</span>, sep=<span class="string">&#x27;&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropAnd:</span><br><span class="line">        left_paren()</span><br><span class="line">        pp(prop.left)</span><br><span class="line">        right_paren()</span><br><span class="line">        print(<span class="string">&#x27;/\\&#x27;</span>, sep=<span class="string">&#x27;&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        left_paren()</span><br><span class="line">        pp(prop.right)</span><br><span class="line">        right_paren()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropOr:</span><br><span class="line">        left_paren()</span><br><span class="line">        pp(prop.left)</span><br><span class="line">        right_paren()</span><br><span class="line">        print(<span class="string">&#x27;\\/&#x27;</span>, sep=<span class="string">&#x27;&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        left_paren()</span><br><span class="line">        pp(prop.right)</span><br><span class="line">        right_paren()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropImplies:</span><br><span class="line">        left_paren()</span><br><span class="line">        pp(prop.left)</span><br><span class="line">        right_paren()</span><br><span class="line">        print(<span class="string">&#x27;-&gt;&#x27;</span>, sep=<span class="string">&#x27;&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        left_paren()</span><br><span class="line">        pp(prop.right)</span><br><span class="line">        right_paren()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropNot:</span><br><span class="line">        print(<span class="string">&#x27;!(&#x27;</span>, sep=<span class="string">&#x27;&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        pp(prop.prop)</span><br><span class="line">        right_paren()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># we can convert the above defined syntax into Z3&#x27;s representation, so</span></span><br><span class="line"><span class="comment"># that we can check it&#x27;s validity easily:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toz3</span>(<span class="params">prop</span>):</span></span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropVar:</span><br><span class="line">        <span class="keyword">return</span> Bool(prop.var)</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropImplies:</span><br><span class="line">        <span class="keyword">return</span> Implies(toz3(prop.left), toz3(prop.right))</span><br><span class="line">    <span class="comment"># Todo: add your code to handle other cases:</span></span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropAnd:</span><br><span class="line">        <span class="keyword">return</span> And(toz3(prop.left), toz3(prop.right))</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropOr:</span><br><span class="line">        <span class="keyword">return</span> Or(toz3(prop.left), toz3(prop.right))</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropNot:</span><br><span class="line">        <span class="keyword">return</span> Not(toz3(prop.prop))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#####################</span></span><br><span class="line"><span class="comment"># a sample test program:</span></span><br><span class="line">prop = PropImplies(PropVar(<span class="string">&#x27;p&#x27;</span>), PropImplies(PropVar(<span class="string">&#x27;q&#x27;</span>), PropVar(<span class="string">&#x27;p&#x27;</span>)))</span><br><span class="line"><span class="comment"># prop = PropNot(PropOr(PropAnd(PropVar(&#x27;p&#x27;),PropNot(PropVar(&#x27;q&#x27;))), PropOr(PropVar(&#x27;r&#x27;), PropNot(PropVar(&#x27;s&#x27;)))))</span></span><br><span class="line"><span class="comment"># prop = PropOr(PropAnd(PropNot(PropVar(&#x27;p&#x27;)), PropVar(&#x27;q&#x27;)), PropAnd(PropNot(PropVar(&#x27;q&#x27;)), PropVar(&#x27;s&#x27;)),)</span></span><br><span class="line"><span class="comment"># prop = PropAnd(PropOr(PropNot(PropVar(&#x27;p1&#x27;)), PropNot(PropVar(&#x27;p2&#x27;))), PropOr(PropVar(&#x27;p2&#x27;), PropVar(&#x27;p4&#x27;)))</span></span><br><span class="line"><span class="comment"># prop = PropAnd(PropVar(&#x27;p&#x27;), PropNot(PropVar(&#x27;p&#x27;)))</span></span><br><span class="line">print(<span class="string">&quot;target prop:&quot;</span>)</span><br><span class="line">pp(prop)</span><br><span class="line">print()</span><br><span class="line">z3prop = toz3(prop)</span><br><span class="line">print(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">print(z3prop)</span><br><span class="line">solver = Solver()</span><br><span class="line">solver.add(Not(z3prop))</span><br><span class="line">print(solver.check())</span><br><span class="line"><span class="comment">#####################</span></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> please implement the nnf(), cnf() and dpll() algorithm, as discussed</span></span><br><span class="line"><span class="comment"># in the class.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除蕴含式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeImplies</span>(<span class="params">prop</span>):</span></span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropImplies:</span><br><span class="line">        left = removeImplies(prop.left)</span><br><span class="line">        right = removeImplies(prop.right)</span><br><span class="line">        <span class="keyword">return</span> PropOr(PropNot(left), right)</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropVar:</span><br><span class="line">        <span class="keyword">return</span> prop</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropNot:</span><br><span class="line">        ret = removeImplies(prop.prop)</span><br><span class="line">        <span class="keyword">return</span> PropNot(ret)</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropAnd:</span><br><span class="line">        left = removeImplies(prop.left)</span><br><span class="line">        right = removeImplies(prop.right)</span><br><span class="line">        <span class="keyword">return</span> PropAnd(left,right)</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropOr:</span><br><span class="line">        left = removeImplies(prop.left)</span><br><span class="line">        right = removeImplies(prop.right)</span><br><span class="line">        <span class="keyword">return</span> PropOr(left,right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># toNNF</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doNNF</span>(<span class="params">prop</span>):</span></span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropNot:</span><br><span class="line">        tmp = prop.prop</span><br><span class="line">        <span class="keyword">if</span> tmp.__class__ == PropAnd:</span><br><span class="line">            left = doNNF(PropNot(tmp.left))</span><br><span class="line">            right = doNNF(PropNot(tmp.right))</span><br><span class="line">            <span class="keyword">return</span> PropOr(left, right)</span><br><span class="line">        <span class="keyword">if</span> tmp.__class__ == PropOr:</span><br><span class="line">            left = doNNF(PropNot(tmp.left))</span><br><span class="line">            right = doNNF(PropNot(tmp.right))</span><br><span class="line">            <span class="keyword">return</span> PropAnd(left, right)</span><br><span class="line">        <span class="keyword">if</span> tmp.__class__ == PropNot:</span><br><span class="line">            ret = doNNF(tmp.prop)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">if</span> tmp.__class__ == PropVar:</span><br><span class="line">            <span class="keyword">return</span> prop</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropVar:</span><br><span class="line">         <span class="keyword">return</span> prop</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropAnd:</span><br><span class="line">        left = doNNF(prop.left)</span><br><span class="line">        right = doNNF(prop.right)</span><br><span class="line">        <span class="keyword">return</span> PropAnd(left, right)</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropOr:</span><br><span class="line">        left = doNNF(prop.left)</span><br><span class="line">        right = doNNF(prop.right)</span><br><span class="line">        <span class="keyword">return</span> PropOr(left, right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nnf</span>(<span class="params">prop</span>):</span></span><br><span class="line">    <span class="comment"># pp(removeImplies(prop))</span></span><br><span class="line">    <span class="keyword">return</span> doNNF(removeImplies(prop))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># D compiler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parserD</span>(<span class="params">prop</span>):</span></span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropOr:</span><br><span class="line">        left = prop.left</span><br><span class="line">        right = prop.right</span><br><span class="line">        <span class="keyword">if</span> left.__class__ == PropAnd:</span><br><span class="line">            childLeft = PropOr(left.left, right)</span><br><span class="line">            childright = PropOr(left.right, right)</span><br><span class="line">            retLeft =  parserD(childLeft)</span><br><span class="line">            retRight = parserD(childright)</span><br><span class="line">            <span class="keyword">return</span> PropAnd(retLeft, retRight)</span><br><span class="line">        <span class="keyword">if</span> right.__class__ == PropAnd:</span><br><span class="line">            childLeft = PropOr(left, right.left)</span><br><span class="line">            childright = PropOr(left, right.right)</span><br><span class="line">            retLeft =  parserD(childLeft)</span><br><span class="line">            retRight = parserD(childright)</span><br><span class="line">            <span class="keyword">return</span> PropAnd(retLeft, retRight)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = parserD(prop.left)</span><br><span class="line">            right = parserD(prop.right)</span><br><span class="line">            <span class="keyword">return</span> PropOr(left, right)</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropVar <span class="keyword">or</span> prop.__class__ == PropNot:</span><br><span class="line">        <span class="keyword">return</span> prop</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropAnd:</span><br><span class="line">        left = parserD(prop.left)</span><br><span class="line">        right = parserD(prop.right)</span><br><span class="line">        <span class="keyword">return</span> PropAnd(left, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cnf</span>(<span class="params">prop</span>):</span></span><br><span class="line">    <span class="keyword">return</span> parserD(prop)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 化简Not 和 And Or</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simplify</span>(<span class="params">prop</span>):</span></span><br><span class="line">    <span class="comment"># pp(prop)</span></span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropNot:</span><br><span class="line">        tmp = prop.prop</span><br><span class="line">        <span class="keyword">if</span> tmp.__class__ == PropNot:</span><br><span class="line">            <span class="keyword">return</span> simplify(tmp)</span><br><span class="line">        <span class="keyword">if</span> tmp.__class__ == PropTrue:</span><br><span class="line">            <span class="keyword">return</span> PropFalse()</span><br><span class="line">        <span class="keyword">if</span> tmp.__class__ == PropFalse:</span><br><span class="line">            <span class="keyword">return</span> PropTrue()</span><br><span class="line">        <span class="keyword">return</span> prop</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropOr:</span><br><span class="line">        left = simplify(prop.left)</span><br><span class="line">        right = simplify(prop.right)</span><br><span class="line">        <span class="keyword">if</span> left.__class__ == PropTrue <span class="keyword">or</span> right.__class__ == PropTrue:</span><br><span class="line">            <span class="keyword">return</span> PropTrue()</span><br><span class="line">        <span class="keyword">if</span> left.__class__ == PropFalse:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> right.__class__ == PropFalse:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> PropOr(left, right)</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropAnd:</span><br><span class="line">        left = simplify(prop.left)</span><br><span class="line">        right = simplify(prop.right)</span><br><span class="line">        <span class="keyword">if</span> left.__class__ == PropFalse <span class="keyword">or</span> right.__class__ == PropFalse:</span><br><span class="line">            <span class="keyword">return</span> PropFalse()</span><br><span class="line">        <span class="keyword">if</span> left.__class__ == PropTrue <span class="keyword">and</span> right.__class__ == PropTrue:</span><br><span class="line">            <span class="keyword">return</span> PropTrue()</span><br><span class="line">        <span class="keyword">return</span> PropAnd(left, right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> prop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按顺序取第一个 p</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectFirstP</span>(<span class="params">prop</span>):</span></span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropVar:</span><br><span class="line">        <span class="keyword">return</span> prop</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropNot:</span><br><span class="line">        <span class="keyword">return</span> selectFirstP(prop.prop)</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropAnd <span class="keyword">or</span> prop.__class__ == PropOr:</span><br><span class="line">        left = selectFirstP(prop.left)</span><br><span class="line">        <span class="keyword">if</span> left.__class__ == PropTrue <span class="keyword">or</span> left.__class__ == PropFalse:</span><br><span class="line">            <span class="keyword">return</span> selectFirstP(prop.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropTrue <span class="keyword">or</span> prop.__class__ == PropFalse:</span><br><span class="line">        <span class="keyword">return</span> prop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在prop中递归给x赋值为setBool</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">propagate</span>(<span class="params">prop, x, setBool</span>):</span></span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropVar:</span><br><span class="line">        <span class="keyword">if</span> prop.var == x.var:</span><br><span class="line">            <span class="keyword">if</span> setBool <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                ret = PropTrue()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret = PropFalse()</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> prop</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropNot:</span><br><span class="line">        ret = propagate(prop.prop, x, setBool)</span><br><span class="line">        <span class="keyword">return</span> PropNot(ret)</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropOr:</span><br><span class="line">        left = propagate(prop.left, x, setBool)</span><br><span class="line">        right = propagate(prop.right, x, setBool)</span><br><span class="line">        <span class="keyword">return</span> PropOr(left, right)</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropAnd:</span><br><span class="line">        left = propagate(prop.left, x, setBool)</span><br><span class="line">        right = propagate(prop.right, x, setBool)</span><br><span class="line">        <span class="keyword">return</span> PropAnd(left, right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> prop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dpll</span>(<span class="params">prop</span>):</span></span><br><span class="line">    prop = simplify(prop)</span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropTrue:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;sat&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> prop.__class__ == PropFalse:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;unsat&#x27;</span></span><br><span class="line"></span><br><span class="line">    x = selectFirstP(prop)</span><br><span class="line">    print(<span class="string">&quot;choose &quot;</span>+x.var)</span><br><span class="line">    <span class="comment"># 需要多次化简的可能存在simplify不彻底，没有化简成最简形式</span></span><br><span class="line">    <span class="keyword">if</span> x.__class__ == PropTrue <span class="keyword">or</span> x.__class__ == PropFalse:</span><br><span class="line">        <span class="keyword">return</span> dpll(x)</span><br><span class="line">    xSetTrue = propagate(prop, x, <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> dpll(xSetTrue) == <span class="string">&#x27;sat&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;sat&#x27;</span></span><br><span class="line">    xSetFalse = propagate(prop, x, <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">return</span> dpll(xSetFalse)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#####################</span></span><br><span class="line"><span class="comment"># Don&#x27;t forget to write test cases to test your solution.</span></span><br><span class="line">print()</span><br><span class="line">print(<span class="string">&quot;After nnf and cnf :&quot;</span>)</span><br><span class="line">pp(cnf(nnf(prop)))</span><br><span class="line">print()</span><br><span class="line">print(dpll(cnf(nnf(prop))))</span><br><span class="line"><span class="comment"># nnf(prop)</span></span><br><span class="line"><span class="comment"># pp(nnf(prop))</span></span><br><span class="line"><span class="comment"># print(&quot;\n&quot;)</span></span><br></pre></td></tr></table></figure>
<hr>
<p>输出如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">target prop:</span><br><span class="line">(p)-&gt;((q)-&gt;(p))</span><br><span class="line"></span><br><span class="line">Implies(p, Implies(q, p))</span><br><span class="line">unsat</span><br><span class="line"></span><br><span class="line">After nnf <span class="keyword">and</span> cnf :</span><br><span class="line">(!(p))\/((!(q))\/(p))</span><br><span class="line">choose p</span><br><span class="line">sat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line"></span><br><span class="line">target prop:</span><br><span class="line">!(((p)/\(!(q)))\/((r)\/(!(s))))</span><br><span class="line"></span><br><span class="line">Not(Or(And(p, Not(q)), Or(r, Not(s))))</span><br><span class="line">sat</span><br><span class="line"></span><br><span class="line">After nnf <span class="keyword">and</span> cnf :</span><br><span class="line">((!(p))\/(q))/\((!(r))/\(s))</span><br><span class="line">choose p</span><br><span class="line">choose q</span><br><span class="line">choose r</span><br><span class="line">choose s</span><br><span class="line">sat</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>形式化方法</tag>
        <tag>SAT</tag>
        <tag>DPLL</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP连接与阻塞IO模型</title>
    <url>/2021/02/16/TCP%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>有台阿里云的Server闲置，做一些TCP连接相关的学习与简单测试</p>
 <a id="more"></a>

<p>Server环境：</p>
<ul>
<li>centos</li>
<li>Python 2.7.5</li>
</ul>
<h3 id="echo-Server端"><a href="#echo-Server端" class="headerlink" title="echo-Server端"></a>echo-Server端</h3><p>简单的echo_tcp_server.py 返回客户端发送的内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;&#x27;</span></span><br><span class="line">PORT = <span class="number">8080</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line">tcp_server_socket = socket(AF_INET, SOCK_STREAM)  <span class="comment"># step1: socket()</span></span><br><span class="line">tcp_server_socket.bind(ADDR)  <span class="comment"># step2: bind()</span></span><br><span class="line">tcp_server_socket.listen(<span class="number">10</span>)  <span class="comment"># parameter: backlog size, step3: listen()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    print(<span class="string">&quot;listen...&quot;</span>)</span><br><span class="line">    tcp_client_sock, addr = tcp_server_socket.accept()  <span class="comment"># step4: accept()</span></span><br><span class="line">    print(<span class="string">&quot;connect...&quot;</span>)  <span class="comment"># connect with client</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = tcp_client_sock.recv(BUFSIZE)  <span class="comment"># step5:read()</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(<span class="built_in">str</span>(data))</span><br><span class="line">        tcp_client_sock.send(data)  <span class="comment"># step6:write()</span></span><br><span class="line">    tcp_client_sock.close()</span><br><span class="line">tcp_server_socket.close()</span><br></pre></td></tr></table></figure>
<p>修改成可执行权限，启动，然后</p>
<h3 id="本地启动echo-tcp客户端1-Python3-8"><a href="#本地启动echo-tcp客户端1-Python3-8" class="headerlink" title="本地启动echo-tcp客户端1(Python3.8)"></a>本地启动echo-tcp客户端1(Python3.8)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pip._vendor.distlib.compat <span class="keyword">import</span> raw_input</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;101.200.158.XXX&#x27;</span></span><br><span class="line">PORT = <span class="number">8080</span>  <span class="comment"># 需要云主机开放的端口</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tcp_client</span>():</span></span><br><span class="line">    tcp_client_socket = socket(AF_INET, SOCK_STREAM)  <span class="comment"># step1: socket()</span></span><br><span class="line">    tcp_client_socket.connect(ADDR)  <span class="comment"># step2: connect()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = raw_input(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        tcp_client_socket.send(<span class="built_in">bytes</span>(data, <span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># step3:write(),默认阻塞</span></span><br><span class="line">        recv = tcp_client_socket.recv(BUFSIZE)  <span class="comment"># step4:read(),默认阻塞</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> recv:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(<span class="built_in">str</span>(recv, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    tcp_client_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    tcp_client()</span><br></pre></td></tr></table></figure>
<p>输入输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Server端：</span><br><span class="line">  listen...</span><br><span class="line">  connect...</span><br><span class="line">  111</span><br><span class="line">  222</span><br><span class="line">Client1端：</span><br><span class="line">  &gt; 111</span><br><span class="line">  111</span><br><span class="line">  &gt; 222</span><br><span class="line">  222</span><br></pre></td></tr></table></figure>
<p>这是三次握手后，echo测试，结果是正常的</p>
<h3 id="这时候同时启动Client端2去连接会发生什么"><a href="#这时候同时启动Client端2去连接会发生什么" class="headerlink" title="这时候同时启动Client端2去连接会发生什么"></a>这时候同时启动Client端2去连接会发生什么</h3><p>客户端1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 111</span><br><span class="line">111</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>
<p>客户端2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 22</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Server端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen...</span><br><span class="line">connect...</span><br><span class="line">111</span><br></pre></td></tr></table></figure>
<p>并没有接收到客户端2发送的内容</p>
<p>参考连接图：</p>
<p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/hexo/tcp%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B.png" alt="tcp连接"></p>
<p>此时TCP-Server端已经被阻塞在于Client1连接的write系统调用处，所以无法响应Client2的connect请求，而客户端2被阻塞在三次握手位置，此时如果断开客户端1的连接，会出现：</p>
<p>Server端，断开与客户端1的连接，重新回到listen状态，然后accept了客户端2（证明客户端2发往Server端的连接没有被drop掉）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen...</span><br><span class="line">connect...</span><br><span class="line">111</span><br><span class="line">listen...</span><br><span class="line">connect...</span><br><span class="line">22</span><br></pre></td></tr></table></figure>
<p>客户端1主动close连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 111</span><br><span class="line">111</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>客户端2，得到服务器的返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 22</span><br><span class="line">22</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>


<h3 id="阻塞IO下模拟fork操作"><a href="#阻塞IO下模拟fork操作" class="headerlink" title="阻塞IO下模拟fork操作"></a>阻塞IO下模拟fork操作</h3><p>Linux下可以fork出子进程来处理IO，主进程处理TCP连接，这里使用多线程来模拟fork操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;&#x27;</span></span><br><span class="line">PORT = <span class="number">8080</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_tcp_server</span>(<span class="params">client_socket, addr</span>):</span></span><br><span class="line">    print(<span class="string">&quot;connect...&quot;</span>)  <span class="comment"># connect with client</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = client_socket.recv(BUFSIZE)  <span class="comment"># step5:read()</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(<span class="built_in">str</span>(data))</span><br><span class="line">        client_socket.send(data)  <span class="comment"># step6:write()</span></span><br><span class="line">    client_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tcp_servers</span>():</span></span><br><span class="line">    tcp_server_socket = socket(AF_INET, SOCK_STREAM)  <span class="comment"># step1: socket()</span></span><br><span class="line">    tcp_server_socket.bind(ADDR)  <span class="comment"># step2: bind()</span></span><br><span class="line">    tcp_server_socket.listen(<span class="number">10</span>)  <span class="comment"># parameter: backlog size, step3: listen()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">&quot;listen...&quot;</span>)</span><br><span class="line">        tcp_client_sock, addr = tcp_server_socket.accept()  <span class="comment"># step4: accept()</span></span><br><span class="line">        t = Thread(target=one_tcp_server, args=(tcp_client_sock, addr))</span><br><span class="line">        t.start()</span><br><span class="line">    tcp_server_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    tcp_servers()</span><br></pre></td></tr></table></figure>
<p>再用客户端1和客户端2去尝试连接：</p>
<p>客户端1后输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; from客户端1</span><br><span class="line">from客户端1</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>
<p>客户端2先输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; from客户端2</span><br><span class="line">from客户端2</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>
<p>Server端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connect...</span><br><span class="line">listen...</span><br><span class="line">connect...</span><br><span class="line">listen...</span><br><span class="line">from客户端2</span><br><span class="line">from客户端1</span><br></pre></td></tr></table></figure>
<p>这里TCP Server端的主线程会阻塞在accept()处直到有连接请求，一旦建立连接后，会启动一个线程去处理IO事件，并不影响处理下一个accept请求，相对只有一个主线程的情况下会更高效，但是这种模式也存在问题：</p>
<h4 id="问题1：创建线程花费时间长"><a href="#问题1：创建线程花费时间长" class="headerlink" title="问题1：创建线程花费时间长"></a>问题1：创建线程花费时间长</h4><p>这里也可以事先创建N个线程，然后事件到达的时候从线程队列中取出去执行，这样减少了创建线程的开销，否则服务器在大量请求connect连接同时到达的时候压力会很大</p>
<h4 id="问题2：资源占用问题"><a href="#问题2：资源占用问题" class="headerlink" title="问题2：资源占用问题"></a>问题2：资源占用问题</h4><p>由于TCP是长连接，如果1000个连接中平均只有几十个是保持活跃的，这时候去维护1000个线程队列明显是不明智的。这就需要异步IO，改用事件触发的机制来处理IO操作</p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>TCP</tag>
        <tag>网络编程</tag>
        <tag>IO模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP &amp; IOC</title>
    <url>/2021/01/12/Spring-AOP-IOC/</url>
    <content><![CDATA[<p>Spring已经成为Java的另一个名字</p>
 <a id="more"></a>

<h3 id="Spring-AOP与代理"><a href="#Spring-AOP与代理" class="headerlink" title="Spring-AOP与代理"></a>Spring-AOP与代理</h3><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理可以分成两个部分，第一个部分是实现代理的本质需求，找中介买房的话那么卖房就是这个本质需求，在这里中介和房东必须都有卖房这个方法才能代理，也就是说中介和房东都需要实现saleHouse()的接口，只不过中介.saleHouse()的内部是实际的房东.saleHouse().静态代理的第二个部分是在不修改源代码的基础上可扩展，中介可以有自己的方法，在代理类中实现即可，无需改动原房东的部分。<br>可以看出其实静态代理的实质就是新增了一个类，核心需求是调用原实体类的方法，其他部分可以自定义，在不改动的基础上进行扩展，但是它的劣势也就是一个实体类需要一个代理类，代码量double</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理 = 静态代理 + 反射，同一个接口的实现类，可以通过反射找到它的class和method，JDK中使用Interface InvocationHandler和Class Proxy实现动态代理。<br>InvocationHandler这个接口中只有一个方法，invoke(Object proxy, 方法 method, Object[] args)，这个方法用于处理代理实例上的方法并返回结果， Proxy类可以生成代理对象如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Foo f &#x3D; (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),</span><br><span class="line">                                          new Class&lt;?&gt;[] &#123; Foo.class &#125;,</span><br><span class="line">                                          handler); </span><br></pre></td></tr></table></figure>
<h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zfeiyu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被代理类对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(), </span><br><span class="line">                target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        doBeforeInvoke();</span><br><span class="line">        Object ret = method.invoke(target, objects);</span><br><span class="line">        doAfterInvoke();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBeforeInvoke</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterInvoke</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>在面向对象的过程中考虑的最小模块是类，而在AOP面向切面编程的过程中考虑的是模块，它旨在提供另一种编程的思路，AOP用于Spring的声明式事务或者用户自定义的切面。从刚才的example中可以看出在动态代理的过程中可以插入自定义的doBefore或者After这种公共动作，AOP就是将这些公共动作抽取成一个类，这个类即是切面aspect，通过配置pointcut切入点和通知类型可以将类中的这些方法以不同形式切入被代理的target方法。</p>
<p>如图：<br><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4/AOP_1589612782417.jpg" alt="AOP"></p>
<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="依赖倒置？"><a href="#依赖倒置？" class="headerlink" title="依赖倒置？"></a>依赖倒置？</h3><p>在网上查阅了部分资料，Spring的IOC使得开发更加便利，底层之间复杂的依赖关系交由Spring进行处理这点是毋庸置疑的，还有的观点说IOC遵循了依赖倒置的原则，例如同样设计一辆车，可以从先造一个合适的轮子(比如17寸可能是个不错的选择)-&gt;根据轮子造底盘-&gt;根据底盘造车身-&gt;整车，也可以反过来整车-&gt;车身-&gt;底盘-&gt;轮子，反过来的意思是：如果我想造辆车，一个正常的车是需要一个车身的，同理一个正常的底盘不能没有轮胎，但是这并不意味着轮胎必须要按照17寸的，可以随时提供一个，只要是合格的底盘轮胎即可。<br>这里反着来的部分我认为其实并不算严格意义上的依赖，底盘还是需要轮胎，只不过从具体的角度来说，一个轮胎只要是复合底盘的就是合格的，单纯看这一个局部是符合依赖倒置的原则，所以依赖注入可以认为是 底盘依赖合适的轮胎，17寸轮胎插入底盘可以看成这个依赖关系注入进来，实现了反转</p>
<h3 id="依赖图"><a href="#依赖图" class="headerlink" title="依赖图"></a>依赖图</h3><p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4/IOC.jpg" alt="依赖图"></p>
<h3 id="IOC的XML"><a href="#IOC的XML" class="headerlink" title="IOC的XML"></a>IOC的XML</h3><p>IOC的XML实现配置中bean可以约等于：对象-id = new class地址，ref也是同样的道理，所以IOC是不是等价于简单的在原来的面向对象基础上增加了setter等接口呢，我认为这只是表象，IOC的灵魂在于bean容器的依赖管理</p>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>从上述图片中还可以看出，当每一个配件的选型达到上百种时，无论哪种建造方法要去一一查找构造函数、setter或者接口等注入方式是及其复杂的，所以我认为IOC的更主要的便捷体现在对于依赖的管理上，它让程序员可以从复杂的依赖关系中抽离出来而由框架来完成查找和装配</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>AOP</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title>c++插入迭代器的insert</title>
    <url>/2021/01/21/c-%E6%8F%92%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84insert/</url>
    <content><![CDATA[<p>c++ primer在插入迭代器中说insert会将元素插入到给定迭代器所表示的元素之前，在P359插入迭代器的位置给到关于insert的一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">copy(lst.cbegin(), lst.cend(), insert(lst3, lst3.begin()));</span><br></pre></td></tr></table></figure>
<p>拷贝完lst3是什么样的呢？每次插入都是在begin()位置吗？</p>
 <a id="more"></a>

<p>拷贝完的lst3是{1,2,3,4}，按照书中的说法每次插入都是在lst3.begin()前，在插入第一个元素1之后，lst3.begin()实际上应该指向1所在的位置之前，也就是说插入2的时候应该出现{2,1}而不是{1,2}，难道insert在插入之后迭代器自增了？</p>
<p>查看了Cpp reference中关于inserter的部分:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line">  <span class="function">insert_iterator&lt;Container&gt; <span class="title">inserter</span> <span class="params">(Container&amp; x, <span class="keyword">typename</span> Container::iterator it)</span></span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Parameters</span><br><span class="line">x</span><br><span class="line">Container on which the iterator will insert <span class="keyword">new</span> elements.</span><br><span class="line">Container should be a container class with member insert defined.</span><br><span class="line">it</span><br><span class="line">Iterator pointing to the insertion point.</span><br><span class="line">This shall be a <span class="keyword">mutable</span> iterator (<span class="keyword">not</span> a <span class="keyword">const</span> iterator).</span><br></pre></td></tr></table></figure>
<p>第二个迭代器的参数需要是一个可变的，而不是const的迭代器，且迭代器指向插入的位置，一开始让我很疑惑，如果迭代器一直指向插入的位置，为什么不直接让它变成const不改变呢，仔细一想发现如下理由：</p>
<ul>
<li>插入的操作会使得迭代器失效</li>
<li>更新迭代器需要一个非const的迭代器</li>
</ul>
<p>这样来说，对于第一个例子，如果beg = lst3.begin()；inserter理论上会执行如下的操作：</p>
<ol>
<li>auto tmp = beg + 1;</li>
<li>insert插入到beg位置</li>
<li>insert(lst3, tmp);</li>
</ol>
<p>使用vector来写一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dst;</span><br><span class="line">    <span class="keyword">auto</span> beg = dst.begin();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;beg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    copy(vec.cbegin(),vec.cend(), inserter(dst, beg));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;n : dst)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;beg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (beg == dst.end()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x7ffee98d38e8</span><br><span class="line">1 2 3 4 </span><br><span class="line">0x7ffee98d38e8</span><br><span class="line">0</span><br></pre></td></tr></table></figure>


<p>在insert(lst3, lst3.begin())里lst3.begin()实际上是一个可变的恒等于lst3的尾迭代器，传入的参数只被使用了一次，这里的lst3.begin()很具有迷惑性</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>coq逻辑定理证明</title>
    <url>/2021/01/12/coq%E9%80%BB%E8%BE%91%E5%AE%9A%E7%90%86%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<p>coq是一个非自动化的定理证明工具，需要使用者按照语法来推导证明</p>
 <a id="more"></a>

<p>coq的证明格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Theorem ident body: type.</span><br><span class="line">Proof.</span><br><span class="line">    Tactics</span><br><span class="line">Qed.</span><br><span class="line">    </span><br></pre></td></tr></table></figure>


<p>主要的证明过程在Tactics这里，Tactics大致有以下几种：</p>
<ul>
<li>intros:对于类似p-&gt;q这种形式 intros.可以看成将p-&gt;q分解成前提p，需证q的格式</li>
<li>apply:当给定前提中出现和goal或者subgoal相同的部分时可以使用apply对应的前提,也可以是 apply Hi in (Hi的前提)</li>
<li>inversion: 前提的tactics，作用于合取式拆分 p/\q, 等价于destruct H as [Hp Hq];作用于析取式拆分 p/q 等价于destruct H as [Hp | Hq]</li>
<li>split: goal的合取式拆分 p/\q</li>
<li>left 和 right: goal的析取式拆分</li>
</ul>
<hr>
<p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4/coq_1588476963394.jpg" alt="简图"></p>
<hr>
<p>tactic：</p>
<ul>
<li>(P / Q) -&gt; 这种前提在goal展开前destruct到需要的部分</li>
<li>尝试intro去除-&gt;</li>
<li>复杂的前提destruct可以尝试inversion</li>
<li>一阶谓词的前提可以destruct将谓词和命题拆分</li>
</ul>
<hr>
<p>example1：证明：∃x.~P(x) -&gt; ~(∀x.P(x))</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Theorem exerc6 :</span><br><span class="line">  (exists x:A, ~ P x ) -&gt; ~ ( forall x:A, P x ).</span><br><span class="line">Proof.</span><br><span class="line"></span><br><span class="line">此时显示为：</span><br><span class="line"></span><br><span class="line">1 subgoal</span><br><span class="line">______________________________________(1&#x2F;1)</span><br><span class="line">(exists x : A, ~ P x) -&gt; ~ (forall x : A, P x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第一步：去除否定not</span><br><span class="line">unfold not.</span><br><span class="line"></span><br><span class="line">此时显示为：</span><br><span class="line"></span><br><span class="line">1 subgoal</span><br><span class="line">______________________________________(1&#x2F;1)</span><br><span class="line">(exists x : A, P x -&gt; False) -&gt; (forall x : A, P x) -&gt; False</span><br><span class="line"></span><br><span class="line">第二步 intro</span><br><span class="line"></span><br><span class="line">此时显示为：</span><br><span class="line"></span><br><span class="line">1 subgoal</span><br><span class="line">H : exists x : A, P x -&gt; False</span><br><span class="line">H0 : forall x : A, P x</span><br><span class="line">______________________________________(1&#x2F;1)</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">理解为已知 H 求证 H0 为 F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第三步   destruct H as [a P].</span><br><span class="line"></span><br><span class="line">此时显示为：</span><br><span class="line"></span><br><span class="line">1 subgoal</span><br><span class="line">a : A</span><br><span class="line">P : P a -&gt; False</span><br><span class="line">H0 : forall x : A, Top.P x</span><br><span class="line">______________________________________(1&#x2F;1)</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">这一步要将谓词分离 以便于apply P，其实是将上一步的 exists进行拆分了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第四步 apply P.</span><br><span class="line"></span><br><span class="line">此时显示为：</span><br><span class="line"></span><br><span class="line">1 subgoal</span><br><span class="line">a : A</span><br><span class="line">P : P a -&gt; False</span><br><span class="line">H0 : forall x : A, Top.P x</span><br><span class="line">______________________________________(1&#x2F;1)</span><br><span class="line">Top.P a</span><br><span class="line"></span><br><span class="line">待证内容变成了 P.a, 这一步等价于已知 a属于P为F，欲证F，证明a属于P即可。H0的含义是：对于A的所有x都满足属性P，故下一步apply H0可得证</span><br><span class="line"></span><br><span class="line">第五步 apply H0.</span><br><span class="line"></span><br><span class="line">No more subgoals.</span><br><span class="line"></span><br><span class="line">Qed.</span><br></pre></td></tr></table></figure>
<hr>
<p>example2 :证明 ∀x.(P(x) -&gt; ~Q(x)) -&gt; ~(∃x.(P(x) /\ Q(x)))<br>上面的例子可以看到证明的过程是非自动化的，也就是说对于待证的命题最好先分析下从哪个地方入手.上述命题其实并非是一个等价的推导，是一个大范围内求证一个小范围</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Theorem exerc10 :</span><br><span class="line">  (forall x:A,  P x -&gt; (~ Q x) ) -&gt; ~ ( exists x:A, P x &#x2F;\ Q x ).</span><br><span class="line"></span><br><span class="line">此时显示为：</span><br><span class="line">1 subgoal</span><br><span class="line">______________________________________(1&#x2F;1)</span><br><span class="line">(forall x : A, P x -&gt; ~ Q x) -&gt; ~ (exists x : A, P x &#x2F;\ Q x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第一步 intros. </span><br><span class="line"></span><br><span class="line">此时显示为：</span><br><span class="line"></span><br><span class="line">1 subgoal</span><br><span class="line">H : forall x : A, P x -&gt; ~ Q x</span><br><span class="line">______________________________________(1&#x2F;1)</span><br><span class="line">~ (exists x : A, P x &#x2F;\ Q x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二步 unfold not.</span><br><span class="line"></span><br><span class="line">此时显示为：</span><br><span class="line"></span><br><span class="line">1 subgoal</span><br><span class="line">H : forall x : A, P x -&gt; ~ Q x</span><br><span class="line">______________________________________(1&#x2F;1)</span><br><span class="line">(exists x : A, P x &#x2F;\ Q x) -&gt; False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第三步 intros. </span><br><span class="line"></span><br><span class="line">此时显示为：</span><br><span class="line"></span><br><span class="line">1 subgoal</span><br><span class="line">H : forall x : A, P x -&gt; ~ Q x</span><br><span class="line">H0 : exists x : A, P x &#x2F;\ Q x</span><br><span class="line">______________________________________(1&#x2F;1)</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">说明： 这里说下为什么不直接unfold not然后intros. 因为后面需要assert引入 H 的结论，~ Q x是可以声明的， Q x -&gt; False这种方式我试过不行，也可能是assert语法的格式不对</span><br><span class="line"></span><br><span class="line">第四步   destruct H0 as [a H1].   destruct H1 as [H2 H3].</span><br><span class="line"></span><br><span class="line">此时显示为：</span><br><span class="line"></span><br><span class="line">1 subgoal</span><br><span class="line">H : forall x : A, P x -&gt; ~ Q x</span><br><span class="line">a : A</span><br><span class="line">H2 : P a</span><br><span class="line">H3 : Q a</span><br><span class="line">______________________________________(1&#x2F;1)</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">第五步   assert( f : ~ Q a ). 这一步是要将False转为 Q x 与 ~ Q x同时存在的矛盾关系</span><br><span class="line"></span><br><span class="line">此时显示为：</span><br><span class="line"></span><br><span class="line">2 subgoals</span><br><span class="line">H : forall x : A, P x -&gt; ~ Q x</span><br><span class="line">a : A</span><br><span class="line">H2 : P a</span><br><span class="line">H3 : Q a</span><br><span class="line">______________________________________(1&#x2F;2)</span><br><span class="line">~ Q a</span><br><span class="line">______________________________________(2&#x2F;2)</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">第六步   apply H.     apply H2.  </span><br><span class="line"></span><br><span class="line">此时显示为：</span><br><span class="line"></span><br><span class="line">1 subgoal</span><br><span class="line">H : forall x : A, P x -&gt; ~ Q x</span><br><span class="line">a : A</span><br><span class="line">H2 : P a</span><br><span class="line">H3 : Q a</span><br><span class="line">f : ~ Q a</span><br><span class="line">______________________________________(1&#x2F;1)</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">第七步   apply f.     apply H3.     在第六步结束的时候已经可以看出 H3与f是不可能同时存在的关系 </span><br><span class="line"></span><br><span class="line">Qed.</span><br></pre></td></tr></table></figure>
<p>事实上通过对tactic的组合使用coq在排中律的前提下可以解决很多复杂的逻辑命题</p>
]]></content>
      <tags>
        <tag>形式化方法</tag>
        <tag>coq</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp的默认初始化</title>
    <url>/2021/02/28/cpp%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>c++ 默认初始化构造出来的对象在内存中是什么样的，堆和栈中默认初始化出来的有没有区别？</p>
 <a id="more"></a>

<h3 id="使用默认初始化分布构造位于全局变量、堆和栈中的对象，代码如下："><a href="#使用默认初始化分布构造位于全局变量、堆和栈中的对象，代码如下：" class="headerlink" title="使用默认初始化分布构造位于全局变量、堆和栈中的对象，代码如下："></a>使用默认初始化分布构造位于全局变量、堆和栈中的对象，代码如下：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Foo* ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Foo bar;</span><br><span class="line">    <span class="keyword">if</span>(bar.val || bar.ptr)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; bar.val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; (bar.ptr == <span class="literal">nullptr</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *iptr;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (iptr == <span class="literal">nullptr</span>)&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查看内存布局："><a href="#查看内存布局：" class="headerlink" title="查看内存布局："></a>查看内存布局：</h3><p>Clion可以在debugger的时候对变量右击使用 show in memory view 查看内存布局，如果是 vs 可以使用 clang -Xclang -fdump-record-layouts 命令（没试过），下面分别查看内存布局：</p>
<p>Foo bar 是创建于堆上，而 func 函数中的局部变量 a 创建于栈中，int 型指针 iptr 是全局变量</p>
<p>变量 Foo bar的内存布局如图，其中int型变量占四个字节，而指针型变量在64位环境中占用8个字节，考虑内存对齐，共占用16个字节 ：</p>
<p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com//hexo/image-20210228095649257.png" alt="image-20210228095649257"></p>
<p>func 函数的变量 a ：</p>
<p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com//hexo/image-20210228095503711.png" alt="image-20210228095503711"></p>
<p>全局变量 iptr ：</p>
<p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com//hexo/image-20210228095922071.png" alt="image-20210228095922071"></p>
<h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><p>对应布局，执行结果很明显了，下面给出我的机器上跑出的结果，堆栈中的变量在内存中的初始化值其实结果是依赖上次使用的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">0x7ffee77c28ec</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>全局变量的内存保证会在初始化的时候被清为 0，但是 局部变量（分配在栈中）和分配在堆（ Heap ）中的变量 在内存中都不会自动被清为 0，它们在内存中的值是上次使用的值 。所以在使用的堆栈中的变量一定要先初始化，否则行为是未定义的</p>
<p>参考：</p>
<ul>
<li>深度探索c++对象模型</li>
</ul>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>dp问题</title>
    <url>/2021/01/12/dp%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>学习动态规划给我一种考研做拉格朗日中值定理的感觉，脑子说会了，这玩意很简单。手说：不，你不会</p>
 <a id="more"></a>

<p>求解类型：计数种类求解–dp，输出每种具体的种类–递归</p>
<p>dp题目的特点：</p>
<ul>
<li>计数：<ul>
<li>多少种方式走到右下角</li>
<li>多少种方式选出k个数和为sum</li>
</ul>
</li>
<li>求最大最小值：<ul>
<li>路劲最大数字和</li>
<li>最长上升子序列</li>
</ul>
</li>
<li>求存在性：<ul>
<li>石子游戏，先手是否必胜</li>
<li>能不能选出k个数使得和是sum</li>
</ul>
</li>
</ul>
<p>计算步骤：</p>
<ol>
<li>确定状态：<ul>
<li>研究最优解的最后一步</li>
<li>转化为子问题</li>
</ul>
</li>
<li>子问题 =&gt; 转移方程</li>
<li>初始条件和边界条件</li>
<li>计算顺序</li>
</ol>
<h4 id="5627-石子游戏-VII"><a href="#5627-石子游戏-VII" class="headerlink" title="5627. 石子游戏 VII"></a><a href="https://leetcode-cn.com/problems/stone-game-vii/">5627. 石子游戏 VII</a></h4><p>难度中等11</p>
<p>石子游戏中，爱丽丝和鲍勃轮流进行自己的回合，<strong>爱丽丝先开始</strong> 。</p>
<p>有 <code>n</code> 块石子排成一排。每个玩家的回合中，可以从行中 <strong>移除</strong> 最左边的石头或最右边的石头，并获得与该行中剩余石头值之 <strong>和</strong> 相等的得分。当没有石头可移除时，得分较高者获胜。</p>
<p>鲍勃发现他总是输掉游戏（可怜的鲍勃，他总是输），所以他决定尽力 <strong>减小得分的差值</strong> 。爱丽丝的目标是最大限度地 <strong>扩大得分的差值</strong> 。</p>
<p>给你一个整数数组 <code>stones</code> ，其中 <code>stones[i]</code> 表示 <strong>从左边开始</strong> 的第 <code>i</code> 个石头的值，如果爱丽丝和鲍勃都 <strong>发挥出最佳水平</strong> ，请返回他们 <strong>得分的差值</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：stones &#x3D; [5,3,1,4,2]</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">- 爱丽丝移除 2 ，得分 5 + 3 + 1 + 4 &#x3D; 13 。游戏情况：爱丽丝 &#x3D; 13 ，鲍勃 &#x3D; 0 ，石子 &#x3D; [5,3,1,4] 。</span><br><span class="line">- 鲍勃移除 5 ，得分 3 + 1 + 4 &#x3D; 8 。游戏情况：爱丽丝 &#x3D; 13 ，鲍勃 &#x3D; 8 ，石子 &#x3D; [3,1,4] 。</span><br><span class="line">- 爱丽丝移除 3 ，得分 1 + 4 &#x3D; 5 。游戏情况：爱丽丝 &#x3D; 18 ，鲍勃 &#x3D; 8 ，石子 &#x3D; [1,4] 。</span><br><span class="line">- 鲍勃移除 1 ，得分 4 。游戏情况：爱丽丝 &#x3D; 18 ，鲍勃 &#x3D; 12 ，石子 &#x3D; [4] 。</span><br><span class="line">- 爱丽丝移除 4 ，得分 0 。游戏情况：爱丽丝 &#x3D; 18 ，鲍勃 &#x3D; 12 ，石子 &#x3D; [] 。</span><br><span class="line">得分的差值 18 - 12 &#x3D; 6 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：stones &#x3D; [7,90,5,1,100,10,10,2]</span><br><span class="line">输出：122</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameVII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(stones.size()+<span class="number">1</span>, <span class="number">0</span>)</span></span>; </span><br><span class="line">        <span class="comment">// 使用前缀和来求两个下标之间的和，数组长度需要+1</span></span><br><span class="line">        <span class="comment">// [i, j]的和 = 累加到j位置的和 - 累加到i-1位置的和</span></span><br><span class="line">                <span class="comment">//   = sum[j+1] - sum[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;stones.size() ; ++i)&#123;</span><br><span class="line">            sum[i+<span class="number">1</span>] = sum[i] + stones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1.确定状态 =&gt; 研究最优解的最后一步，转为子问题</span></span><br><span class="line"><span class="comment">            2.子问题得到转移方程</span></span><br><span class="line"><span class="comment">            3.起始条件和边界条件</span></span><br><span class="line"><span class="comment">            4.计算顺序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            本题：</span></span><br><span class="line"><span class="comment">            1.最后一步是&quot;没有石头可以移除的时候，得分高的获胜&quot;，往回倒退：</span></span><br><span class="line"><span class="comment">              如果只剩一个石头，移除得分0，再倒回一步</span></span><br><span class="line"><span class="comment">              如果剩余两个石头，[1, 4]则移除1，得分4，下一个回合的人得分是0</span></span><br><span class="line"><span class="comment">              子问题：对于[i, j]下标的序列，移除最左侧i还是最右侧j使得</span></span><br><span class="line"><span class="comment">                爱丽丝和鲍勃都发挥出最佳水平(最大限度地扩大与下一轮得分的差值)</span></span><br><span class="line"><span class="comment">                本回合的得分与下回合的得分差值(dp[i][j] - dp[i+1][j]或dp[i][j] - dp[i][j-1])最大</span></span><br><span class="line"><span class="comment">            2.定义dp[i][j] = 从i到j的得分差值，这是要求的返回值，但是最优的条件是与下一轮的差值最大：</span></span><br><span class="line"><span class="comment">                移除i位置：本轮得分是sum[j+1]-sum[i+1],下轮对手得分是dp[i+1][j]</span></span><br><span class="line"><span class="comment">                移除j位置：本轮得分是sum[j]-sum[i],下轮对手得分是dp[i][j-1]</span></span><br><span class="line"><span class="comment">                差值最大：</span></span><br><span class="line"><span class="comment">                dp[i][j] = max(sum[j+1]-sum[i+1] - dp[i+1][j], </span></span><br><span class="line"><span class="comment">                                sum[j]-sum[i] - dp[i][j-1])</span></span><br><span class="line"><span class="comment">            3.起始条件：</span></span><br><span class="line"><span class="comment">                在这里困扰了我很久，刚开始设想的是能不能扫描一次确定一个最优的最后一个移除的石头位置，然后倒推</span></span><br><span class="line"><span class="comment">                实际上如果把这个作为起始条件是无法通过O(n)来得出这个位置的</span></span><br><span class="line"><span class="comment">                如果抽象的不确定石头的位置而是通过i与j之间的距离来度量的话(相当于推广着来看,对每个可能的距离实际都会求一次),结合步骤1有：</span></span><br><span class="line"><span class="comment">                如果 j-i == 0, dp[i][j] = 0;//i==j,只有一个石头，移除后得分是0</span></span><br><span class="line"><span class="comment">                    j-i == 1, dp[i][j] = max(stones[i], stones[j]);//参考步骤1，这是实际的初始条件</span></span><br><span class="line"><span class="comment">                所以 j=i+1可以作为起始条件，也就是只有两个石头的情况，比两个石头更少的都是0</span></span><br><span class="line"><span class="comment">                返回的结果是dp[0, len-1]</span></span><br><span class="line"><span class="comment">            4.计算顺序：</span></span><br><span class="line"><span class="comment">                一开始写成这样的循环结果答案不正确</span></span><br><span class="line"><span class="comment">                for(int i=0 ; i&lt;stones.size() ; ++i)&#123;</span></span><br><span class="line"><span class="comment">                    for(int j=i+1 ; j&lt;stones.size() ; ++j)&#123; </span></span><br><span class="line"><span class="comment">                        if(j-i == 1)&#123;</span></span><br><span class="line"><span class="comment">                            dp[i][j] = max(stones[i], stones[j]);</span></span><br><span class="line"><span class="comment">                        &#125;else&#123;</span></span><br><span class="line"><span class="comment">                            dp[i][j] = max(sum[j+1]-sum[i+1] - dp[i+1][j], sum[j]-sum[i] - dp[i][j-1]);</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                        .....</span></span><br><span class="line"><span class="comment">                可以看到因为在求解的过程中dp[i][j]用到了 dp[i+1][j]和dp[i][j-1]，例如dp[0][5]用到了dp[1][5]和dp[0][4]</span></span><br><span class="line"><span class="comment">                可以看出 i需要用到比i大的部分(从右到左)而j需要用到比j小的部分(从左到右)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(stones.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(stones.size(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=stones.size()<span class="number">-2</span> ; i&gt;=<span class="number">0</span> ; --i)&#123;<span class="comment">//i=stones.size()-1的情况下只有一个石头，得分是0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span> ; j&lt;stones.size() ; ++j)&#123; <span class="comment">//j==i的情况已经设置过默认值了</span></span><br><span class="line">                <span class="keyword">if</span>(j-i == <span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j] = max(stones[i], stones[j]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = max(sum[j+<span class="number">1</span>]-sum[i+<span class="number">1</span>] - dp[i+<span class="number">1</span>][j], sum[j]-sum[i] - dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][stones.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h4><p>难度中等367</p>
<p>给定一个整数数组 <code>prices</code>，其中第 <code>i</code> 个元素代表了第 <code>i</code> 天的股票价格 ；非负整数 <code>fee</code> 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2</span><br><span class="line">输出: 8</span><br><span class="line">解释: 能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] &#x3D; 1</span><br><span class="line">在此处卖出 prices[3] &#x3D; 8</span><br><span class="line">在此处买入 prices[4] &#x3D; 4</span><br><span class="line">在此处卖出 prices[5] &#x3D; 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8.</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li><code>0 &lt; prices.length &lt;= 50000</code>.</li>
<li><code>0 &lt; prices[i] &lt; 50000</code>.</li>
<li><code>0 &lt;= fee &lt; 50000</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.确定状态</span></span><br><span class="line"><span class="comment">            f[0][n-1] = max(f[0][i] + f[i+1][n-1])... </span></span><br><span class="line"><span class="comment">        2.状态方程</span></span><br><span class="line"><span class="comment">        3.初始条件</span></span><br><span class="line"><span class="comment">        4.顺序</span></span><br><span class="line"><span class="comment">        int len = prices.size();</span></span><br><span class="line"><span class="comment">        if(len == 0)&#123;</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt; dp(len, 0);</span></span><br><span class="line"><span class="comment">        for(int i=1 ; i&lt;len ; ++i)&#123;</span></span><br><span class="line"><span class="comment">            if(prices[i]-prices[i-1] &lt;= fee)&#123;</span></span><br><span class="line"><span class="comment">                dp[i] = dp[i-1];</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            dp[i] = dp[i-1];</span></span><br><span class="line"><span class="comment">            for(int j=0 ; j&lt;i ; ++j)&#123;</span></span><br><span class="line"><span class="comment">                int offset = prices[i] - prices[j] - fee + dp[j] ;</span></span><br><span class="line"><span class="comment">                dp[i] = max(dp[i], offset);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return dp[len-1];</span></span><br><span class="line"><span class="comment">        超时..</span></span><br><span class="line"><span class="comment">				复杂度超了，因为只考虑没有完全发挥dp的优势，中间的状态还是没有记录下来还是要二重循环的比较</span></span><br><span class="line"><span class="comment">				要考虑怎么在遍历中尽可能将不同的状态保存下来</span></span><br><span class="line"><span class="comment">				</span></span><br><span class="line"><span class="comment">				</span></span><br><span class="line"><span class="comment">        1、状态分为 持有或不持有,跟博弈问题一样，状态的关键在于</span></span><br><span class="line"><span class="comment">        如何将关键句&quot;如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了&quot;</span></span><br><span class="line"><span class="comment">        转化为状态</span></span><br><span class="line"><span class="comment">        2、如果当前状态为持有</span></span><br><span class="line"><span class="comment">        如果考虑从一个不持有的状态转化而来是要减去prices[i]的</span></span><br><span class="line"><span class="comment">        但是还是有可能比 上一个持有的状态大</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> len = prices.size();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(len, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ; i&lt;len ; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]-fee);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>博弈问题</tag>
      </tags>
  </entry>
  <entry>
    <title>git初学</title>
    <url>/2021/01/12/git%E5%88%9D%E5%AD%A6/</url>
    <content><![CDATA[<p>版本控制应该是现代开发的必备工具了，但是要想用好git确实不是特别简单的事，还需要多看多用</p>
 <a id="more"></a>

<p>git有一些基本概念：工作目录、对象库和索引</p>
<ul>
<li>工作目录就是你当前git本地使用的目录，编辑改动来实现一些新的功能</li>
<li>对象库是git实现的核心，每一次文件的提交，已提交文件的类型等。基础的数据结构有：块(每一个版本，不包含任何元数据)、目录树(块的目录等)、提交和标签(如498a5603，指定一次提交)。</li>
<li>索引是临时、动态的目录结构的索引。比如add之后，本地的索引就会更新</li>
</ul>
<p>git的结构：<br>工作目录 — 索引 — 版本库，索引成为当前工作目录和版本库的缓冲，当你add，rm之后，索引会立即进行更新，但是版本库只有在你commit之后才会进行更新</p>
<p>git如何区分改动：<br>git对每一个对象计算SHA1的160位的散列值，可以认为一个SHA1的散列值对应唯一的一个对象，这样就可以通过160位SHA1的比较来确定对象是否被改动过，例如一个大的文件A包含两个文件B和C，C在另一个版本库中被改为D，在比较的时候可以发现A的SHA1不同知道A被改动过，但是B的SHA1是相同的代表改动不在B文件内</p>
<p>git的分支：分支的作用=隔离版本、阶段、开发者等</p>
<p>git常见命令：</p>
<ul>
<li>status</li>
<li>add</li>
<li>rm</li>
<li>commit</li>
<li>diff</li>
</ul>
<p>git diff可以将结构中两个部分之间的差别以下列形式展示出来 :<br>‘’–’’代表的是 改动前<br>“++”代表的是 改动后<br>例如 ：@@ - 1,4 + 1,5表示的是 @@ -(改动前部分) 1 (从第一行开始) ,4 (共4行被改动) +(改动后部分) 1(同理), 5 @@</p>
<p>不同的diff命令比较的是不同的部分：<br>git diff：这里比较的是 <strong>已经更改未add(也就是比较 工作目录和索引)</strong><br>git diff HEAD：工作目录和版本库diff<br>git diff –cached：索引和版本库diff<br><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/hexo/git_diff.png" alt="image-20201014163646907"></p>
<p>一些示例：</p>
<p>常见的bitbicket git pull request流程如下：</p>
<ol>
<li><code>git clone</code></li>
<li><code>cd path</code></li>
<li><code>git checkout -b</code> + 分支名字：分支名字可以自己起，pull 的时候显示</li>
<li><code>git add</code> + 添加的文件名</li>
<li><code>git commit -m +</code> “提交备注”</li>
<li><code>git push origin </code>+ <strong>你的分支名字</strong></li>
<li><code>bitbicket</code> 网站上，去添加一个<code>pull request</code></li>
<li>从你的分支 到 <code>master</code> ：添加 <code>title 、reviewer</code></li>
</ol>
<hr>
<p>git rm :</p>
<ol>
<li>git rm 或 git rm -r</li>
<li>可选【git add】</li>
<li>git status</li>
<li>git commit -m “desc”</li>
<li>git push origin <strong>yourname</strong></li>
<li>有时候会出现reject，需要重新git pull origin <strong>yourname</strong></li>
</ol>
<hr>
<p>拉取特定的分支(未PUSH到远程仓库的)：<br>git remove add &lt; name &gt; &lt; url &gt;<br>然后git fetch &lt; name &gt;<br>IDEA中可以在branches中选择checkout还是merge into 当前目录</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo相关的两个shell脚本</title>
    <url>/2021/01/12/hexo%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%A4%E4%B8%AAshell%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>迁移博客到hexo是像让自己更关注博客内容而非博客样式，但是mac下hexo新建文章默认会生成一个”undefined)title.md”，无法自动命名并且写入需要修改文件权限，所以写了个脚本来一键新建打开编辑，顺便将部署也一起搞定</p>
 <a id="more"></a>

<p>update July 2023<br>use this new shell script</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># hexo new &quot;title&quot;</span><br><span class="line"># deploy script, run under hexo folder</span><br><span class="line">hexo clean</span><br><span class="line">rm -rf .deploy_git&#x2F;</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><p>例如command：Desktop/create_hexo.sh hexo相关shell脚本，脚本实现如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ $# != 1 ]; then</span><br><span class="line">    echo &quot;输入文章名&quot;</span><br><span class="line">exit 1;        </span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cd /Users/yufei/Desktop/hexo/blog/source/_posts/</span><br><span class="line">if [ -f &quot;undefined)title.md&quot; ]; then</span><br><span class="line">    echo &quot;已存在未初始化的新建文稿!&quot;</span><br><span class="line">exit 2;   </span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;1234&quot; |sudo -S cd /Users/yufei/Desktop/hexo/blog/</span><br><span class="line">echo &quot;1234&quot; |sudo -S hexo new &quot;$1&quot;</span><br><span class="line">echo &quot;1234&quot; |sudo -S cd /Users/yufei/Desktop/hexo/blog/source/_posts/</span><br><span class="line">echo &quot;1234&quot; |sudo -S chmod 777 undefined\)title.md</span><br><span class="line">echo &quot;1234&quot; |sudo -S mv &quot;undefined)title.md&quot; &quot;$1.md&quot;</span><br><span class="line">open &quot;$1.md&quot;</span><br></pre></td></tr></table></figure>
<p>因为mac下创建需要权限（也可能是我配置有问题），所以这里命令需要需要root权限，root密码我用1234代替，如果要使用需要改成自己的root密码和自己的hexo路径</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>这个很简单没什么可说的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">cd /Users/yufei/Desktop/hexo/blog/</span><br><span class="line">echo &quot;1234&quot; |sudo -S hexo g</span><br><span class="line">echo &quot;1234&quot; |sudo -S hexo d</span><br></pre></td></tr></table></figure>
<p>记得修改脚本的权限，这样就可以直接使用命令： /Users/yufei/Desktop/create_hexo.sh hexo相关shell脚本 来一键创建打开md文件，这篇文章就是这样创建的</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>shell</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda表达式</title>
    <url>/2021/01/12/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>lambda表达式：我们可以向一个算法传递任何类别的可调用对象，什么是可调用对象，lambda表达式又是如何实现？c++的语法结合lambda表达式让我对lambda表达式的理解更深</p>
 <a id="more"></a>

<p>可调用对象一共有四种：</p>
<ul>
<li>函数</li>
<li>函数指针</li>
<li>重载了函数调用符的类</li>
<li>lambda表达式</li>
</ul>
<p>一个lambda表达式的形式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[capture list捕获列表不可省略](para list) -&gt; return type &#123;function body不可省略&#125;</span><br></pre></td></tr></table></figure>
<p>捕获列表只用于当前函数内lambda函数外的局部变量，对于当前函数外的变量不需要捕获就可以直接使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findBigSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;vec, <span class="keyword">int</span> minimum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = partition(vec.begin(), vec.end(), [minimum](<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)-&gt;<span class="keyword">bool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.size() &gt;= minimum;</span><br><span class="line">    &#125;);</span><br><span class="line">    vec.erase(it, vec.end());</span><br><span class="line">    for_each(vec.cbegin(), vec.cend(), [](<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)-&gt;<span class="keyword">void</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;Enter strings, &#x27;quit&#x27; for Quit! &quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; str &amp;&amp; str != <span class="string">&quot;quit&quot;</span>)&#123;</span><br><span class="line">        vec.push_back(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;Enter minimum size:&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">string</span> num;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    findBigSize(vec, stoi(num));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个lambda表达式时，编译器生成一个与之相对应的类类型，使用lambda的时候实际上在使用这种类型的对象，默认情况下生成的类都包含一个在lambda所捕获的变量的数据成员，数据成员在创建lambda的时候被初始化，<strong>捕获的变量是在创建的时候拷贝，而不是调用的时候拷贝</strong>，lambda捕获的值也可以是引用，但是必须保证在lambda表达式调用的时候这个变量没有消亡</p>
<p>隐式捕获：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[=]值</span><br><span class="line"> [&amp;]引用</span><br><span class="line"> [=, &amp;val]</span><br><span class="line"> [&amp;, val]混合</span><br></pre></td></tr></table></figure>
<p>如果一个lambda表达式返回return之外的任何语句（如if..）,编译器会假定这个lambda返回void，需要制定返回类型</p>
<p>lambda表达式一个很大的优势在于，它可以灵活的适配那些需求指定了形参个数以及类型的地方，可以将一部分的形参移动到捕获列表中，使用bind也可以达到同样的效果，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders::_1;</span><br><span class="line"><span class="keyword">auto</span> bindFunction = bind(oldFunction, _1, arg2);<span class="comment">//这里标识以_开头标识调用bindFunction要传入的参数</span></span><br></pre></td></tr></table></figure>
<h3 id="lambda表达式的原理是什么呢？"><a href="#lambda表达式的原理是什么呢？" class="headerlink" title="lambda表达式的原理是什么呢？"></a>lambda表达式的原理是什么呢？</h3><p>首先来看看重载函数调用运算符”()”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintStr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    PrintStr(ostream &amp;o = <span class="built_in">cout</span>, <span class="keyword">char</span> ch = <span class="string">&#x27;-&#x27;</span>):os(o), seq(ch)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); ++i) &#123;</span><br><span class="line">            os &lt;&lt; str[i] &lt;&lt; seq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ostream &amp;os;</span><br><span class="line">    <span class="keyword">char</span> seq;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PrintStr ps;</span><br><span class="line">    ps(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以lambda表达式的处理方式是：编译器将该表达式翻译成一个未命名类的未命名对象，在lambda表达式产生的类中含有一个重载的函数调用运算符</p>
<p>lambda表达式、函数、函数对象类都如果接受同样的参数返回同样的类型，实际使用中可能希望把它们当成一类处理如set&lt;这一类&gt;，或者是函数表（vector、map的函数集合）但是实际上它们并不能简单归为一类混用，但是可以都当成function类型处理（标准库类型），例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;function&lt;<span class="keyword">int</span> (<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; functionSet;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>git rebase / squash to 1 commit</title>
    <url>/2023/07/16/rebase%E5%92%8Csquash/</url>
    <content><![CDATA[<ol>
<li><p>git rebase<br>git rebase 我通常会用于想在保留本地分支改动的同时拉取最新的master改动，然后将我们本地的commit移动到最后，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> feature branch A check out from the origin master</span><br><span class="line"> feature branch B check out from the origin master</span><br><span class="line"> featureA commit with commit1</span><br><span class="line"> featureB commit with commit2 and merge to origin master</span><br><span class="line"> featureA rebase origin master</span><br><span class="line"> featureA merge to origin master</span><br><span class="line">&#x2F;&#x2F; 此时 commit1 在git log中会位于commit2之后，尽管在rebase前 commit1先提交</span><br></pre></td></tr></table></figure>
</li>
<li><p>squash to 1 commit<br>方法1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; X equals to the commits you want to squash </span><br><span class="line">git rebase -i HEAD~[X]</span><br></pre></td></tr></table></figure>
<p>方法2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master and pull from origin master</span><br><span class="line">git checkout -b tmp_banch</span><br><span class="line">git merge --squash your_feature_branch</span><br><span class="line">git add and git commit</span><br><span class="line">git push -f origin tmp_branch:your_feature_branch</span><br></pre></td></tr></table></figure>
<p>推荐使用第二种方法，因为借助了临时分支，相当于做了一层保护，就算在这个临时分支上操作错误也不会影响到你的feature分支(force push前)</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>union的内存排列</title>
    <url>/2021/01/28/union%E7%9A%84%E5%86%85%E5%AD%98%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>union也叫联合体， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存。union的内存是如何分配的，是否可以按照联合体的每个分量不同的类型长度来不同的读取同样一片内存呢？</p>
 <a id="more"></a>

<h4 id="关于字节对齐"><a href="#关于字节对齐" class="headerlink" title="关于字节对齐"></a>关于字节对齐</h4><p>在c++中每种对象类型都有一个对齐要求(alignment requirement)的属性，这个属性的是size_t类型的且长度始终是2的幂，表示的是连续地址可分配这种对象的字节数。例如int就是4个字节</p>
<p>字节对齐测试：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">double</span> score;</span><br><span class="line">    &#125; struct_s;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//union:</span></span><br><span class="line">    <span class="comment">//The union is only as big as necessary to hold its largest data member.</span></span><br><span class="line">    <span class="comment">//The other data members are allocated in the same bytes as part of that largest member.</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">double</span> score;</span><br><span class="line">    &#125; union_s;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;struct size : &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(struct_s) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;union size : &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(union_s) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct size : 24      &#x2F;&#x2F; 0-9:char,  10-15:null, 16-23:double</span><br><span class="line">union size : 16       &#x2F;&#x2F;     0-9:char, 10-15:null  or  0-7:double, 8-15:null</span><br></pre></td></tr></table></figure>
<p>可以看出union和struct的一样都是可以填充以满足内部最大元素在连续内存的对齐，这种设计应该是为了方便指令寻址</p>
<p>union的共享内存特性可能会让人想做很多骚操作，想象int和char数组共享内存的时候能否在4个连续字节内存按照1个字节的大小来依次处理呢，事实上判断大小端可以用到：</p>
<h4 id="使用union判断大小端"><a href="#使用union判断大小端" class="headerlink" title="使用union判断大小端"></a>使用union判断大小端</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参考 &lt;Unix网络编程&gt; P64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">short</span> s;</span><br><span class="line">        <span class="keyword">char</span> c[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">    &#125; un;</span><br><span class="line"></span><br><span class="line">    un.s = <span class="number">0x0102</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">sizeof</span>(<span class="keyword">short</span>) == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(un.c[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; un.c[<span class="number">1</span>] == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; big-endian &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(un.c[<span class="number">1</span>] == <span class="number">1</span> &amp;&amp; un.c[<span class="number">0</span>] == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; little-endian &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;unknown&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size of &#x27;short&#x27; : &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">short</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试在windows上输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">little-endian</span><br></pre></td></tr></table></figure>
<p>那么union真的可以这么灵活吗</p>
<p>事实上c++是不允许union使用与上次不同的对象去访问的，这种行为是undefined未定义的，事实上可以自行在上面这个例子里使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; un.c[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>是没有输出的，必须要强制转换到合适的类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">&#125; test;</span><br><span class="line"></span><br><span class="line">test.s = <span class="number">0x01020304</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt;(test.c[i]) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>符合小端的内存增长方向，那么问题来了，c++里面到底是否支持这样的操作呢，查阅了一下资料，可以参考如下<a href="http://port70.net/~nsz/c/c11/n1570.html#note95">95</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">95) </span><br><span class="line">If the member used to read the contents of a union object is not the same as the member</span><br><span class="line">last used to store a value in the object, </span><br><span class="line">the appropriate part of the object representation of the value is reinterpreted as an </span><br><span class="line">object representation in the new type as described in 6.2.6 (a process sometimes called &#39;&#39;type punning&#39;&#39;). </span><br><span class="line">This might be a trap representation.</span><br></pre></td></tr></table></figure>
<p>翻译过来就是：如果用于读取联合对象的内容的成员与上次用于在对象中存储值的成员不同，则该值的对象表示的适当部分将重新解释为新类型的对象表示，也就是说在日常使用的时候就不要这样去尝试了，新类型的对象表示可能取决于不同的硬件，而当你没有使用正确的新类型去读取该片内存的时候是在做未定义的操作。事实上如果有这样的需求，没有理由不用vector</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>union</tag>
      </tags>
  </entry>
  <entry>
    <title>switch与ifelse</title>
    <url>/2023/07/18/switch%E4%B8%8Eifelse/</url>
    <content><![CDATA[<p>通常来说if else的使用频率要比Switch高很多，但是之前在工作中code review中别人的一条comments让我对Switch有了新的认识</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// origin code</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">mediaType</span> &#123;</span>Audio1, Audio2, Video1, Video2&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (media_type == MediaType::Audio1) &#123;</span><br><span class="line">    <span class="comment">// do something with type Audio 1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( media_type == MediaType::Video1 ) &#123;</span><br><span class="line">    <span class="comment">// do something with type Video 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出原代码只有对Audio1和Video1的处理，而PR中代码的改动增加了对于Audio2和Video2的处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// code for PR</span></span><br><span class="line"><span class="keyword">if</span> (media_type == MediaType::Audio1) &#123;</span><br><span class="line">    <span class="comment">// do something with type Audio 1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( media_type == MediaType::Audio2 ) &#123;</span><br><span class="line">    <span class="comment">// do something with type Video 2</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( media_type == MediaType::Video1 ) &#123;</span><br><span class="line">    <span class="comment">// do something with type Video 1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( media_type == MediaType::Video2 ) &#123;</span><br><span class="line">    <span class="comment">// do something with type Video 2</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>code review中建议将这段改为switch,理由是media type是一个在代码中大量被引用的基本类型，如果增加新的media type(例如Audio3)的话这里就必须cover Audio3的逻辑而不会遗漏，从而使得代码的扩展性更好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// will meet compile error if we not deal with all type in MediaType</span></span><br><span class="line"><span class="keyword">switch</span> (media_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> MediaType::Audio1 :</span><br><span class="line">        <span class="comment">// do something with type Audio 1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MediaType::Audio2 :</span><br><span class="line">        <span class="comment">// do something with type Audio 2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MediaType::Video1 :</span><br><span class="line">        <span class="comment">// do something with type Video 1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MediaType::Video2 :</span><br><span class="line">        <span class="comment">// do something with type Video 2</span></span><br><span class="line">        <span class="keyword">break</span>;        </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>webAssembly的wasm文件以及与JS的简单测试比较</title>
    <url>/2021/01/13/webAssembly%E7%AC%94%E8%AE%B0%E4%BB%A5%E5%8F%8A%E4%B8%8EJS%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p>webAssembly设计的目的不是为了手写代码而是为诸如C、C++和Rust等低级源语言提供一个高效的<strong>编译目标</strong>。为客户端app提供了一种在网络平台以接近本地速度的方式运行多种语言编写的代码的方式</p>
<p>优势：JS先通过解释器-优化器，wasm是先编译器-优化器</p>
<p>一些概念</p>
<ul>
<li><strong>模块</strong>：表示一个已经被浏览器编译为可执行机器码的WebAssembly二进制代码。一个模块是无状态的，并且像一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob">二进制大对象</a>（Blob）一样能够<a href="https://developer.mozilla.org/zh-CN/docs/WebAssembly/Caching_modules">被缓存到IndexedDB</a>中或者在windows和workers之间进行共享（通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessagePort/postMessage">postMessage()</a>函数）。一个模块能够像一个ES2015的模块一样声明导入和导出。</li>
<li><strong>内存</strong>：ArrayBuffer，大小可变。本质上是连续的字节数组，WebAssembly的低级内存存取指令可以对它进行读写操作。</li>
<li><strong>表格</strong>：带类型数组，大小可变。表格中的项存储了<strong>不能作为原始字节存储在内存里的对象</strong>的引用（为了安全和可移植性的原因）。</li>
<li><strong>实例</strong>：一个模块及其在运行时使用的所有状态，包括内存、表格和一系列导入值。一个实例就像一个已经被加载到一个拥有一组特定导入的特定的全局变量的ES2015模块。</li>
</ul>
<hr>
<p>编译过程：（环境配置参照<a href="https://developer.mozilla.org/zh-CN/docs/WebAssembly/C_to_wasm%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%83%B3%E5%AE%89%E8%A3%85%E5%8F%AF%E4%BB%A5%E8%B7%B3%E5%88%B0%E6%9C%AB%E5%B0%BE%E4%BD%BF%E7%94%A8studio%EF%BC%89">https://developer.mozilla.org/zh-CN/docs/WebAssembly/C_to_wasm，如果不想安装可以跳到末尾使用studio）</a></p>
<ol>
<li>.c和.cpp文件通过emcc编译成.wasm类型文件</li>
<li>在JavaScript文件中import.wasm，初始化成实例instance，对外暴露instance.exports的一些接口</li>
<li>在JavaScript中可以同时操作DOM和访问接口</li>
</ol>
<p>大致示意图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14594229-8f42add0c27377ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image-20201209135247222.png"></p>
<p>一个使用的实例，后面会解释：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在html中：&lt;script async type=&quot;text/javascript&quot; src=&quot;hello.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load the wasm module and create an instance of using native support in the JS engine.</span></span><br><span class="line">  <span class="comment">// handle a generated wasm instance, receiving its exports and</span></span><br><span class="line">  <span class="comment">// performing other necessary setup</span></span><br><span class="line">  <span class="comment">/** <span class="doctag">@param <span class="type">&#123;WebAssembly.Module=&#125;</span> </span>module*/</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">receiveInstance</span>(<span class="params">instance, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">exports</span> = instance.exports;</span><br><span class="line"></span><br><span class="line">    Module[<span class="string">&#x27;asm&#x27;</span>] = <span class="built_in">exports</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">exports</span>);</span><br><span class="line"></span><br><span class="line">    wasmMemory = Module[<span class="string">&#x27;asm&#x27;</span>][<span class="string">&#x27;memory&#x27;</span>];</span><br><span class="line">    assert(wasmMemory, <span class="string">&quot;memory not found in wasm exports&quot;</span>);</span><br><span class="line">    <span class="comment">// This assertion doesn&#x27;t hold when emscripten is run in --post-link</span></span><br><span class="line">    <span class="comment">// mode.</span></span><br><span class="line">    <span class="comment">// TODO(sbc): Read INITIAL_MEMORY out of the wasm file in post-link mode.</span></span><br><span class="line">    <span class="comment">//assert(wasmMemory.buffer.byteLength === 16777216);</span></span><br><span class="line">    updateGlobalBufferAndViews(wasmMemory.buffer);</span><br><span class="line"></span><br><span class="line">    wasmTable = Module[<span class="string">&#x27;asm&#x27;</span>][<span class="string">&#x27;__indirect_function_table&#x27;</span>];</span><br><span class="line">    assert(wasmTable, <span class="string">&quot;table not found in wasm exports&quot;</span>);</span><br><span class="line"></span><br><span class="line">    removeRunDependency(<span class="string">&#x27;wasm-instantiate&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<hr>
<p>Emscripten编译有很多种选择，其中有两种：</p>
<ul>
<li>编译生成HTML，并添加JavaScript</li>
<li>编译仅生成JavaScript</li>
</ul>
<p>转到一个已经配置过Emscripten编译环境的终端窗口中，进入刚刚保存hello.c文件的文件夹中，然后运行下列命令：emcc hello.c -s WASM=1 -o hello.html</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14594229-f8eb1f93ea280ded.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image-20201207163419037.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14594229-bdc0f12d6b27fa93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image-20201207165319307.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14594229-61063b0b9722b4cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image-20201207165354403.png"></p>
<p>在JavaScript中主要的调用方法为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = Module.ccall(<span class="string">&#x27;myFunction&#x27;</span>, <span class="comment">// name of C function</span></span><br><span class="line">    <span class="literal">null</span>, <span class="comment">// return type</span></span><br><span class="line">    <span class="literal">null</span>, <span class="comment">// argument types</span></span><br><span class="line">    <span class="literal">null</span>); <span class="comment">// arguments</span></span><br></pre></td></tr></table></figure>
<h6 id="加载和运行WebAssembly代码"><a href="#加载和运行WebAssembly代码" class="headerlink" title="加载和运行WebAssembly代码"></a>加载和运行WebAssembly代码</h6><p>为了在JavaScript中使用WebAssembly，在编译/实例化之前，你首先需要把<strong>模块</strong>放入<strong>内存</strong>。</p>
<p>当前并没有内置的方式让浏览器获取模块，唯一的方式是创建一个包含webAssembly模块的二进制代码的ArrayBuffer并且使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate"><code>WebAssembly.instantiate()</code></a>编译它</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;module.wasm&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="comment">//从&#x27;module.wasm&#x27;获取response并用arrayBuffer转换为带类型数组的promise</span></span><br><span class="line">  response.arrayBuffer()</span><br><span class="line">).then(<span class="function"><span class="params">bytes</span> =&gt;</span>  <span class="comment">//使用WebAssembly.instantiate一步实现编译和实例化带类型数组</span></span><br><span class="line">  WebAssembly.instantiate(bytes, importObject)</span><br><span class="line">).then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Do something with the compiled results!</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">bufferSource</span></span><br><span class="line"><span class="comment">一个包含你想编译的wasm模块二进制代码的 typed array(类型数组) or ArrayBuffer(数组缓冲区)</span></span><br><span class="line"><span class="comment">importObject 可选</span></span><br><span class="line"><span class="comment">一个将被导入到新创建实例中的对象，它包含的值有函数、WebAssembly.Memory 对象等等。编译的模块中，对于每一个导入的值都要有一个与其匹配的属性与之相对应，否则将会抛出 WebAssembly.LinkError。</span></span><br><span class="line"><span class="comment">返回值</span></span><br><span class="line"><span class="comment">解析为包含两个字段的 ResultObject 的一个 Promise:</span></span><br><span class="line"><span class="comment">module: 一个被编译好的 WebAssembly.Module 对象. 这个模块可以被再次实例化，通过 postMessage() 被分享，或者缓存到 IndexedDB。</span></span><br><span class="line"><span class="comment">instance: 一个包含所有 Exported WebAssembly functions的WebAssembly.Instance对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//XMLHttpRequest这种更清晰</span></span><br><span class="line">request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">request.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;simple.wasm&#x27;</span>);</span><br><span class="line">request.responseType = <span class="string">&#x27;arraybuffer&#x27;</span>;</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line">request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bytes = request.response;</span><br><span class="line">  WebAssembly.instantiate(bytes, importObject).then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    results.instance.exports.exported_func();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>JavaScript的Promise相关:<a href="https://blog.csdn.net/u013967628/article/details/86569262">https://blog.csdn.net/u013967628/article/details/86569262</a></p>
<p>indexDB缓存查找：（可以不看）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> openDatabase().then(</span><br><span class="line">        db=&gt; &#123;</span><br><span class="line">            <span class="comment">//module =&gt; 相当于一个匿名函数function(module)&#123;return WebAssembly.instantiate(module, importObject);&#125;,lookupInDatabase函数返回resolve的时候开始执行这个匿名函数</span></span><br><span class="line">            <span class="keyword">return</span> lookupInDatabase(db).then(</span><br><span class="line">                <span class="built_in">module</span> =&gt; &#123;</span><br><span class="line">                    <span class="comment">//找到缓存的$&#123;url&#125;</span></span><br><span class="line">                    <span class="keyword">return</span> WebAssembly.instantiate(<span class="built_in">module</span>, importObject);</span><br><span class="line">                &#125;,</span><br><span class="line">                errMsg =&gt; &#123;</span><br><span class="line">                    <span class="comment">//没找到缓存，从url获取，然后WebAssembly.instantiate</span></span><br><span class="line">                    <span class="comment">/* 从给定的url获取数据，将其编译成一个模块，并且使用给定的导入对象实例化该模块</span></span><br><span class="line"><span class="comment">                      function fetchAndInstantiate() &#123;</span></span><br><span class="line"><span class="comment">                        return fetch(url).then(response =&gt;</span></span><br><span class="line"><span class="comment">                          response.arrayBuffer()</span></span><br><span class="line"><span class="comment">                        ).then(buffer =&gt;</span></span><br><span class="line"><span class="comment">                          WebAssembly.instantiate(buffer, importObject)</span></span><br><span class="line"><span class="comment">                        )</span></span><br><span class="line"><span class="comment">                      &#125;</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">return</span> fetchAndInstantiate().then(</span><br><span class="line">                        results =&gt;&#123;</span><br><span class="line">                            <span class="comment">/*触发一个异步操作，从而在给定的数据库中存储给定的wasm模块</span></span><br><span class="line"><span class="comment">                              function storeInDatabase(db, module) &#123;</span></span><br><span class="line"><span class="comment">                                var store = db.transaction([storeName], &#x27;readwrite&#x27;).objectStore(storeName);</span></span><br><span class="line"><span class="comment">                                var request = store.put(module, url);// key, value形式存储</span></span><br><span class="line"><span class="comment">                                request.onerror = err =&gt; &#123; console.log(`Failed to store in wasm cache: $&#123;err&#125;`) &#125;;</span></span><br><span class="line"><span class="comment">                                request.onsuccess = err =&gt; &#123; console.log(`Successfully stored $&#123;url&#125; in wasm cache`) &#125;;</span></span><br><span class="line"><span class="comment">                              &#125;</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">                            storeInDatabase(db, results.module);<span class="comment">//参数是fetchAndInstantiate结果中的module</span></span><br><span class="line">                            <span class="keyword">return</span> results.instance;<span class="comment">//返回fetchAndInstantiate结果中的实例</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;,</span><br><span class="line">        errMsg =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchAndInstantiate().then(</span><br><span class="line">                results =&gt; results.instance</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缓存的版本号（可以不用），当任何wasm模块发生更新或者移动到不同的URL，你都需要更新它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wasmCacheVersion = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">instantiateCachedURL(wasmCacheVersion, <span class="string">&#x27;test.wasm&#x27;</span>).then(<span class="function"><span class="params">instance</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Instance says the answer is: &quot;</span> + instance.exports.answer())</span><br><span class="line">).catch(<span class="function"><span class="params">err</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&quot;Failure to instantiate: &quot;</span> + err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<p>instance.exports函数的特性：</p>
<ul>
<li>length属性 = 参数数量</li>
<li>name属性 = wasm模块中的索引调用toString()的返回值</li>
<li>不支持i64类型</li>
</ul>
<p>.wasm文件的结构：</p>
<p>使用S-表达式，是一个相对比较平的AST</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(module (memory 1) (func)) &#x2F;&#x2F;根是module，子树1是memory1，子树2是func</span><br><span class="line"></span><br><span class="line">函数的结构</span><br><span class="line">( func &lt;signature参数以及函数的返回值&gt; &lt;locals&gt; &lt;body&gt; )</span><br><span class="line"></span><br><span class="line">signature和locals可以通过get_local(int)读取:</span><br><span class="line">(func (param i32) (param f32) (local f64)</span><br><span class="line">  get_local 0</span><br><span class="line">  get_local 1</span><br><span class="line">  get_local 2)</span><br><span class="line">get_local 0会得到i32类型的参数</span><br><span class="line">get_local 1会得到f32类型的参数</span><br><span class="line">get_local 2会得到f64类型的局部变量</span><br><span class="line"></span><br><span class="line">	c语言函数</span><br><span class="line">    WASM_EXPORT</span><br><span class="line">    int add(int a, int b)&#123;</span><br><span class="line">      return a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	.wasm文件部分</span><br><span class="line">  (type $t2 (func (param i32 i32) (result i32)))</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;(export &quot;add&quot;)表示这个函数要被export让JavaScript来调用它</span><br><span class="line">  (func $add (export &quot;add&quot;) (type $t2) (param $p0 i32) (param $p1 i32) (result i32)</span><br><span class="line">    get_local $p1 &#x2F;&#x2F;这里使用了别名，包括上面的$t2代替数字，可读性更强</span><br><span class="line">    get_local $p0</span><br><span class="line">    i32.add &#x2F;&#x2F;虚拟机栈来执行指令，声明了返回值，指向到这里时栈中只剩余一个i32值来return</span><br><span class="line">    )</span><br><span class="line">    ..</span><br></pre></td></tr></table></figure>
<p>一个.wasm的示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#define WASM_EXPORT __attribute__((visibility(<span class="string">&quot;default&quot;</span>)))</span><br><span class="line">WASM_EXPORT</span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WASM_EXPORT <span class="comment">//对应后面的export&quot;add&quot;</span></span><br><span class="line">int <span class="function"><span class="title">add</span>(<span class="params">int a, int b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line">(<span class="built_in">module</span> <span class="comment">//所有的都在module内部</span></span><br><span class="line">  (type $t0 (func))</span><br><span class="line">  (type $t1 (func (result i32))) <span class="comment">//main function</span></span><br><span class="line">  (type $t2 (func (param i32 i32) (result i32))) <span class="comment">//add function</span></span><br><span class="line">  (func $__wasm_call_ctors (type $t0))</span><br><span class="line">  (func $main (<span class="keyword">export</span> <span class="string">&quot;main&quot;</span>) (type $t1) (result i32)</span><br><span class="line">    i32.const <span class="number">42</span>)</span><br><span class="line">  (func $add (<span class="keyword">export</span> <span class="string">&quot;add&quot;</span>) (type $t2) (param $p0 i32) (param $p1 i32) (result i32)</span><br><span class="line">    get_local $p1</span><br><span class="line">    get_local $p0</span><br><span class="line">    i32.add)</span><br><span class="line">  (table $T0 <span class="number">1</span> <span class="number">1</span> anyfunc) <span class="comment">//表格 存储anyfunction</span></span><br><span class="line">  (memory $memory (<span class="keyword">export</span> <span class="string">&quot;memory&quot;</span>) <span class="number">2</span>) <span class="comment">//memory也可以被js访问</span></span><br><span class="line">  (<span class="built_in">global</span> $g0 (mut i32) (i32.const <span class="number">66560</span>))</span><br><span class="line">  (<span class="built_in">global</span> $__heap_base (<span class="keyword">export</span> <span class="string">&quot;__heap_base&quot;</span>) i32 (i32.const <span class="number">66560</span>))</span><br><span class="line">  (<span class="built_in">global</span> $__data_end (<span class="keyword">export</span> <span class="string">&quot;__data_end&quot;</span>) i32 (i32.const <span class="number">1024</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如何传递字符串给JavaScript：我们所需要做的就是把字符串在线性内存中的偏移量，以及表示其长度的方法传递出去。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">consoleLogString</span>(<span class="params">offset, length</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> bytes = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(memory.buffer, offset, length);</span><br><span class="line">  <span class="keyword">var</span> string = <span class="keyword">new</span> TextDecoder(<span class="string">&#x27;utf8&#x27;</span>).decode(bytes);</span><br><span class="line">  <span class="built_in">console</span>.log(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何传递函数：WebAssembly可以增加一个anyfunc类型（”any”的含义是该类型能够持有任何签名的函数），但是，不幸的是，由于安全原因，这个anyfunc类型不能存储在线性内存中。线性内存会把存储的原始内容作为字节暴露出去，并且这会使得wasm内容能够任意的查看和修改原始函数地址，而这在网络上是不被允许的。</p>
<p>解决方案是在一个表格中存储函数引用，然后作为 代替，传递表格索引——它们只是i32类型值。因此，call_indirect的操作数可以是一个i32类型索引值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(type $return_i32 (func (result i32))) ;;call_indirect调用函数在调用前会检查签名</span><br><span class="line">(func (<span class="keyword">export</span> <span class="string">&quot;callByIndex&quot;</span>) (param $i i32) (result i32)</span><br><span class="line">  get_local $i ;;参数压栈</span><br><span class="line">  call_indirect $return_i32) ;;根据参数来call对应teble中的函数</span><br></pre></td></tr></table></figure>


<p>APIs:</p>
<ul>
<li><p>WebAssembly.instantiateStreaming: [IE、Safari、nodejs目前不可用]</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> importObject = &#123; <span class="attr">imports</span>: &#123; <span class="attr">imported_func</span>: <span class="function"><span class="params">arg</span> =&gt;</span> <span class="built_in">console</span>.log(arg) &#125; &#125;;</span><br><span class="line"></span><br><span class="line">WebAssembly.instantiateStreaming(fetch(<span class="string">&#x27;simple.wasm&#x27;</span>), importObject)</span><br><span class="line">.then(<span class="function"><span class="params">obj</span> =&gt;</span> obj.instance.exports.exported_func());</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><strong><code>WebAssembly.instantiate()</code></strong>:此方法不是获取(fetch)和实例化wasm模块的最具效率方法。 如果可能的话，您应该改用较新的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming"><code>WebAssembly.instantiateStreaming()</code></a>方法，该方法直接从原始字节码中直接获取，编译和实例化模块，因此不需要转换为<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>。<br>importObject :可选， 一个将被导入到新创建实例中的对象，它包含的值有函数、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory"><code>WebAssembly.Memory</code></a> 对象等等。编译的模块中，对于每一个导入的值都要有一个与其匹配的属性与之相对应，否则将会抛出 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/LinkError">WebAssembly.LinkError</a>。</li>
</ul>
<p>总结，编写c类代码,使用WASM_EXPORT–&gt; 编译成.wasm文件–&gt;在js中import该文件,instantiate得到instance–&gt;使用js操作instance.exports对外暴露的接口</p>
<hr>
<p>  本文同时发于简书 <a href="https://www.jianshu.com/p/a44503cb58ce">https://www.jianshu.com/p/a44503cb58ce</a></p>
<p>  参考：</p>
<ul>
<li><p>基本概念：<a href="https://developer.mozilla.org/zh-CN/docs/WebAssembly/Concepts">https://developer.mozilla.org/zh-CN/docs/WebAssembly/Concepts</a></p>
</li>
<li><p>规范<a href="https://www.w3.org/TR/wasm-core-1/">https://www.w3.org/TR/wasm-core-1/</a></p>
</li>
<li><p>文档<a href="https://developer.mozilla.org/zh-CN/docs/WebAssembly">https://developer.mozilla.org/zh-CN/docs/WebAssembly</a></p>
</li>
</ul>
<ul>
<li><p>使用案例<a href="https://juejin.cn/post/6901925766968115207">https://juejin.cn/post/6901925766968115207</a></p>
</li>
<li><p>studio（推荐自己尝试）：<a href="https://webassembly.studio/">https://webassembly.studio/</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>webAssembly</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>webRTC and SDP</title>
    <url>/2023/07/18/webRTC-and-SDP/</url>
    <content><![CDATA[<p>SDP(Session Description Protocol)用于描述multimedia的会话协商，可以让通话的双方交换一些必要的信息(codec, port等),SDP详见 <a href="https://datatracker.ietf.org/doc/html/rfc8866#name-sdp-specification">https://datatracker.ietf.org/doc/html/rfc8866#name-sdp-specification</a> </p>
 <a id="more"></a>

<p>WebRTC在建立连接时有以下步骤:</p>
<ul>
<li>发起方createOffer</li>
<li>发起方setLocalDescription</li>
<li>发起方发送offer</li>
<li>接收方setRemoteDescription</li>
<li>接收方createAnswer</li>
<li>接收方setLocalDescription</li>
<li>接收方发送Answer</li>
</ul>
<ol>
<li>example offer from <a href="https://www.rfc-editor.org/rfc/rfc4317.txt">https://www.rfc-editor.org/rfc/rfc4317.txt</a></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v=<span class="number">0</span> </span><br><span class="line">o=- <span class="number">487255629242026503</span> <span class="number">2</span> IN IP4 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> </span><br><span class="line">s=- </span><br><span class="line">t=<span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="comment">// use same port for audio video</span></span><br><span class="line">a=group:BUNDLE audio video </span><br><span class="line">a=msid-semantic: WMS <span class="number">6</span>x9ZxQZqpo19FRr3Q0xsWC2JJ1lVsk2JE0sG </span><br><span class="line"><span class="comment">// audio m line</span></span><br><span class="line"><span class="comment">// use port 9 for audio, use RTP, format is 111(see a=rtpmap:111 opus/48000/2 below)</span></span><br><span class="line">m=audio <span class="number">9</span> RTP/SAVPF <span class="number">111</span> <span class="number">103</span> <span class="number">104</span> <span class="number">9</span> <span class="number">0</span> <span class="number">8</span> <span class="number">106</span> <span class="number">105</span> <span class="number">13</span> <span class="number">126</span> </span><br><span class="line">c=IN IP4 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">a=rtcp:<span class="number">9</span> IN IP4 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> </span><br><span class="line">a=ice-ufrag:<span class="number">8</span>a1/LJqQMzBmYtes </span><br><span class="line">a=ice-pwd:sbfskHYHACygyHW1wVi8GZM+ </span><br><span class="line">a=ice-options:google-ice </span><br><span class="line">a=fingerprint:sha<span class="number">-256</span> <span class="number">28</span>:<span class="number">4</span>C:<span class="number">19</span>:<span class="number">10</span>:<span class="number">97</span>:<span class="number">56</span>:FB:<span class="number">22</span>:<span class="number">57</span>:<span class="number">9</span>E:<span class="number">5</span>A:<span class="number">88</span>:<span class="number">28</span>:F3:<span class="number">04</span>:</span><br><span class="line">   DF:<span class="number">37</span>:D0:<span class="number">7</span>D:<span class="number">55</span>:C3:D1:<span class="number">59</span>:B0:B2:<span class="number">81</span> :FB:<span class="number">9</span>D:DF:CB:<span class="number">15</span>:A8 </span><br><span class="line">a=setup:actpass </span><br><span class="line">a=mid:audio </span><br><span class="line"><span class="comment">// rtp extension, audio level can be used to check if attendee is speaking</span></span><br><span class="line">a=extmap:<span class="number">1</span> urn:ietf:params:rtp-hdrext:ssrc-audio-level </span><br><span class="line"><span class="comment">// abs-send-time for delay calculate</span></span><br><span class="line">a=extmap:<span class="number">3</span> http:<span class="comment">//www.webrtc.org/experiments/rtp-hdrext/abs-send-time </span></span><br><span class="line"><span class="comment">// sendonly/recvonly/sendrecv</span></span><br><span class="line">a=sendrecv </span><br><span class="line"><span class="comment">// same port for rtp and rtcp</span></span><br><span class="line">a=rtcp-mux </span><br><span class="line"><span class="comment">// playload type 111, opus, sampling rate, channel number </span></span><br><span class="line">a=rtpmap:<span class="number">111</span> opus/<span class="number">48000</span>/<span class="number">2</span> </span><br><span class="line"><span class="comment">// more details of opus codec(like useinbandfec)</span></span><br><span class="line">a=fmtp:<span class="number">111</span> minptime=<span class="number">10</span> </span><br><span class="line">a=rtpmap:<span class="number">103</span> ISAC/<span class="number">16000</span> </span><br><span class="line">a=rtpmap:<span class="number">104</span> ISAC/<span class="number">32000</span> </span><br><span class="line">a=rtpmap:<span class="number">9</span> G722/<span class="number">8000</span> </span><br><span class="line">a=rtpmap:<span class="number">0</span> PCMU/<span class="number">8000</span> </span><br><span class="line">a=rtpmap:<span class="number">8</span> PCMA/<span class="number">8000</span> </span><br><span class="line">a=rtpmap:<span class="number">106</span> CN/<span class="number">32000</span> </span><br><span class="line">a=rtpmap:<span class="number">105</span> CN/<span class="number">16000</span> </span><br><span class="line">a=rtpmap:<span class="number">13</span> CN/<span class="number">8000</span> </span><br><span class="line">a=rtpmap:<span class="number">126</span> telephone-event/<span class="number">8000</span> </span><br><span class="line">a=maxptime:<span class="number">60</span> </span><br><span class="line">a=ssrc:<span class="number">3607952327</span> cname:v1SBHP7c76XqYcWx </span><br><span class="line">a=ssrc:<span class="number">3607952327</span> msid:<span class="number">6</span>x9ZxQZqpo19FRr3Q0xsWC2JJ1lVsk2JE0sG <span class="number">9</span>eb1f6d5-c3b246fe</span><br><span class="line">   -b46b<span class="number">-63</span>ea11c46c74 </span><br><span class="line">a=ssrc:<span class="number">3607952327</span> mslabel:<span class="number">6</span>x9ZxQZqpo19FRr3Q0xsWC2JJ1lVsk2JE0sG </span><br><span class="line">a=ssrc:<span class="number">3607952327</span> label:<span class="number">9</span>eb1f6d5-c3b2<span class="number">-46f</span>e-b46b<span class="number">-63</span>ea11c46c74</span><br><span class="line"></span><br><span class="line"><span class="comment">// video m line</span></span><br><span class="line">m=video <span class="number">9</span> RTP/SAVPF <span class="number">100</span> <span class="number">116</span> <span class="number">117</span> <span class="number">96</span> </span><br><span class="line">c=IN IP4 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> </span><br><span class="line">a=rtcp:<span class="number">9</span> IN IP4 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> </span><br><span class="line">a=ice-ufrag:<span class="number">8</span>a1/LJqQMzBmYtes</span><br><span class="line">a=ice-pwd:sbfskHYHACygyHW1wVi8GZM+ </span><br><span class="line">a=ice-options:google-ice </span><br><span class="line">a=fingerprint:sha<span class="number">-256</span> <span class="number">28</span>:<span class="number">4</span>C:<span class="number">19</span>:<span class="number">10</span>:<span class="number">97</span>:<span class="number">56</span>:FB:<span class="number">22</span>:<span class="number">57</span>:<span class="number">9</span>E:<span class="number">5</span>A:<span class="number">88</span>:<span class="number">28</span>:F3:<span class="number">04</span>:</span><br><span class="line">   DF:<span class="number">37</span>:D0:<span class="number">7</span>D:<span class="number">55</span>:C3:D1:<span class="number">59</span>:B0:B2:<span class="number">81</span> :FB:<span class="number">9</span>D:DF:CB:<span class="number">15</span>:A8 </span><br><span class="line">a=setup:actpass </span><br><span class="line">a=mid:video </span><br><span class="line">a=extmap:<span class="number">2</span> urn:ietf:params:rtp-hdrext:toffset </span><br><span class="line">a=extmap:<span class="number">3</span> http:<span class="comment">//www.webrtc.org/experiments/rtp-hdrext/abs-send-time</span></span><br><span class="line">a=sendrecv </span><br><span class="line">a=rtcp-mux </span><br><span class="line">a=rtpmap:<span class="number">100</span> VP8/<span class="number">90000</span> </span><br><span class="line">a=rtcp-fb:<span class="number">100</span> ccm fir </span><br><span class="line">a=rtcp-fb:<span class="number">100</span> nack </span><br><span class="line">a=rtcp-fb:<span class="number">100</span> nack pli </span><br><span class="line">a=rtcp-fb:<span class="number">100</span> goog-remb </span><br><span class="line">a=rtpmap:<span class="number">116</span> red/<span class="number">90000</span> </span><br><span class="line">a=rtpmap:<span class="number">117</span> ulpfec/<span class="number">90000</span> </span><br><span class="line">a=rtpmap:<span class="number">96</span> rtx/<span class="number">90000</span> </span><br><span class="line">a=fmtp:<span class="number">96</span> apt=<span class="number">100</span> </span><br><span class="line">a=ssrc-group:FID <span class="number">1175220440</span> <span class="number">3592114481</span> </span><br><span class="line">a=ssrc:<span class="number">1175220440</span> cname:v1SBHP7c76XqYcWx </span><br><span class="line">a=ssrc:<span class="number">1175220440</span> msid:<span class="number">6</span>x9ZxQZqpo19FRr3Q0xsWC2JJ1lVsk2JE0sG</span><br><span class="line">   <span class="number">43</span>d2eec3<span class="number">-7116</span><span class="number">-4b</span>29-ad33<span class="number">-466</span>c9358bfb3 </span><br><span class="line">a=ssrc:<span class="number">1175220440</span> mslabel:<span class="number">6</span>x9ZxQZqpo19FRr3Q0xsWC2JJ1lVsk2JE0sG </span><br><span class="line">a=ssrc:<span class="number">1175220440</span> label:<span class="number">43</span>d2eec3<span class="number">-7116</span><span class="number">-4b</span>29-ad33<span class="number">-466</span>c9358bfb3 </span><br><span class="line">a=ssrc:<span class="number">3592114481</span> cname:v1SBHP7c76XqYcWx </span><br><span class="line">a=ssrc:<span class="number">3592114481</span> msid:<span class="number">6</span>x9ZxQZqpo19FRr3Q0xsWC2JJ1lVsk2JE0sG</span><br><span class="line">   <span class="number">43</span>d2eec3<span class="number">-7116</span><span class="number">-4b</span>29-ad33<span class="number">-466</span>c9358bfb3 </span><br><span class="line">a=ssrc:<span class="number">3592114481</span> mslabel:<span class="number">6</span>x9ZxQZqpo19FRr3Q0xsWC2JJ1lVsk2JE0sG </span><br><span class="line">a=ssrc:<span class="number">3592114481</span> label:<span class="number">43</span>d2eec3<span class="number">-7116</span><span class="number">-4b</span>29-ad33<span class="number">-466</span>c9358bfb3</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>example answer</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v=<span class="number">0</span> </span><br><span class="line">o=- <span class="number">5504016820010393753</span> <span class="number">2</span> IN IP4 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> </span><br><span class="line">s=- </span><br><span class="line">t=<span class="number">0</span> <span class="number">0</span> </span><br><span class="line">a=group:BUNDLE audio video </span><br><span class="line">a=msid-semantic: WMS </span><br><span class="line">m=audio <span class="number">9</span> RTP/SAVPF <span class="number">111</span> <span class="number">103</span> <span class="number">104</span> <span class="number">9</span> <span class="number">0</span> <span class="number">8</span> <span class="number">106</span> <span class="number">105</span> <span class="number">13</span> <span class="number">126</span> </span><br><span class="line">c=IN IP4 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> </span><br><span class="line">a=rtcp:<span class="number">9</span> IN IP4 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> </span><br><span class="line">a=ice-ufrag:RjDpYl08FRKBqZ4A </span><br><span class="line">a=ice-pwd:wSgwewyvypHhyxrcZELBLOBO </span><br><span class="line">a=fingerprint:sha<span class="number">-256</span> <span class="number">28</span>:<span class="number">4</span>C:<span class="number">19</span>:<span class="number">10</span>:<span class="number">97</span>:<span class="number">56</span>:FB:<span class="number">22</span>:<span class="number">57</span>:<span class="number">9</span>E:<span class="number">5</span>A:<span class="number">88</span>:<span class="number">28</span>:</span><br><span class="line">   F3:<span class="number">04</span>:DF:<span class="number">37</span>:D0:<span class="number">7</span>D:<span class="number">55</span>:C3:D1:<span class="number">59</span>:B0:B2:<span class="number">81</span> :FB:<span class="number">9</span>D:DF:CB:<span class="number">15</span>:A8 </span><br><span class="line">a=setup:active </span><br><span class="line">a=mid:audio </span><br><span class="line">a=extmap:<span class="number">1</span> urn:ietf:params:rtp-hdrext:ssrc-audio-level </span><br><span class="line">a=extmap:<span class="number">3</span> http:<span class="comment">//www.webrtc.org/experiments/rtp-hdrext/abs-send-time </span></span><br><span class="line">a=recvonly </span><br><span class="line">a=rtcp-mux </span><br><span class="line">a=rtpmap:<span class="number">111</span> opus/<span class="number">48000</span>/<span class="number">2</span> </span><br><span class="line">a=fmtp:<span class="number">111</span> minptime=<span class="number">10</span> </span><br><span class="line">a=rtpmap:<span class="number">103</span> ISAC/<span class="number">16000</span> </span><br><span class="line">a=rtpmap:<span class="number">104</span> ISAC/<span class="number">32000</span> </span><br><span class="line">a=rtpmap:<span class="number">9</span> G722/<span class="number">8000</span> </span><br><span class="line">a=rtpmap:<span class="number">0</span> PCMU/<span class="number">8000</span> </span><br><span class="line">a=rtpmap:<span class="number">8</span> PCMA/<span class="number">8000</span> </span><br><span class="line">a=rtpmap:<span class="number">106</span> CN/<span class="number">32000</span> </span><br><span class="line">a=rtpmap:<span class="number">105</span> CN/<span class="number">16000</span> </span><br><span class="line">a=rtpmap:<span class="number">13</span> CN/<span class="number">8000</span> </span><br><span class="line">a=rtpmap:<span class="number">126</span> telephone-event/<span class="number">8000</span> </span><br><span class="line">a=maxptime:<span class="number">60</span> </span><br><span class="line"></span><br><span class="line">m=video <span class="number">9</span> RTP/SAVPF <span class="number">100</span> <span class="number">116</span> <span class="number">117</span> <span class="number">96</span></span><br><span class="line">c=IN IP4 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> </span><br><span class="line">a=rtcp:<span class="number">9</span> IN IP4 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> </span><br><span class="line">a=ice-ufrag:RjDpYl08FRKBqZ4A </span><br><span class="line">a=ice-pwd:wSgwewyvypHhyxrcZELBLOBO </span><br><span class="line">a=fingerprint:sha<span class="number">-256</span> <span class="number">28</span>:<span class="number">4</span>C:<span class="number">19</span>:<span class="number">10</span>:<span class="number">97</span>:<span class="number">56</span>:FB:<span class="number">22</span>:<span class="number">57</span>:<span class="number">9</span>E:<span class="number">5</span>A:<span class="number">88</span>:<span class="number">28</span>:</span><br><span class="line">   F3:<span class="number">04</span>:DF:<span class="number">37</span>:D0:<span class="number">7</span>D:<span class="number">55</span>:C3:D1:<span class="number">59</span>:B0:B2:<span class="number">81</span> :FB:<span class="number">9</span>D:DF:CB:<span class="number">15</span>:A8 </span><br><span class="line">a=setup:active </span><br><span class="line">a=mid:video </span><br><span class="line">a=extmap:<span class="number">2</span> urn:ietf:params:rtp-hdrext:toffset </span><br><span class="line">a=extmap:<span class="number">3</span> http:<span class="comment">//www.webrtc.org/experiments/rtp-hdrext/abs-send-time</span></span><br><span class="line">a=recvonly </span><br><span class="line">a=rtcp-mux </span><br><span class="line">a=rtpmap:<span class="number">100</span> VP8/<span class="number">90000</span> </span><br><span class="line">a=rtcp-fb:<span class="number">100</span> ccm fir </span><br><span class="line">a=rtcp-fb:<span class="number">100</span> nack </span><br><span class="line">a=rtcp-fb:<span class="number">100</span> nack pli </span><br><span class="line">a=rtcp-fb:<span class="number">100</span> goog-remb </span><br><span class="line">a=rtpmap:<span class="number">116</span> red/<span class="number">90000</span> </span><br><span class="line">a=rtpmap:<span class="number">117</span> ulpfec/<span class="number">90000</span> </span><br><span class="line">a=rtpmap:<span class="number">96</span> rtx/<span class="number">90000</span> </span><br><span class="line">a=fmtp:<span class="number">96</span> apt=<span class="number">100</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>webRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>一次使用python发送大量请求的优化</title>
    <url>/2021/01/24/%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8python%E5%8F%91%E9%80%81%E5%A4%A7%E9%87%8F%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>最近需要实现一个简单的功能，将多个记录同步到n个不同的服务器环境中去（每个记录分别需要call每个Server的API），后端使用的是python的Flask框架，在使用了多线程后发现速度还是很慢，20条记录同步到10个环境大约需要20s以上，显然是慢的离谱，由于对Python并不算特别熟悉，查找了一些资料开始优化</p>
 <a id="more"></a>

<p>系统的流程大约是这样：首先针对不同的环境获取token信息，缓存这些token，然后make_request方法针对每个环境每个表项获取不同的配置拼接header发送每个请求，例如20条记录到10个环境也就是200个请求</p>
<p>为了测试是什么地方出了问题，我在各个位置打了log信息，发现结果如下：</p>
<ul>
<li>200个线程几乎同时启动</li>
<li>每个线程执行make_request的时间不同，最快的0.1s就返回response，最慢的则需要10秒以上才能返回response</li>
</ul>
<p>因为使用的post请求，在应用层使用的是http协议，http由于通常不会进行推流这些操作，传输层大概率使用的是TCP协议。我们可以回想下</p>
<h3 id="TCP服务在客户端和服务端上的流程："><a href="#TCP服务在客户端和服务端上的流程：" class="headerlink" title="TCP服务在客户端和服务端上的流程："></a>TCP服务在客户端和服务端上的流程：</h3><ol>
<li>socket函数创建主动的套接字（如果是服务器需要使用listen变成被动的套接字）</li>
<li>connect函数建立连接，建立连接的过程就是常见的TCP三次握手</li>
<li>write系统调用将post请求的数据由进程缓冲区写入内核的TCP套接字发送缓冲区，相对的服务端会使用read系统调用来讲读取服务端TCP套接字接受缓冲区的内容</li>
<li>服务端执行write系统调用将返回的数据由进程缓冲区写入内核的TCP套接字发送缓冲区，相对的我们的客户端会使用read系统调用来讲读取服务端TCP套接字接受缓冲区的内容</li>
<li>close关闭连接</li>
</ol>
<p>如下图所示：</p>
<p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/hexo/tcp%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B.png" alt="tcp连接"></p>
<h3 id="是不是accept的阻塞？"><a href="#是不是accept的阻塞？" class="headerlink" title="是不是accept的阻塞？"></a>是不是accept的阻塞？</h3><p>由于是对10个环境做200个request，每个服务器只会接受20个握手的请求，不考虑服务器端的优化（事实上这里请求的服务器使用了线程池之类的优化），通常来说listen()建立的未完成连接数目和已完成连接的队列长度是128，所以如果不考虑IO，200个request的返回应该在一到几秒内完成</p>
<h3 id="是不是IO问题？"><a href="#是不是IO问题？" class="headerlink" title="是不是IO问题？"></a>是不是IO问题？</h3><p>Python的多线程是伪多线程，对Python虚拟机的访问是由全局解释器锁GIL控制的，GIL负责线程的切换且保证同时只能有一个线程运行。</p>
<p>不考虑服务端的话，客户端需要进行200次read和write的系统调用，这是一个IO密集型的程序（threading里有利的条件，意味着释放GIL，可以更多的并发），虽然不存在竞态条件，但是每个线程都是阻塞型IO。如果我们改用非阻塞的异步IO，由内核来处理tcp缓冲区的赋值然后通知线程的结果会更好</p>
<h3 id="多线程能不能改进？"><a href="#多线程能不能改进？" class="headerlink" title="多线程能不能改进？"></a>多线程能不能改进？</h3><p>这里200个线程（这里线程数过大通常为cpu核数*2）分到的时间片太小可能需要频繁的调度线程，如果使用线程池类的方式会使得开销更小</p>
<h3 id="由此得出我们改进的方向："><a href="#由此得出我们改进的方向：" class="headerlink" title="由此得出我们改进的方向："></a>由此得出我们改进的方向：</h3><ul>
<li>改进IO方式：目的是减少线程阻塞</li>
<li>改进线程创建和工作的方式：减少线程开销</li>
<li>绕过GIL充分利用多核的优势</li>
</ul>
<p>查找了相关的 py lib环节，看了下aiohttp的功能看起来可以满足要求：</p>
<ul>
<li>协程：由于线程切换需要上下文的开销，尤其在线程很多而时间片很短的情况下。协程可以将这200个线程的任务放在一个线程中执行（这一点应该也是因为Python无法原生支持多核，实际上这一步如何和多线程处理结合起来可以做的更好），但这显然还是无法并发执行，所以需要异步IO</li>
<li>异步IO：aiohttp并不单纯是cpu轮询式的异步IO，而是实现了一个消息循环，每次make_request的时候都会创建一个协程的任务去执行当前的IO（write到TCP缓冲区,read服务端返回信息….），主线程并不会等待（这里的意思是主线程不会轮询IO状态，IO状态最终由事件触发），但是当IO完成的时候，线程会拿到当前request的response，这个过程是并行的。</li>
</ul>
<p>工作流程大致如下：</p>
<ol>
<li>使用async关键字创建协程</li>
<li>将request加入消息循环，主线程在这里并不会等待结果，也不需要cpu轮询结果</li>
<li>使用gather收集结果</li>
</ol>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">doRequest</span>(<span class="params">url, method, config, env, session: ClientSession, **kwargs</span>) -&gt; tuple:</span></span><br><span class="line">    start = datetime.datetime.now()</span><br><span class="line">    logger.info(<span class="built_in">str</span>(config) + <span class="string">&quot; - &quot;</span> + <span class="built_in">str</span>(env) + <span class="built_in">str</span>(start))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = <span class="keyword">await</span> session.request(method=method, url=url, data=json.dumps(config),</span><br><span class="line">                                         headers=getHeader4env(env), **kwargs)</span><br><span class="line">    <span class="keyword">except</span> ClientConnectorError:</span><br><span class="line">        <span class="keyword">return</span> config, env, <span class="number">404</span></span><br><span class="line">    logger.info(<span class="built_in">str</span>(config) + <span class="string">&quot; - &quot;</span> + <span class="built_in">str</span>(env) + <span class="built_in">str</span>(datetime.datetime.now() - start))</span><br><span class="line">    <span class="keyword">return</span> config, env, response.status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">make_requests</span>(<span class="params">data_list: <span class="built_in">list</span>, **kwargs</span>) -&gt; <span class="keyword">None</span>:</span> </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> ClientSession() <span class="keyword">as</span> session: <span class="comment"># 使用async关键字创建协程</span></span><br><span class="line">        tasks = []</span><br><span class="line">        <span class="keyword">for</span> each_data <span class="keyword">in</span> data_list:</span><br><span class="line">            tasks.append(	<span class="comment"># 将task加入循环loop</span></span><br><span class="line">                doRequest(url=each_data[<span class="string">&#x27;url&#x27;</span>], method=each_data[<span class="string">&#x27;method&#x27;</span>], config=each_data[<span class="string">&#x27;config&#x27;</span>],</span><br><span class="line">                            env=each_data[<span class="string">&#x27;env&#x27;</span>], session=session, **kwargs)</span><br><span class="line">            )</span><br><span class="line">        results = <span class="keyword">await</span> asyncio.gather(*tasks) <span class="comment"># gather收集结果，这里是fail的表项</span></span><br><span class="line">    fail_list = []</span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">        <span class="keyword">if</span> result[<span class="number">2</span>] &gt;= <span class="number">300</span> <span class="keyword">or</span> result[<span class="number">2</span>] &lt; <span class="number">200</span>:</span><br><span class="line">            fail_list.append(<span class="built_in">str</span>(result[<span class="number">0</span>]) + <span class="string">&quot; - &quot;</span> + <span class="built_in">str</span>(result[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> fail_list</span><br></pre></td></tr></table></figure>
<p>测试下来100条表项同步到10个环境大约需要6-7s，相比以前20条记录同步到10个环境大约需要20s以上，性能提高了很多</p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>异步</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>位图与c++实现</title>
    <url>/2021/01/12/%E4%BD%8D%E5%9B%BE%E4%B8%8Ec-%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>位图：一种数据结构，代表了有限域中的稠集（dense set），每一个元素至少出现一次，没有其他的数据和元素相关联。在索引，数据压缩等方面有广泛应用。</p>
 <a id="more"></a>

<h3 id="位向量"><a href="#位向量" class="headerlink" title="位向量"></a>位向量</h3><p>位向量这种数据结构可以用来表示多个数字，如果每一位代表一个数字，这一位为0表示该数字不存在，这一位为1则表示该数字存在，这N位的位向量可以存储N个数字，所以存储 0到2^n共2^n + 1个数字可以用2^n + 1位的位向量表示（0是不能被全0的位向量表示的，全0的位向量表示不存储任何数）</p>
<h3 id="vector向量实现位向量"><a href="#vector向量实现位向量" class="headerlink" title="vector向量实现位向量"></a>vector向量实现位向量</h3><p>因为向量在物理存储中也是连续的，所以我们可以用向量这种数据结构来模拟长度很长的位向量，例如c++中vector<int>，因为每个int是4个字节，每个字节是8bit，所以如果要表示64这个数,需要将vec[64/32]这个整形数加上2^(64%32)，推广为存储任意非负整数 num：vec[num/32] += 2^(num%32);</p>
<h3 id="vector-lt-int-gt-实现bitmap代码如下："><a href="#vector-lt-int-gt-实现bitmap代码如下：" class="headerlink" title="vector&lt;int&gt;实现bitmap代码如下："></a>vector&lt;int&gt;实现bitmap代码如下：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bit_map:使用vector&lt;int&gt;线性结构存储，同样可以使用数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITSPERWORD 32 <span class="comment">//每个int是4个字节 32位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT 5 <span class="comment">// 2^5=32, num&gt;&gt;SHIFT等价于 num/32</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MASK 0x1F <span class="comment">//全1的32位掩码, num &amp; MASK等价于取最低的32位，等价于 num % 32</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> num, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;bit_map)</span></span>&#123;</span><br><span class="line">    <span class="comment">//等价于 bit_map[num/32] |= (1 &lt;&lt; (num%32));</span></span><br><span class="line">    bit_map[num &gt;&gt; SHIFT] |= (<span class="number">1</span> &lt;&lt; (num &amp; MASK) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> num, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;bit_map)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> bit_map[num &gt;&gt; SHIFT] &amp; (<span class="number">1</span> &lt;&lt; (num &amp; MASK));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将int以二进制print</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showAsBinary</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span> ; i&gt;=<span class="number">0</span> ; --i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="number">1</span> &amp; (num&gt;&gt;i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">int</span> num, maxn;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">-1</span>)&#123;</span><br><span class="line">        nums.push_back(num);</span><br><span class="line">        maxn = max(maxn, num);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bit_map</span><span class="params">( <span class="number">1</span> + maxn/BITSPERWORD, <span class="number">0</span>)</span></span>;<span class="comment">//init bit map</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n : nums)&#123;</span><br><span class="line">        <span class="built_in">set</span>(n, bit_map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;init bit map... stoıre by int of vector, size = &quot;</span> &lt;&lt; bit_map.size() &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">8</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=bit_map.size()<span class="number">-1</span> ; i&gt;=<span class="number">0</span> ; --i)&#123;</span><br><span class="line">        showAsBinary(bit_map[i]);</span><br><span class="line">    &#125;<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;enter number you want to search ...&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; num)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (checkIndex(num, bit_map) ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="number">127</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"></span><br><span class="line">init bit <span class="built_in">map</span>... stoıre by <span class="keyword">int</span> of <span class="built_in">vector</span>, size = <span class="number">4</span> * <span class="number">32</span></span><br><span class="line"><span class="number">10000000000000000000000000000000</span> <span class="number">00000000000000000000000000000001</span> <span class="number">00000000000000000000000000000000</span> <span class="number">00000000000000000000000000001001</span> </span><br><span class="line">enter number you want to search ...</span><br><span class="line"><span class="number">0</span></span><br><span class="line">YES</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line">NO</span><br><span class="line"></span><br><span class="line"><span class="number">64</span></span><br><span class="line">YES</span><br><span class="line"></span><br><span class="line"><span class="number">127</span></span><br><span class="line">YES</span><br><span class="line"></span><br><span class="line"><span class="number">128</span></span><br><span class="line">NO</span><br></pre></td></tr></table></figure>
<p>从上面可以看出位图存储的效率很高，理想状态下空间利用率相比普通的int存储高了大约32倍，缺点是vector的长度会受到存储的最大的数的限制，对于排列紧密，最大长度并非特别的长的集合存储非常有效</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>bit map</tag>
        <tag>位图</tag>
      </tags>
  </entry>
  <entry>
    <title>并发条件下写测试</title>
    <url>/2021/02/23/%E5%B9%B6%E5%8F%91%E6%9D%A1%E4%BB%B6%E4%B8%8B%E5%86%99%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>测试多进程和多线程条件下c++、Java、Python的写操作，以及c++的多进程文件写入，其中c++使用fork多进程，Java实现Runnable接口，Python使用threading库</p>
 <a id="more"></a>

<h3 id="并发写入map"><a href="#并发写入map" class="headerlink" title="并发写入map"></a>并发写入map</h3><h4 id="c-fork"><a href="#c-fork" class="headerlink" title="c++ fork"></a>c++ fork</h4><p>原map的value全部为0，子进程将value全部赋值为-1，而父进程全部赋值为1，代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m[<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    m[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    m[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>( (pid = fork()) == <span class="number">0</span> )&#123; <span class="comment">//这里忽略fork失败的情况</span></span><br><span class="line">        m[<span class="number">-1</span>] = <span class="number">-1</span>;</span><br><span class="line">        m[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        m[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;subprocess map  ... &quot;</span>&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=m.begin() ; it!=m.end() ; ++it)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span>  &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; subprocess print end ... &quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main print ... &quot;</span>&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=m.begin() ; it!=m.end() ; ++it)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span>  &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; main print end ... &quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main print ...  -1 0, 0 0, 1 0,  main print end ... </span><br><span class="line"></span><br><span class="line">subprocess map  ...  -1 -1, 0 -1, 1 -1,  subprocess print end ... </span><br></pre></td></tr></table></figure>
<p>可以看出进程做到了很好的隔离，两个进程之间互不影响</p>
<h4 id="Java-Thread"><a href="#Java-Thread" class="headerlink" title="Java Thread"></a>Java Thread</h4><p>测试使用两个进程都能写的变量，在Java中，线程共享的有全局变量、静态变量、地址空间、代码段、打开文件的IO、父进程id、堆，也就是说全局变量、静态变量和new在堆上的变量都满足这个要求，下面用静态变量测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> thread_test;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadModify</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num ;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;, expect 1 : &quot;</span> + num);</span><br><span class="line">        num = <span class="number">3</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;, expect 6 : &quot;</span> + num * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadModify t = <span class="keyword">new</span> ThreadModify();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(t,<span class="string">&quot;thread&quot;</span>+i+<span class="string">&quot;:&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread59:, expect 1 : 1</span><br><span class="line">thread59:, expect 6 : 6</span><br><span class="line">thread57:, expect 1 : 3</span><br><span class="line">thread57:, expect 6 : 6</span><br><span class="line">thread47:, expect 6 : 6</span><br><span class="line">thread55:, expect 1 : 3</span><br></pre></td></tr></table></figure>
<p>来看下线程安全的定义：Thread-safe code only manipulates shared data structures in a manner that ensures that all threads behave properly and fulfill their design specifications without unintended interaction. </p>
<p>这样看来Java中的静态变量在多线程下是不安全的</p>
<h4 id="python-threading"><a href="#python-threading" class="headerlink" title="python threading"></a>python threading</h4><p>与Java的测试一致，测试使用两个进程都能写的全局变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    print(<span class="string">&quot;thread&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;, expect 1 :&quot;</span> + <span class="built_in">str</span>(num))</span><br><span class="line">    num = <span class="number">3</span></span><br><span class="line">    print(<span class="string">&quot;thread&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;, expect 6 :&quot;</span> + <span class="built_in">str</span>(num*<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lst = []</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        t = Thread(target=f, args=(t,), name=<span class="string">&quot;thread&quot;</span>+<span class="built_in">str</span>(t))</span><br><span class="line">        t.start()</span><br><span class="line">        lst.append(t)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> lst:</span><br><span class="line">        t.join()</span><br></pre></td></tr></table></figure>
<p>奇怪的是，测试线程增加了一倍变成10000，但是没有出现线程不安全的情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">thread9996, expect 1 :1</span><br><span class="line">thread9996, expect 6 :6</span><br><span class="line">thread9997, expect 1 :1</span><br><span class="line">thread9997, expect 6 :6</span><br><span class="line">thread9998, expect 1 :1</span><br><span class="line">thread9999, expect 1 :1</span><br><span class="line">thread9999, expect 6 :6</span><br><span class="line">thread9998, expect 6 :6</span><br></pre></td></tr></table></figure>
<p>考虑GIL的存在，如果加入一些CPU密集型任务，让线程同时启动：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">cnt</span>):</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cnt):</span><br><span class="line">        num += j</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lst = []</span><br><span class="line">    n = <span class="number">100000</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        t = Thread(target=f, args=(n,), name=<span class="string">&quot;thread&quot;</span>+<span class="built_in">str</span>(t))</span><br><span class="line">        lst.append(t)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> lst:</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> lst:</span><br><span class="line">        t.join()</span><br><span class="line">    res = n/<span class="number">2</span> * (n-<span class="number">1</span>) * <span class="number">100</span></span><br><span class="line">    print(<span class="string">&quot;except &quot;</span> + <span class="built_in">str</span>(res) + <span class="string">&quot; : get &quot;</span> + <span class="built_in">str</span>(num))</span><br></pre></td></tr></table></figure>
<p>结果果然出错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">except 499995000000.0 : get 386490408126</span><br></pre></td></tr></table></figure>
<p>Python的写全局变量也是线程不安全的</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>Python的多线程与c++的多进程有很大区别，c++ fork之后子进程继承了父进程的变量内容，但是子进程和父进程修改互不影响，也就是说在修改前有个深拷贝map的动作，并不像Java线程中常见的可以共享全局变量。Python是伪多线程，由于GIL（Global Interpreter Lock，全局解释器锁）的存在，同一进程内任何时刻仅有一个线程在执行，可以尝试加入一些CPU密集型任务让线程无法在一个时间片内完成从而需要调度，方便观察结果，简单来说：</p>
<ol>
<li>多进程与多线程有很大的区别，多进程操作的是不同的变量或者副本。而多线程在写全局变量的时候操作的是同一个变量</li>
<li>Java的多线程操作静态变量是线程不安全的</li>
<li>Python的多线程操作全局变量是线程不安全的</li>
</ol>
<h3 id="c-多进程写入文件"><a href="#c-多进程写入文件" class="headerlink" title="c++ 多进程写入文件"></a>c++ 多进程写入文件</h3><p>c++的文件IO写入方式默认是输出和截断，也可以设置成追加，下面测试这两种情况</p>
<h4 id="c-ofstream-默认方式"><a href="#c-ofstream-默认方式" class="headerlink" title="c++ ofstream 默认方式"></a>c++ ofstream 默认方式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   ofstream outfile;</span><br><span class="line">   outfile.open(<span class="string">&quot;./testfile.txt&quot;</span>); <span class="comment">//默认是输出和截断模式</span></span><br><span class="line">   <span class="keyword">pid_t</span> pid;</span><br><span class="line">   <span class="keyword">if</span>( (pid = fork()) == <span class="number">0</span>)&#123;</span><br><span class="line">       <span class="built_in">string</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">           str += <span class="string">&quot;this is subprocess....&quot;</span>;  <span class="comment">// vscode计为22个字符 </span></span><br><span class="line">       &#125;</span><br><span class="line">       outfile &lt;&lt; str;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="built_in">string</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">           str += <span class="string">&quot;this is main process....&quot;</span>;  <span class="comment">// vscode计为24个字符 </span></span><br><span class="line">       &#125;</span><br><span class="line">       outfile &lt;&lt; str;</span><br><span class="line">       sleep(<span class="number">2</span>);</span><br><span class="line">       outfile.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>testfile.txt的内容是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is test file old content. &#x2F;&#x2F; vscode计为30个字符</span><br></pre></td></tr></table></figure>
<p>执行结果太长，截取一部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is main process....this is main process....</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">this is main process....this is main process....this is this is subprocess....</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">this is subprocess....this is subprocess....main process....this is main process....this is main process....this is main process....</span><br></pre></td></tr></table></figure>
<p>可以看出testfile.txt的原内容被丢弃，两个进程写同一个文件描述符，且是交叉的写入，main进程出现了输入被截断的情况，文件大小为46000个字符，46000 = (22 + 24)*1000，代表没有丢失写入</p>
<h4 id="c-ofstream-追加模式"><a href="#c-ofstream-追加模式" class="headerlink" title="c++ ofstream 追加模式"></a>c++ ofstream 追加模式</h4><p>代码改成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">outfile.open(<span class="string">&quot;./testfile.txt&quot;</span>, ofstream::app); <span class="comment">//追加模式</span></span><br></pre></td></tr></table></figure>
<p>结果原内容没有被丢弃，两个进程都是在原内容后追加，且是交叉的写入，main进程同样出现了输入被截断的情况，文件大小为46030个字符，同样没有丢失输入</p>
<p>可以看出c++ fork使得两个进程共享文件描述符，且<strong>隐式同步共享文件偏移量</strong></p>
<p>参考：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Thread_safety">线程安全维基百科</a></li>
<li>Unix环境高级编程</li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>Java</tag>
        <tag>c++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发相关图片存档</title>
    <url>/2021/01/12/%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3%E5%9B%BE%E7%89%87%E5%AD%98%E6%A1%A3/</url>
    <content><![CDATA[<p>学习Java并发相关的过程中的一些图片存档</p>
 <a id="more"></a>

<h3 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h3><p>准确的说是JMM内存模型所表达的语义</p>
<p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B_1587947785674.jpg" alt="JMM内存模型"></p>
<h3 id="volatile的作用"><a href="#volatile的作用" class="headerlink" title="volatile的作用"></a>volatile的作用</h3><p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4/volitale%20(2)_1587947785662.jpg" alt="volitale"></p>
<h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>currentHashMap的分段锁</p>
<p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4/%E5%88%86%E6%AE%B5%E9%94%81_1587947785679.jpg" alt="分段锁"></p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4/%E7%BA%BF%E7%A8%8B%E6%B1%A0_1587947790551.jpg" alt="线程池"></p>
<h3 id="锁的膨胀"><a href="#锁的膨胀" class="headerlink" title="锁的膨胀"></a>锁的膨胀</h3><p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4/%E9%94%81%E7%9A%84%E8%86%A8%E8%83%80_1587947790555.jpg" alt="锁的膨胀"></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>形式化方法-混合执行</title>
    <url>/2021/01/12/%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95-%E6%B7%B7%E5%90%88%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<p>在一个程序中，可能存在庞大的if分支，又或者存在对于某些计算机无法求解的条件，例如 x * x * x = z，如果想对这个程序进行条件性安全检测，应该如何去做呢？</p>
 <a id="more"></a>

<h3 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h3><p>对于 if(x &gt;0)这样的分支，使用值去穷举显然是无法得到解的，因为x可能取的值有无穷多个，事实上我们通过路径的穷举来实现，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(x&gt;0)&#123;</span><br><span class="line">	if(y&gt;1)&#123;</span><br><span class="line">		z &#x3D; x&#x2F;y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码实际上的分支路径有 x&lt;=0, x&gt;0 &amp;&amp; y&gt;1, x&gt;0 &amp;&amp;y&lt;=1三条，而除零错误只有x&gt;0 &amp;&amp; y&gt;1 路劲下才会遍历到，所以不会触发</p>
<p>但是符号执行存在一些问题，第一个问题是可能存在路劲爆炸，每一条分支使得路劲的个数呈指数级上升，当分支数过多的时候就会导致路劲爆炸，无法穷举这些路径。第二个问题是符合执行的危险条件的表达式的方程对于计算机来说有时候是无解的，例如 z = x<em>x</em>x（计算机是无法求解这个表达式的）</p>
<h3 id="混合执行"><a href="#混合执行" class="headerlink" title="混合执行"></a>混合执行</h3><p>对于拥有过于复杂的分支的程序，如果使用穷举结合符合执行有时候是一个解决问题的方法</p>
<p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/hexo/%E6%B7%B7%E5%90%88%E6%89%A7%E8%A1%8C.png" alt="混合执行"></p>
<p>混合执行维持两套内存模型，实际在结合路径分支进行穷举，如果当前分支执行完成后对当前分支进行取反作为下一次的具体输入的范围来源，避免了路径的指数级累加，并且对于无法求解的方程也可以使用具体值进行尝试</p>
<p>e.g:对于下面这样一个函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loop(m,n)&#123;</span><br><span class="line">	while(m &lt; n)&#123;</span><br><span class="line">		if(m &gt; 0)&#123;</span><br><span class="line">		   m &#x3D; m * 2;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">		  if(m &#x3D;&#x3D; 0)&#123;</span><br><span class="line">			   m &#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">			   m &#x3D; m * -1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一个循环，将其映射成抽象的AST形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># test code</span><br><span class="line">func_loop &#x3D; Function(&quot;loop&quot;, [&quot;m&quot;, &quot;n&quot;],</span><br><span class="line">                     [StmWhile(ExpBop(ExpVar(&quot;m&quot;), ExpVar(&quot;n&quot;), BOp.LT),</span><br><span class="line">                               [StmIf(ExpBop(ExpVar(&quot;m&quot;), ExpNum(0), BOp.GT),</span><br><span class="line">                                      [StmAssign(&quot;m&quot;, ExpBop(ExpVar(&quot;m&quot;), ExpNum(2), BOp.MUL))],</span><br><span class="line">                                      [StmIf(ExpBop(ExpVar(&quot;m&quot;), ExpNum(0), BOp.EQ),</span><br><span class="line">                                             [StmAssign(&quot;m&quot;, ExpNum(1))],</span><br><span class="line">                                             [StmAssign(&quot;m&quot;, ExpBop(ExpVar(&quot;m&quot;), ExpNum(-1), BOp.MUL))])])</span><br><span class="line">                                ])</span><br><span class="line">                     ], ExpVar(&quot;m&quot;))</span><br><span class="line">  </span><br><span class="line"># 混合执行函数</span><br><span class="line">  def concolic_executor(func, init_params, try_times):</span><br><span class="line">    print(&quot;最大尝试次数threshold  &#x3D; &quot;, try_times)</span><br><span class="line">    init_concrete &#x3D; dict(zip(func.args, init_params))</span><br><span class="line">    print(f&quot;First Try, Input Value: &#123;init_concrete&#125;&quot;)</span><br><span class="line">    memory, _ &#x3D; concolic_func(func, init_concrete.copy())</span><br><span class="line">    print(memory)</span><br><span class="line"></span><br><span class="line">    # random select and negate one condition from previous result</span><br><span class="line">    # and use z3 to generate a input to do next concolic execution</span><br><span class="line">    for try_time in range(2, try_times+1, 1):</span><br><span class="line">        random_idx &#x3D; random.randrange(0, len(memory.path_condition))</span><br><span class="line">        memory.path_condition[random_idx] &#x3D; neg_exp(memory.path_condition[random_idx])</span><br><span class="line">        ret, solver &#x3D; check_cond(memory)</span><br><span class="line"></span><br><span class="line">        if ret &#x3D;&#x3D; sat:</span><br><span class="line">            # use z3 result update new input values</span><br><span class="line">            model &#x3D; solver.model()</span><br><span class="line">            for dec in model.decls():</span><br><span class="line">                if dec.name() in func.args:</span><br><span class="line">                    init_concrete[dec.name()] &#x3D; model[dec].as_long()</span><br><span class="line"></span><br><span class="line">            print(f&quot;Try times: &#123;try_time&#125;, Input Value: &#123;init_concrete&#125;&quot;)</span><br><span class="line">            memory, _ &#x3D; concolic_func(func, init_concrete.copy())</span><br><span class="line">            print(memory)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;Try times: &#123;try_time&#125;, Path conditions got UNSAT&#x2F;UNKNOWN from z3&quot;)</span><br><span class="line">            print(f&quot;Conditions try to Solve: &#123;solver&#125;\n&quot;)</span><br><span class="line">                   </span><br></pre></td></tr></table></figure>
<p>如果将最大尝试次数设为10，执行concolic_executor(func_loop, [2, 31], 10)，则可以得到如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">threshold  &#x3D;  10</span><br><span class="line">First Try, Input Value: &#123;&#39;m&#39;: 2, &#39;n&#39;: 31&#125;</span><br><span class="line">Arguments: m,n</span><br><span class="line">Path Condition: m &gt; 0,m &lt; n</span><br><span class="line">Actual Table: m &#x3D; 4,n &#x3D; 31</span><br><span class="line">Symbol Table: </span><br><span class="line">	m &#x3D; m * 2</span><br><span class="line">	n &#x3D; n</span><br><span class="line"></span><br><span class="line">Try times: 2, Input Value: &#123;&#39;m&#39;: 1, &#39;n&#39;: 1&#125;</span><br><span class="line">Arguments: m,n</span><br><span class="line">Path Condition: m &gt;&#x3D; n</span><br><span class="line">Actual Table: m &#x3D; 1,n &#x3D; 1</span><br><span class="line">Symbol Table: </span><br><span class="line">	m &#x3D; m</span><br><span class="line">	n &#x3D; n</span><br><span class="line"></span><br><span class="line">Try times: 3, Input Value: &#123;&#39;m&#39;: 0, &#39;n&#39;: 1&#125;</span><br><span class="line">Arguments: m,n</span><br><span class="line">Path Condition: m &#x3D;&#x3D; 0,m &lt;&#x3D; 0,m &lt; n</span><br><span class="line">Actual Table: m &#x3D; 1,n &#x3D; 1</span><br><span class="line">Symbol Table: </span><br><span class="line">	m &#x3D; 1</span><br><span class="line">	n &#x3D; n</span><br><span class="line"></span><br><span class="line">Try times: 4, Input Value: &#123;&#39;m&#39;: -1, &#39;n&#39;: 0&#125;</span><br><span class="line">Arguments: m,n</span><br><span class="line">Path Condition: m !&#x3D; 0,m &lt;&#x3D; 0,m &lt; n</span><br><span class="line">Actual Table: m &#x3D; 1,n &#x3D; 0</span><br><span class="line">Symbol Table: </span><br><span class="line">	m &#x3D; m * -1</span><br><span class="line">	n &#x3D; n</span><br><span class="line"></span><br><span class="line">Try times: 5, Input Value: &#123;&#39;m&#39;: -1, &#39;n&#39;: -1&#125;</span><br><span class="line">Arguments: m,n</span><br><span class="line">Path Condition: m &gt;&#x3D; n</span><br><span class="line">Actual Table: m &#x3D; -1,n &#x3D; -1</span><br><span class="line">Symbol Table: </span><br><span class="line">	m &#x3D; m</span><br><span class="line">	n &#x3D; n</span><br><span class="line"></span><br><span class="line">Try times: 6, Input Value: &#123;&#39;m&#39;: 0, &#39;n&#39;: 1&#125;</span><br><span class="line">Arguments: m,n</span><br><span class="line">Path Condition: m &#x3D;&#x3D; 0,m &lt;&#x3D; 0,m &lt; n</span><br><span class="line">Actual Table: m &#x3D; 1,n &#x3D; 1</span><br><span class="line">Symbol Table: </span><br><span class="line">	m &#x3D; 1</span><br><span class="line">	n &#x3D; n</span><br><span class="line"></span><br><span class="line">Try times: 7, Input Value: &#123;&#39;m&#39;: 0, &#39;n&#39;: 0&#125;</span><br><span class="line">Arguments: m,n</span><br><span class="line">Path Condition: m &gt;&#x3D; n</span><br><span class="line">Actual Table: m &#x3D; 0,n &#x3D; 0</span><br><span class="line">Symbol Table: </span><br><span class="line">	m &#x3D; m</span><br><span class="line">	n &#x3D; n</span><br><span class="line"></span><br><span class="line">Try times: 8, Input Value: &#123;&#39;m&#39;: 0, &#39;n&#39;: 1&#125;</span><br><span class="line">Arguments: m,n</span><br><span class="line">Path Condition: m &#x3D;&#x3D; 0,m &lt;&#x3D; 0,m &lt; n</span><br><span class="line">Actual Table: m &#x3D; 1,n &#x3D; 1</span><br><span class="line">Symbol Table: </span><br><span class="line">	m &#x3D; 1</span><br><span class="line">	n &#x3D; n</span><br><span class="line"></span><br><span class="line">Try times: 9, Input Value: &#123;&#39;m&#39;: -1, &#39;n&#39;: 0&#125;</span><br><span class="line">Arguments: m,n</span><br><span class="line">Path Condition: m !&#x3D; 0,m &lt;&#x3D; 0,m &lt; n</span><br><span class="line">Actual Table: m &#x3D; 1,n &#x3D; 0</span><br><span class="line">Symbol Table: </span><br><span class="line">	m &#x3D; m * -1</span><br><span class="line">	n &#x3D; n</span><br><span class="line"></span><br><span class="line">Try times: 10, Input Value: &#123;&#39;m&#39;: 0, &#39;n&#39;: 1&#125;</span><br><span class="line">Arguments: m,n</span><br><span class="line">Path Condition: m &#x3D;&#x3D; 0,m &lt;&#x3D; 0,m &lt; n</span><br><span class="line">Actual Table: m &#x3D; 1,n &#x3D; 1</span><br><span class="line">Symbol Table: </span><br><span class="line">	m &#x3D; 1</span><br><span class="line">	n &#x3D; n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>可以看到在给定的次数中，程序遍历到了所有可能的路径，而且对m和n进行了随机取值，虽然不会遍历到所有可能的m、n取值，但是随着尝试次数的增大，很大可能可以覆盖可能的路径</p>
]]></content>
      <tags>
        <tag>形式化方法</tag>
      </tags>
  </entry>
  <entry>
    <title>快排中的partition</title>
    <url>/2021/03/05/%E5%BF%AB%E6%8E%92%E4%B8%AD%E7%9A%84partition/</url>
    <content><![CDATA[<p>快速排序中一个重要的步骤就是对待排序列 partition ，partition 会选出一个 pivot （ 枢轴，中心点 ），使得所有关键字较它小的都安置在它之前，所有关键字叫它大的都安置在它之后， partition 函数有哪些实现方式呢，哪种比较快？</p>
 <a id="more"></a>

<h3 id="严蔚敏版-partition"><a href="#严蔚敏版-partition" class="headerlink" title="严蔚敏版 partition"></a>严蔚敏版 partition</h3><p>严蔚敏版数据结构在「P274」页给出了双指针版的 partition ，基本思想是取最左侧的值作为 pivot ，利用双指针遍历，优先从右侧遍历（因为第一个 pivot 出现在左侧，已经被取走，所以该位置为空，可以放置第一个从右侧遍历出的小于  pivot 的值）， 用 c++ 实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotKey = arr[low]; <span class="comment">//取最左侧为枢纽</span></span><br><span class="line">    <span class="comment">//双指针遍历，优先先给low位置赋值，终止条件为两个指针重合</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[high] &gt; pivotKey)&#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivotKey)&#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = pivotKey;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="另一个版本的partition"><a href="#另一个版本的partition" class="headerlink" title="另一个版本的partition"></a>另一个版本的partition</h3><p>这个版本的 partition 也比较常见，『算法（第四版）』中关于 Random Select 算法中使用的也是这个 partition 方式，这种 partition 的方式是利用 一个额外的变量 current_pivot 记录<strong>已遍历部分</strong>的『枢轴』位置，c++实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotKey = arr[high]; <span class="comment">//不同于上一个版本的partition，这里以最右侧为枢纽</span></span><br><span class="line">    <span class="keyword">int</span> current_pivot = low<span class="number">-1</span>; <span class="comment">//当前的枢纽</span></span><br><span class="line">    <span class="comment">//在迭代中保持这样的不变式：小于等于枢纽的值位于[low, current_pivot]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt;= pivotKey)&#123;</span><br><span class="line">            ++current_pivot; <span class="comment">//当前枢纽需要右移一位</span></span><br><span class="line">            swap(arr[current_pivot], arr[i]); <span class="comment">//将小于等于枢纽的值交换到 [low, current_pivot]区间内</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将枢纽放回正确的位置</span></span><br><span class="line">    swap(arr[current_pivot+<span class="number">1</span>], arr[high]);</span><br><span class="line">    <span class="keyword">return</span> current_pivot+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个版本谁比较快呢，测试一下：</p>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotKey = arr[low]; <span class="comment">//取最左侧为枢纽</span></span><br><span class="line">    <span class="comment">//双指针遍历，优先先给low位置赋值，终止条件为两个指针重合</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[high] &gt; pivotKey)&#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivotKey)&#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = pivotKey;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotKey = arr[high]; <span class="comment">//不同于上一个版本的partition，这里以最右侧为枢纽</span></span><br><span class="line">    <span class="keyword">int</span> current_pivot = low<span class="number">-1</span>; <span class="comment">//当前的枢纽</span></span><br><span class="line">    <span class="comment">//在迭代中保持这样的不变式：小于等于枢纽的值位于[low, current_pivot]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt;= pivotKey)&#123;</span><br><span class="line">            ++current_pivot; <span class="comment">//当前枢纽需要右移一位</span></span><br><span class="line">            swap(arr[current_pivot], arr[i]); <span class="comment">//将小于等于枢纽的值交换到 [low, current_pivot]区间内</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将枢纽放回正确的位置</span></span><br><span class="line">    swap(arr[current_pivot+<span class="number">1</span>], arr[high]);</span><br><span class="line">    <span class="keyword">return</span> current_pivot+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> (*partition)(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high))</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">int</span> pivotloc = partition(arr, low, high);</span><br><span class="line">        quickSort(arr, low, pivotloc<span class="number">-1</span>, partition);</span><br><span class="line">        quickSort(arr, pivotloc+<span class="number">1</span>, high, partition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkResult</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr_len = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> time_cost_1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> time_cost_2 = <span class="number">0</span>;</span><br><span class="line">    chrono::steady_clock::time_point begin, end;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; ++i) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        srand(<span class="keyword">unsigned</span>(time(<span class="number">0</span>)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr_len; ++i) &#123;</span><br><span class="line">            arr.push_back(rand()%arr_len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr_copy = arr;</span><br><span class="line"></span><br><span class="line">        begin = chrono::steady_clock::now();</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.size(), partition1);</span><br><span class="line">        end = chrono::steady_clock::now();</span><br><span class="line">        time_cost_1 += (end - begin).count();</span><br><span class="line"></span><br><span class="line">        begin = chrono::steady_clock::now();</span><br><span class="line">        quickSort(arr_copy, <span class="number">0</span>, arr_copy.size(), partition2);</span><br><span class="line">        end = chrono::steady_clock::now();</span><br><span class="line">        time_cost_2 += (end - begin).count();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;checkResult(arr) &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; checkResult(arr_copy) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; time_cost_1 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; time_cost_2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">1 : 1</span><br><span class="line">1 : 1</span><br><span class="line">1 : 1</span><br><span class="line">1992431403</span><br><span class="line">2254204522</span><br></pre></td></tr></table></figure>
<p>可以看出双指针版本通常来说会稍快一点，因为在第二个版本的 partition2 当current_pivot == i 的时候可能会在 swap(arr[current_pivot], arr[i]) 语句存在多余的交换</p>
<h3 id="标准库中的sort"><a href="#标准库中的sort" class="headerlink" title="标准库中的sort"></a>标准库中的sort</h3><p>将 time_cost_2 中改为 sort ，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">        begin = chrono::steady_clock::now();</span><br><span class="line"><span class="comment">//        quickSort(arr_copy, 0, arr_copy.size(), partition2);</span></span><br><span class="line">        sort(arr_copy.begin(), arr_copy.end());</span><br><span class="line">        end = chrono::steady_clock::now();</span><br><span class="line">        time_cost_2 += (end - begin).count();</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">1 : 1</span><br><span class="line">1 : 1</span><br><span class="line">1 : 1</span><br><span class="line">1965534304</span><br><span class="line">496306010</span><br></pre></td></tr></table></figure>
<p>可以看出标准库的 sort 快了很多，看了一眼标准库的 sort 部分代码，似乎是部分基于快速排序的，但在选取 pivot 的时候多了很多额外的判断和优化</p>
<p>参考：</p>
<ul>
<li>数据结构（C语言版）-严蔚敏</li>
<li>算法（第四版）</li>
</ul>
]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>拷贝控制与赋值运算等</title>
    <url>/2021/01/12/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AD%89/</url>
    <content><![CDATA[<p>cpp的语言粒度相对Java要细的多，编程的时候需要更关注内存的使用和释放，但是在学习语法的过程中也会对一些语言中一些常见的操作例如赋值、拷贝动作有更深的体会，cpp将a = b这样简单的动作分解并允许使用者自定义</p>
 <a id="more"></a>

<p>拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数，如果没有定义拷贝构造函数，编译器也会默认定义一个合成拷贝构造函数，这个函数对类类型的成员会使用构造函数来拷贝，对于内置类型的成员会直接拷贝，下面重点看拷贝构造函数和拷贝赋值运算符</p>
<p>拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;);<span class="comment">//这里如果不是引用，则调用拷贝构造函数需要先调用构造函数...循环调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为拷贝构造函数的存在，所以可以使用 { … }来给要赋值的对象的成员属性赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person p &#x3D; &quot;name&quot;;&#x2F;&#x2F;右侧就算是一个对象同样也是提取它的成员属性进行赋值，但是对explicit不适用</span><br></pre></td></tr></table></figure>
<p>重载赋值运算符：重载运算符本质是函数，其名字由operator关键字后接表示要定义的运算符的符号组成，赋值运算符就是一个名为operator=的函数，类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表</p>
<p>重载运算符的参数表示运算符的运算对象，如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数，二元运算符的右侧运算对象作为显式参数传递</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Foo &amp; operator&#x3D;(const Foo &amp;);&#x2F;&#x2F;赋值运算符，返回一个指向其左侧运算对象的引用</span><br></pre></td></tr></table></figure>
<h5 id="e-g-拷贝控制与赋值运算符"><a href="#e-g-拷贝控制与赋值运算符" class="headerlink" title="e.g-拷贝控制与赋值运算符"></a>e.g-拷贝控制与赋值运算符</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关于：</span></span><br><span class="line"><span class="comment"> * 构造函数</span></span><br><span class="line"><span class="comment"> * 拷贝构造函数</span></span><br><span class="line"><span class="comment"> * 拷贝赋值运算符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在何时调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结论：</span></span><br><span class="line"><span class="comment"> * 有Person这种才是构造函数或者拷贝构造函数</span></span><br><span class="line"><span class="comment"> *  a = b 这种没有类名的是拷贝赋值运算符</span></span><br><span class="line"><span class="comment"> *  编译器可以绕过拷贝构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;default &quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp; p)&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; copy &quot;</span>&lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    Person <span class="keyword">operator</span>=(<span class="keyword">const</span> Person &amp;p)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; operator &quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Person p)</span></span>&#123; <span class="keyword">return</span> ;&#125;</span><br><span class="line"><span class="function">Person <span class="title">f2</span><span class="params">()</span></span>&#123; Person p; <span class="keyword">return</span> p;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p1; <span class="comment">//default</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;=========p1 end=========&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Person p2 = p1;<span class="comment">// copy</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;=========p2 end=========&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>;<span class="comment">// copy</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;=========p3 end=========&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Person p4;<span class="comment">//default</span></span><br><span class="line">    p4 = p3;<span class="comment">//operator</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;=========p4 end=========&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    f1(p4);<span class="comment">// copy</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;=========f1 end=========&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    f2();<span class="comment">//default</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;=========f2 end=========&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Person p5 = f2();<span class="comment">//default 编译器绕过了拷贝构造函数而使用的是构造函数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;=========p5 end=========&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>拷贝控制</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统与V结点</title>
    <url>/2021/01/12/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8EV%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<p>在Linux操作系统中，将近乎所有都看成是文件，包括普通文件、目录、其他资源等等，如果需要读写访问文件则需要使用内核提供的文件描述符</p>
<p>从字面意思来看，很容易把文件描述符看成是一个具体文件带偏移量的索引，这样系统就可以知道在何处开始读写操作。实际上文件描述符是一个小的非负整数，内核来标识一个特定进程正在访问的文件。也就是说文件描述符缺失是作为读写系统调用的参数来使用的，但文件描述符和特定进程是绑定的。因为这样每个进程只需要将系统文件表项中进程需要的索引保存在自己当前的进程表项中，且对同一个文件每一个进程都可以保存自己的读写位置</p>
 <a id="more"></a>

<p>从上面可以得出，文件描述符在每个进程表项中可以得到系统文件表项，而系统文件表项中存放v节点的指针、文件偏移量以及文件状态等</p>
<p>什么是v节点？(v节点是Unix的定义，实际上Linux的概念是相同的，只不过命名不同，Linux中v节点也叫i节点)每个打开文件都有一个v节点，v节点包含了文件类型和对此文件进行各种操作函数的指针，对于大多数文件，v节点还包含了该文件的i节点指针，i节点包含真正的物理地址、所有者以及文件长度等，也就是说v节点实际包含了对文件物理共享操作的所有信息</p>
<p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/hexo/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8Ev%E8%8A%82%E7%82%B9.png" alt="文件节点"></p>
<p>总结一下，Unix文件系统对于文件的操作可以看成3层，第1层是各个进程的表项，索引找到系统的文件表项，第2层是文件表项，除了文件状态和v节点指针以外，还存放当前文件的偏移量，也就是说如果不实际修改物理存储仅仅修改或重置偏移量到这一层就可以了，第3层是v节点，这时候可以开始对磁盘文件进行读写了，文件共享的加锁等处理也是在这一层实现</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>V结点</tag>
      </tags>
  </entry>
  <entry>
    <title>求连通分量个数问题</title>
    <url>/2021/01/12/%E6%B1%82%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E4%B8%AA%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在图的问题中，常常会碰到这样一类问题，对于N个点的不同集合，很多点两两之间有等价的可传递的联系，这种联系将它们分成若干类，如果能顺利遍历这些联系并将它们正确分类，问题往往迎刃而解</p>
 <a id="more"></a>

<p>在刚开始遇到这类的问题的时候，我的思路是对于A、B两个点的集合而言，如果A和B中出现了重合的点，则合并A、B集合，这样重复直到集合的数量不再改变。这样做的问题在于复杂度过高，并且需要在迭代set的时候进行修改容易出错。实际上用标记的方式来代替set的迭代更简单效率更高</p>
<p>这类问题的标记方法主要有三种：</p>
<ul>
<li>DFS</li>
<li>BFS</li>
<li>并查集</li>
</ul>
<p>DFS和BFS在遍历的时候需要借助另外的空间来标记当前节点是否已经被访问过，并查集需要标记当前节点属于哪个集合</p>
<h4 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547. 省份数量"></a><a href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份数量</a></h4><p>难度中等444</p>
<p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p>
<p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p>
<p>返回矩阵中 <strong>省份</strong> 的数量。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：isConnected &#x3D; [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：isConnected &#x3D; [[1,0,0],[0,1,0],[0,0,1]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 200</code></li>
<li><code>n == isConnected.length</code></li>
<li><code>n == isConnected[i].length</code></li>
<li><code>isConnected[i][j]</code> 为 <code>1</code> 或 <code>0</code></li>
<li><code>isConnected[i][i] == 1</code></li>
<li><code>isConnected[i][j] == isConnected[j][i]</code></li>
</ul>
<h3 id="DFS解法："><a href="#DFS解法：" class="headerlink" title="DFS解法："></a>DFS解法：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//聚类的问题</span></span><br><span class="line">        <span class="keyword">int</span> n = isConnected.size();</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;n ; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            ++ret;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ; j&lt;n ; ++j)&#123;</span><br><span class="line">                <span class="comment">//对j的位置进行dfs</span></span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j] &amp;&amp; !vis[j])&#123;</span><br><span class="line">                    search(isConnected, vis, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;vis, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        vis[index] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;isConnected.size() ; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isConnected[index][i] &amp;&amp; !vis[i])&#123;</span><br><span class="line">                search(isConnected, vis, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="并查集解法："><a href="#并查集解法：" class="headerlink" title="并查集解法："></a>并查集解法：</h3><ul>
<li>初始化parent = 自身</li>
<li>union操作</li>
<li>查找剩余的root</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//并查集解法</span></span><br><span class="line">        <span class="keyword">int</span> n = isConnected.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">parent</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;n ; ++i)&#123;</span><br><span class="line">            parent[i] = i; <span class="comment">//初始的parent都是自身</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;n ; ++i)&#123;</span><br><span class="line">            <span class="comment">// j&gt;i,二维矩阵是对角线对称的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span> ; j&lt;n ; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j])&#123;</span><br><span class="line">                    unionCity(parent, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//检查剩余的root数目</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;n ; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parent[i] == i)&#123;</span><br><span class="line">                ++ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findParent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;parent, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> par = parent[index];</span><br><span class="line">        <span class="keyword">while</span>(index != par)&#123;</span><br><span class="line">            index = par;</span><br><span class="line">            par = parent[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> par;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionCity</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;parent, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//两个节点union的时候，可能存在index1的root是A, index2的root是B,</span></span><br><span class="line">        <span class="comment">//需要修改的是A-&gt;B而不是index1和index2的指向 </span></span><br><span class="line">        <span class="keyword">int</span> root1 = findParent(parent, index1);</span><br><span class="line">        <span class="keyword">int</span> root2 = findParent(parent, index2);</span><br><span class="line">        parent[root1] = root2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="5650-执行交换操作后的最小汉明距离"><a href="#5650-执行交换操作后的最小汉明距离" class="headerlink" title="5650. 执行交换操作后的最小汉明距离"></a><a href="https://leetcode-cn.com/problems/minimize-hamming-distance-after-swap-operations/">5650. 执行交换操作后的最小汉明距离</a></h4><p>难度中等5</p>
<p>给你两个整数数组 <code>source</code> 和 <code>target</code> ，长度都是 <code>n</code> 。还有一个数组 <code>allowedSwaps</code> ，其中每个 <code>allowedSwaps[i] = [ai, bi]</code> 表示你可以交换数组 <code>source</code> 中下标为 <code>ai</code> 和 <code>bi</code>（<strong>下标从 0 开始</strong>）的两个元素。注意，你可以按 <strong>任意</strong> 顺序 <strong>多次</strong> 交换一对特定下标指向的元素。</p>
<p>相同长度的两个数组 <code>source</code> 和 <code>target</code> 间的 <strong>汉明距离</strong> 是元素不同的下标数量。形式上，其值等于满足 <code>source[i] != target[i]</code> （<strong>下标从 0 开始</strong>）的下标 <code>i</code>（<code>0 &lt;= i &lt;= n-1</code>）的数量。</p>
<p>在对数组 <code>source</code> 执行 <strong>任意</strong> 数量的交换操作后，返回 <code>source</code> 和 <code>target</code> 间的 <strong>最小汉明距离</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：source &#x3D; [1,2,3,4], target &#x3D; [2,1,4,5], allowedSwaps &#x3D; [[0,1],[2,3]]</span><br><span class="line">输出：1</span><br><span class="line">解释：source 可以按下述方式转换：</span><br><span class="line">- 交换下标 0 和 1 指向的元素：source &#x3D; [2,1,3,4]</span><br><span class="line">- 交换下标 2 和 3 指向的元素：source &#x3D; [2,1,4,3]</span><br><span class="line">source 和 target 间的汉明距离是 1 ，二者有 1 处元素不同，在下标 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：source &#x3D; [1,2,3,4], target &#x3D; [1,3,2,4], allowedSwaps &#x3D; []</span><br><span class="line">输出：2</span><br><span class="line">解释：不能对 source 执行交换操作。</span><br><span class="line">source 和 target 间的汉明距离是 2 ，二者有 2 处元素不同，在下标 1 和下标 2 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：source &#x3D; [5,1,2,4,3], target &#x3D; [1,5,4,2,3], allowedSwaps &#x3D; [[0,4],[4,2],[1,3],[1,4]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == source.length == target.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= source[i], target[i] &lt;= 105</code></li>
<li><code>0 &lt;= allowedSwaps.length &lt;= 105</code></li>
<li><code>allowedSwaps[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt;= n - 1</code></li>
<li><code>ai != bi</code></li>
</ul>
<p>这题一开始使用的DFS做的没做出来，主要没想好如何处理汉明距离的比较，参考了下别人的题解发现可以用集合的元素差异</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;parent, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> par = parent[x];</span><br><span class="line">        <span class="keyword">while</span>(par != x)&#123;</span><br><span class="line">            x = par;</span><br><span class="line">            par = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> par;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;parent, <span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> find1 = Find(parent, n1);</span><br><span class="line">        <span class="keyword">int</span> find2 = Find(parent, n2);</span><br><span class="line">        parent[find1] = find2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumHammingDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; source, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; allowedSwaps)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*求连通分量的问题</span></span><br><span class="line"><span class="comment">        在这种复杂的结构中DFS和BFS比较复杂</span></span><br><span class="line"><span class="comment">        使用并查集</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> len = source.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">parent</span><span class="params">(len)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;len ; ++i)&#123;</span><br><span class="line">            parent[i] = i; <span class="comment">//第一步初始化parent数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec: allowedSwaps)&#123;</span><br><span class="line">            Union(parent, vec[<span class="number">0</span>], vec[<span class="number">1</span>]);<span class="comment">//第二步Union操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第三步处理剩余的root</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            最小汉明距离可以用两个set之间元素相差的个数来表示</span></span><br><span class="line"><span class="comment">            因为元素可重所以使用unordered_multiset</span></span><br><span class="line"><span class="comment">            如果不在swap数组里的元素s[i]=&#123;source[i]&#125;,</span></span><br><span class="line"><span class="comment">                t[i]=&#123;target[i]&#125;，比较是它们自身的值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_multiset</span>&lt;<span class="keyword">int</span>&gt;&gt; s, t; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;len ; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> findx = Find(parent, i);</span><br><span class="line">            <span class="comment">//对比source、target两个map的set，不出现在swap数组中的元素这里对比的是下标相对应的值</span></span><br><span class="line">            s[findx].insert(source[i]); </span><br><span class="line">            t[findx].insert(target[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;len ; ++i)&#123;</span><br><span class="line">            <span class="comment">//遍历s的set查找对应的t</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span> &amp;sval : s[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(t[i].find(sval) == t[i].end())&#123;</span><br><span class="line">                    ++ret;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//可重复set直接erase会删除所有等于target的值</span></span><br><span class="line">                    t[i].erase(t[i].find(sval));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>图算法</tag>
        <tag>分类问题</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Web编程</title>
    <url>/2021/02/20/%E6%B5%85%E8%B0%88Web%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>在BS（Browser/Server）架构下，服务器端是如何响应客户端请求的，如何处理用户不同的请求类型的，现代Web的开发框架Spring和Flask是如何工作的?</p>
 <a id="more"></a>

<h4 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h4><p>在BS（Browser/Server）架构下，服务器的工作模式有所不同，客户端发来的不仅仅是标准IO的类型，更多的是各种表单类型，还包括浏览器的一些特性例如cookie等，Web服务器端可以将这些变量保存在环境变量中，交给外部的应用来解析出变量的内容，然后外部应用返回一个HTML页面给Web服务器，Web服务器将这个页面返回给客户端，这就使用到了CGI，例如表单处理的流程图如下：</p>
<img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/hexo/pzYvZrP5cjFSlN4.png" alt="image-20210220094657376"  />



<p>CGI（Common Gateway Interface）是一种让Web服务器能够执行外部程序处理用户请求的接口规范，CGI脚本就是处理表单返回HTML（附带有效头文件）的脚本。</p>
<h4 id="CGI脚本解析出错了会导致什么情况"><a href="#CGI脚本解析出错了会导致什么情况" class="headerlink" title="CGI脚本解析出错了会导致什么情况"></a>CGI脚本解析出错了会导致什么情况</h4><p>当CGI脚本崩溃的时候（通常代码出错导致脚本无法处理request请求），CGI脚本会返回给Web服务器错误的回溯信息，这些信息因为不附带有效的头文件也不是HTML类型，所以Web服务器无法理解会抛弃这个响应，返回500错误，也就是常见的服务器错误（实则是服务器所执行的应用程序出错），但是现在的IDE集成的原因，有些Web环境（例如Python）都是以错误回溯消息代替500错误</p>
<h4 id="c-实现的简单CGI脚本"><a href="#c-实现的简单CGI脚本" class="headerlink" title="c++实现的简单CGI脚本"></a>c++实现的简单CGI脚本</h4><p>如果用c++实现一个简单的CGI服务器脚本程序，我们需要做的是：</p>
<ol>
<li>服务器端监听端口</li>
<li>接受请求，完成连接</li>
<li>fork出CGI处理进程来处理request</li>
<li>CGI处理进程向标准输出写入HTML</li>
<li>HTML输出重定向到TCP连接套接字</li>
</ol>
<h4 id="CGI缺点与改进"><a href="#CGI缺点与改进" class="headerlink" title="CGI缺点与改进"></a>CGI缺点与改进</h4><p>CGI的缺点在于如果针对每一个这样的连接都fork出一个子进程，那么在面对多连接请求的时候系统很快就会崩溃，所以有了以下两种改进方法：</p>
<ul>
<li>改进方法1：服务器集成，代表为Apache HTTP Web服务器，服务器根据对应的API通过一组预先创建的进程或者线程来工作</li>
<li>改进方法2：CGI作为外部进程在服务器外部运行，代表为FastCGI</li>
</ul>
<h4 id="J2EE：Apache-HTTP-Web和Tomcat"><a href="#J2EE：Apache-HTTP-Web和Tomcat" class="headerlink" title="J2EE：Apache HTTP Web和Tomcat"></a>J2EE：Apache HTTP Web和Tomcat</h4><p>Apache HTTP Web是将这个外部应用模块集成到服务器端中去，将原来fork的部分替换成：1、提前创建多个进程，2、将处理request替换为函数调用。这样就大大提高了并发的性能，但是本质上还是返回HTML也就是静态页面，所以在J2EE中还有大名鼎鼎的Tomcat来处理动态页面（例如JSP，事实上Tomcat也可以处理静态页面，不过效率比Apache HTTP Web低），而Tomcat本质上是一个Servlet容器，处理流程如下：</p>
<ol>
<li>客户端（通常都是浏览器）访问Web服务器，发送HTTP请求。</li>
<li>Web服务器接收到请求后，传递给Servlet容器。</li>
<li>Servlet容器加载Servlet，产生Servlet实例后，向其传递表示请求和响应的对象。</li>
<li>Servlet实例使用请求对象得到客户端的请求信息，然后进行相应的处理。</li>
<li>Servlet实例将处理结果通过响应对象发送回客户端，容器负责确保响应正确送出，同时将控制返回给Web服务器。</li>
</ol>
<p>可以看出Apache HTTP Web和Tomcat都是将外部应用以不同方式集成到服务器端，这样做的好处是集成度高，缺点是耦合性高，无论是实现的语言还是安全性</p>
<h4 id="Python：WSGI"><a href="#Python：WSGI" class="headerlink" title="Python：WSGI"></a>Python：WSGI</h4><p>CGI作为外部进程在服务器外部运行，耦合性低，但是与服务器集成的接口太过灵活成为开发者的负担，WCGI（Web Server Gateway Interface）就是Python Web服务器网类接口标准</p>
<p>WSGI：是定义的接口，目标在Web服务器和Web框架层之间提供一个通用的API标准，形成统一的调用方式。WSGI有两个参数：1、含有服务器环境变量的字典，2、可调用对象</p>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span>(<span class="params">env, start_response</span>):</span></span><br><span class="line">  status = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line">  headers = ((<span class="string">&#x27;Content-type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>))</span><br><span class="line">  start_response(status, headers)</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">&#x27;Hello world!&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>start_response是一个可调用对象，类似如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_response</span>(<span class="params">status, headers</span>):</span></span><br><span class="line">  将status写入body</span><br><span class="line">  <span class="keyword">for</span> header <span class="keyword">in</span> headers:</span><br><span class="line">    将header写入body</span><br><span class="line">  <span class="keyword">return</span> body.write  <span class="comment"># 在Servlet中是PrintWriter对象向浏览器输入数据流</span></span><br></pre></td></tr></table></figure>
<h4 id="现代Web开发"><a href="#现代Web开发" class="headerlink" title="现代Web开发"></a>现代Web开发</h4><p>现在Web框架下有众多优秀的框架，集成了众多功能，让Web开发变得更加容易，实际上服务器端通信的方式仍没有改变，例如：</p>
<p>Python的Web框架下通信（以Flask为例）</p>
<p>在Flask文档中有以下说明：当安装 Flask 时，以下配套软件会被自动安装。Werkzeug [<a href="https://palletsprojects.com/p/werkzeug/]">https://palletsprojects.com/p/werkzeug/]</a> 用于实现 WSGI ，应用和服务之间的标准 Python 接口。”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">“<span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, World!”</span></span><br></pre></td></tr></table></figure>
<p>接着：“我们导入了 Flask 类。 该类的实例将会成为我们的 WSGI 应用。”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“在运行应用之前，需要在终端里导出 FLASK_APP 环境变量:</span><br><span class="line">$ export FLASK_APP&#x3D;hello.py</span><br><span class="line">$ flask run</span><br><span class="line"> * Running on http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;”</span><br></pre></td></tr></table></figure>
<p>总结如下图所示：</p>
<p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/hexo/image-20210220151134825.png" alt="image-20210220151134825"></p>
<p>Flask具体工作流程图如下：</p>
<p><img src="https://pham-nuwens-document.readthedocs.io/zh/latest/_images/037DA780-F8DA-47EF-AE7E-3D10A9380CD1.png" alt="../_images/037DA780-F8DA-47EF-AE7E-3D10A9380CD1.png"></p>
<p>SpringMVC工作流程图</p>
<p><img src="https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/images/mvc.png" alt="img"></p>
<p>可以看出Python和Java的一些Web框架还是参照Http服务器 + 外部处理应用程序的方式来实现，Http服务器部分负责接受分发request和返回response，外部处理应用程序部分负责request处理，并且外部处理程序与模板以及框架的其他组件之间交互使得框架有很高的开发效率</p>
<p>参考：</p>
<ul>
<li>Hedand M L. Python 核心编程[J]. 2010.</li>
<li><a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface#Using_CGI_scripts">Wikipedia: Common Gateway Interface</a></li>
<li><a href="https://birdben.github.io/2017/03/05/Java/Python%E5%92%8CJava%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E6%AF%94%E8%BE%83/">Python和Java服务器通信实现的理解和比较</a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html">SpringMVC文档</a></li>
<li><a href="https://dormousehole.readthedocs.io/en/latest/foreword.html">Flask中文文档</a></li>
</ul>
<p>注：</p>
<ul>
<li>因水平有限个人总结难免出错</li>
<li>欢迎指正</li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>Flask</tag>
        <tag>Java</tag>
        <tag>CGI</tag>
        <tag>WSGI</tag>
        <tag>Servlet</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记策略和markdown文档图片处理脚本</title>
    <url>/2021/02/10/%E7%AC%94%E8%AE%B0%E7%AD%96%E7%95%A5%E5%92%8Cmarkdown%E6%96%87%E6%A1%A3%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>理想的笔记需求：</p>
<ol>
<li>支持markdown，图片自动上传到云存储</li>
<li>多终端同步</li>
<li>方便的搜索</li>
<li>方便的导入导出md格式（这样可以创建脚本根据这些md文档自动更新博客）</li>
</ol>
<p>目前市面上的产品都或多或少不能全部满足这些需求</p>
 <a id="more"></a>

<p>目前的解决方式是Typora本地编辑模式和坚果云来进行同步，将图片插入目录设置为同步文件夹下的相对路径，例如./images目录，这样多终端的时候也是可以直接显示的</p>
<p>这样2和4就解决了，由于hexo中加载云端的图片比较快，所以考虑使用脚本将md文件中引用的图片自动上传，然后替换为cos的地址，至于搜索功能在hexo上可以实现，本地可能暂时还没有好的办法</p>
<h3 id="图片路径替换脚本"><a href="#图片路径替换脚本" class="headerlink" title="图片路径替换脚本"></a>图片路径替换脚本</h3><p>目标只有两个：</p>
<ol>
<li><p>上传md文档中本地的图片：这里依赖不同云存储的SDK，笔者使用的是腾讯云的数据万象，其他的cos也可以类似处理</p>
</li>
<li><p>替换文档中图片的路径：这个部分感觉用shell脚本做可能更好，但是为了方便一把梭哈了。事实上替换文件中的某些部分不同于追加append，并不是直接找到文件的末尾，可以通过包括但不限于以下方式实现：</p>
<ol>
<li><p>copy当前替换行之前（before part），追加替换后的行，追加替换行之后部分（after part）</p>
</li>
<li><p>读每一行，如果当前行是需要替换的行则写替换行，如果不是，则写回当前行</p>
<p>这里使用的是方法2，这些方式都需要一个临时的缓存文件实现。Attention：这里不要轻易拿源md文件实验，亲历有个bug然后所有文件一秒被写成0字节…</p>
</li>
</ol>
</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> qcloud_cos <span class="keyword">import</span> CosConfig</span><br><span class="line"><span class="keyword">from</span> qcloud_cos <span class="keyword">import</span> CosS3Client</span><br><span class="line"><span class="keyword">from</span> qcloud_cos <span class="keyword">import</span> CosServiceError</span><br><span class="line"><span class="keyword">from</span> qcloud_cos <span class="keyword">import</span> CosClientError</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">扫描使用Typora的markdown文档下的本地图片，上传到腾讯云cos并替换markdown中路径为腾讯云中的路径</span></span><br><span class="line"><span class="string">扫描目标：</span></span><br><span class="line"><span class="string"> 1、md插入图片格式： &#x27; ![&#x27;, </span></span><br><span class="line"><span class="string"> 2、缩放过的图片插入格式： &#x27;&lt;img src=&quot; &#x27;</span></span><br><span class="line"><span class="string"> 两种类型(后面用于图片缩放过的)，绝对路径和相对路径都是可以的，对于已经是网络路径的图片不会进行替换</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Attention：</span></span><br><span class="line"><span class="string">    需要关闭Typora全局图像设置：&#x27;插入时自动转义图片URL选项&#x27;</span></span><br><span class="line"><span class="string">    使用前请备份！！！</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">cos_path = <span class="string">&#x27;https://xxxx-xxxxxx.xxxxx.myqcloud.com/&#x27;</span>  <span class="comment"># 需要配置：腾讯云cos的bucket存储桶的url</span></span><br><span class="line">cos_folder = <span class="string">&#x27;mac_md/&#x27;</span>  <span class="comment"># 需要配置：上传到腾讯云cos的文件夹名</span></span><br><span class="line">source_path = <span class="string">&#x27;/Users/yufei/Desktop/mac_md/&#x27;</span>  <span class="comment"># 需要配置：本地需要扫描的markdown文档目录需要以&#x27;/&#x27;结尾，例如：/Users/yufei/Desktop/test/</span></span><br><span class="line">secret_id = <span class="string">&#x27;XXXXXXXXXXXXXXXXXXXXXXXXXXXX&#x27;</span>  <span class="comment"># 需要配置：腾讯云cos的secret_id</span></span><br><span class="line">secret_key = <span class="string">&#x27;XXXXXXXXXXXXXXXXXXXXXXXXXXXXX&#x27;</span>  <span class="comment"># 需要配置：腾讯云cos的secret_key</span></span><br><span class="line">region = <span class="string">&#x27;ap-shanghai&#x27;</span>  <span class="comment"># 需要配置：腾讯云cos的region</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换文档中图片的路径,这部分不可以并发，并非追加append模式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify_file</span>(<span class="params">filename, text_to_search, replacement_text, water_mark=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        filedata = file.read()</span><br><span class="line">    filedata = filedata.replace(text_to_search, replacement_text+water_mark)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(filedata)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 扫描md文档中的image，上传本地文件(if exists)，替换原图片路径为云路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_replace</span>(<span class="params">hexo_posts_path, replace_regular_header=[<span class="string">&#x27;![&#x27;</span>, <span class="string">&#x27;&lt;img src=&quot;&#x27;</span>]</span>):</span></span><br><span class="line">    files = os.listdir(hexo_posts_path)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        modify_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(hexo_posts_path+file):</span><br><span class="line">            image_replace(hexo_posts_path+file+<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> file.endswith(<span class="string">&quot;.md&quot;</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(hexo_posts_path+file, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            lines = f.readlines()</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">                local_image_path = <span class="string">&quot;&quot;</span></span><br><span class="line">                <span class="keyword">if</span> <span class="string">&quot;http&quot;</span> <span class="keyword">in</span> local_image_path:  <span class="comment"># 不替换网页图片引用</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> replace_regular_header[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> line <span class="keyword">and</span> replace_regular_header[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> line:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> replace_regular_header[<span class="number">0</span>] <span class="keyword">in</span> line:</span><br><span class="line">                    <span class="keyword">if</span> <span class="string">&#x27;]&#x27;</span> <span class="keyword">in</span> line <span class="keyword">and</span> <span class="string">&#x27;(&#x27;</span> <span class="keyword">in</span> line <span class="keyword">and</span> <span class="string">&#x27;)&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">                        start_index = line.find(<span class="string">&#x27;(&#x27;</span>, line.find(replace_regular_header[<span class="number">0</span>]))</span><br><span class="line">                        end_index = line.find(<span class="string">&#x27;)&#x27;</span>, start_index+<span class="number">1</span>)</span><br><span class="line">                        local_image_path = line[start_index+<span class="number">1</span>: end_index]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> replace_regular_header[<span class="number">1</span>] <span class="keyword">in</span> line:</span><br><span class="line">                    start_index = line.find(replace_regular_header[<span class="number">1</span>]) + <span class="built_in">len</span>(replace_regular_header[<span class="number">1</span>])</span><br><span class="line">                    end_index = line.find(<span class="string">&#x27;&quot;&#x27;</span>, start_index+<span class="number">1</span>)</span><br><span class="line">                    local_image_path = line[start_index: end_index]</span><br><span class="line">                image_name = local_image_path.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">                modify_dict[local_image_path] = cos_path + cos_folder + image_name</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> local_image_path.startswith(<span class="string">&#x27;.&#x27;</span>):  <span class="comment"># 处理相对路径</span></span><br><span class="line">                    local_image_path = local_image_path[<span class="number">2</span>:]</span><br><span class="line">                    t = threading.Thread(target=image_upload, args=(hexo_posts_path+file, hexo_posts_path+local_image_path, image_name))</span><br><span class="line">                    t.start()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    t = threading.Thread(target=image_upload, args=(hexo_posts_path+file, local_image_path, image_name))</span><br><span class="line">                    t.start()</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> modify_dict:</span><br><span class="line">            modify_file(hexo_posts_path+file, key, modify_dict[key])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_upload</span>(<span class="params">md_file_name, file_path, file_name, rename_folder=cos_folder</span>):</span></span><br><span class="line">    logging.basicConfig(level=logging.INFO, stream=sys.stdout)</span><br><span class="line">    token = <span class="literal">None</span>  <span class="comment"># 使用临时密钥需要传入Token，默认为空,可不填</span></span><br><span class="line">    config = CosConfig(Region=region, SecretId=secret_id, SecretKey=secret_key, Token=token)  <span class="comment"># 获取配置对象</span></span><br><span class="line">    client = CosS3Client(config)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 文件流 简单上传</span></span><br><span class="line">    finish = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            response = client.put_object(</span><br><span class="line">                Bucket=<span class="string">&#x27;feiyu-xxxxxxxxxxx&#x27;</span>,  <span class="comment"># Bucket由bucketname-appid组成</span></span><br><span class="line">                Body=fp,</span><br><span class="line">                Key=rename_folder+file_name,</span><br><span class="line">                StorageClass=<span class="string">&#x27;STANDARD&#x27;</span>,</span><br><span class="line">                EnableMD5=<span class="literal">False</span></span><br><span class="line">            )</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError <span class="keyword">as</span> e:</span><br><span class="line">        finish = <span class="literal">False</span></span><br><span class="line">        print(e)</span><br><span class="line">    <span class="keyword">if</span> finish:</span><br><span class="line">        print(md_file_name + <span class="string">&quot; =====&gt; done!&quot;</span> + <span class="string">&quot;\n          &quot;</span> + file_path + <span class="string">&quot; &quot;</span> + file_name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(md_file_name + <span class="string">&quot; =====&gt; fail!&quot;</span> + <span class="string">&quot;\n          &quot;</span> + file_path + <span class="string">&quot; &quot;</span> + file_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    image_replace(source_path)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><p>这个脚本是实验性的，在本地电脑运行处理了之前写的部分md文档，效果总体来说还行，但是还有很大的优化空间</p>
]]></content>
      <tags>
        <tag>脚本</tag>
        <tag>笔记</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>编译与gcc</title>
    <url>/2021/01/12/%E7%BC%96%E8%AF%91%E4%B8%8Egcc/</url>
    <content><![CDATA[<p>在学习c和cpp的过程中，如果使用vscode的话或者Linux系统进行编译的话难免要自己编写Makefile，习惯了点击run和java -jar难免会有些不适，所以总结下相关的知识</p>
<p>如何编译一个project是一件很有意思的事，因为各个module之间会存在有顺序的依赖关系，理论上类似一个有向无环图，在Java中有类似Maven这类包的管理工具，当出现依赖黑洞这些问题的时候，IDEA可以帮助分析包之间的关系，c和cpp是粒度更细的语言，给我们更大程度的自由同时也需要做的更多</p>
<p>注：在对gcc版本进行升级的时候需要注意std::string和std::list的ABI(Application Binary Interface)的变化，也就是说如果编译部分使用的是新ABI接口(gcc version &gt;= 5.1)而lib使用的是老的ABI接口(gcc version &lt; 5.1)，那么在link的时候是无法进行link，会报错如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">undefined reference to `<span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="keyword">char</span>, <span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;, <span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt; &gt;::basic_string(<span class="keyword">char</span> <span class="keyword">const</span>*, <span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt; <span class="keyword">const</span>&amp;)<span class="string">&#x27; </span></span><br></pre></td></tr></table></figure>
<p>解决方法就是去统一这个ABI接口，要么全部使用老接口(在gcc高版本编译时指定_GLIBCXX_USE_CXX11_ABI=0)，要么使用gcc高版本将老的lib重新编译，这样就可以link成功了</p>
 <a id="more"></a>

<p>在初学c类语言的时候就接触过 #include，#include是一个预处理指令，作用等价于将头文件的内容拷贝到当前行，实则是一个替换的过程，与之相类似拷贝替换的还有#define、内联函数，#define和内联函数inline更接近，区别在于#define是在词法分析结束语法分析开始之前就进行替换，也就是说无语义的替换，而函数实际上是有明确的语义的，例如max()，之所以这样区分是因为有时候我们仅仅需要的是token的替换，顺便说下，因为进程切换上下文是比较耗时的，所以对于那些执行时间短、无递归的函数原地展开比进程切换要更好</p>
<p>在编译过程中，#if, #else, #endif 代表条件编译，有时候我们需要根据不同的环境选择不同的编译方式，例如在标准库中大量的对于某些已经定义编译过的不再重复引入编译</p>
<p>一个.c文件在编译结束后可以得到.o文件，并不能直接执行，我们还需要将多个.o文件以及需要库文件(.a文件，多个.o文件打包 而成可以直接调用接口)链接在一起得到最终的target可执行文件，链接分为静态链接和动态链接，以前学习操作系统的印象来看，动态链接并不是一次性装入内存的，根据内存的偏移量可以实现同一段装入部分的复用</p>
<p>gcc是由GNU开发的编程语言译器，在Linux环境下编译可以使用如下的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc transcode.c -o transcode -lavformat -lavcodec -lavutil -lz -lm -lpthread -lswresample -lavcodec -lavformat -lavutil</span><br></pre></td></tr></table></figure>
<ul>
<li>-I(大写i) 表示寻找的include目录</li>
<li>-L 表示寻找的lib目录</li>
</ul>
<p>复杂的情况下，还是要编写Makefile更为方便一点</p>
]]></content>
      <tags>
        <tag>编译</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>编译器前端相关名词</title>
    <url>/2021/01/12/%E7%BC%96%E8%AF%91%E5%99%A8%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D/</url>
    <content><![CDATA[<p>Java写编译器前端的笔记</p>
<p><a href="https://zfeiyu1122.gitbook.io/zfeiyu/">https://zfeiyu1122.gitbook.io/zfeiyu/</a></p>
 <a id="more"></a>

<ul>
<li>文法：如果把LL语法分析比作一条处理前端传来的记号流的机器流水线的话，那么文法就是这个流水线工作的设计图，这个流水线想要得到什么样的结果大部分取决于这个设计图纸。我们设计一个图纸，然后按照这个图纸build出这条流水线。</li>
<li>上下文无关文法：抛开上下文，只针对当前部分按照定义实现推导的文法</li>
<li>终结符和非终结符：简单来说终结符是无法再推导的，如果当前推导状态到一个终结符但是和输入的符号不匹配，就会报错，而非终结符可以通过它的推导再去找匹配，也可以非终结符推导出 ε 来取出下一个符号，举例如下 LC是终结符 ‘}’ ，而BLOCK是非终结符，它的推导公式是BLOCK-&gt;LC STMTS RC，语义是一个块可以推出 { 多条语句 } 的模式 ：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 :栈顶-&gt; BLOCK  + 输入-&gt; LC                           推导公式：BLOCK-&gt;LC STMTS RC</span><br><span class="line">1 :栈顶-&gt; LC  + 输入-&gt; LC   </span><br></pre></td></tr></table></figure>
<ul>
<li><p>非终结符举例：</p>
<ul>
<li>factor：不能被运算符分割的表达式，如：(8+9)*2，这里8+9就是一个factor，后面的乘号对它的计算并无影响</li>
<li>term：可以被乘除分割，不可以被加减分割</li>
<li>expr：被任意运算符分割</li>
</ul>
</li>
<li><p>LL1文法：第一个L 代表 从左到右扫描输入， 第二个L代表产生最左推导，1表示每一步前看1，这个文法的优点是在构造预测时候比较简单，适合手工编码，一些专业编译器可以实现LL-K的递归下降，我自己的体会缺点大概有以下几个：</p>
<ul>
<li>无法实现比较复杂的文法，当你想增加语义的时候可能会出现其他的冲突</li>
<li>需要改写左递归的文法，提取左公因子，这一点可以手动实现</li>
<li>语义分析的时候可能会比较复杂，因为这个LL是一个递归下降的过程，而且部分改写过语义与直观不符</li>
</ul>
</li>
<li><p>句型与句子</p>
<ul>
<li>句型：一个文法G由开始符号推出的 不限定类型(终结或非终结或空串或组合)</li>
<li>句子：推出的限定类型 终结or空串</li>
</ul>
</li>
<li><p>最左匹配会出现语法的二义性，如悬空else： if E1 then if E2 then S1 else S2，需要对文法进行改写</p>
<ul>
<li>if E1 then (if E2 then S1) else S2</li>
<li>if E1 then (if E2 then S1 else S2)</li>
<li>解决方法：最近匹配原则=&gt; if E1 then (如果是这种形式这里必须是一个完整的 if-else语句,不可以单独出现 if then)) else S2</li>
<li>stmt -&gt; matched_stmt | open_stmt</li>
<li>优先一起吃掉最近的if和else如果有的话：matched_stmt -&gt; if expr then matched_stmt else mathed_stmt | other</li>
<li>open_stmt -&gt; if expr then stmt | if expr then matched_stmt else open_stmt</li>
</ul>
</li>
<li><p>预测表：这是语法分析第一部分的核心，栈+预测表实现了一个很有意思的基于上下文无关文法的解析</p>
</li>
<li><p>语法分析：基于语法制导翻译。如果仔细看解析过程以及抽象语法树，可以看出栈的弹出是一个基于树的”后序遍历”的过程，基于这个顺序过程可以实现符号表以及部分静态检查，剩下的检查可以使用递归下降配合实现，在这个栈+递归下降的过程中大概有：</p>
<ul>
<li>检查变量以及推导公式是否匹配</li>
<li>符号表</li>
<li>静态检查是否定义</li>
<li>类型匹配</li>
<li>部分代码生成以及desugar 等</li>
</ul>
</li>
<li><p>符号表：符号表也是向后续其他模块(可以与语法分析形成一个不动点循环)提供帮助的，比如解析时遇到一个变量就去符号表查该变量有没有在符号表注册，作用域是什么等等。lombok也是基于这种原理</p>
</li>
<li><p>语义分析在我看来是一个糅合层，编译器在我们能理解的语法和实际语法之间加上了一个中间层范式–上下文无关文法，而语义分析比语法分析更像是连接不同语法之间转换器，由于这个步骤可以基于抽象语法树进行，所以它相对独立可扩展性强，这也就意味着很复杂，基于我们的”初心”，这个部分决定忽略掉如变量作用域，也就是默认全局变量，目前只实现如下两个功能：</p>
<ul>
<li>变量声明检查：利用符号表实现</li>
<li>表达式类型检查</li>
</ul>
</li>
<li><p>静态检查：</p>
<ul>
<li>表达式检查</li>
<li>类型检查 if(boolean flag)， if(a.type == b.type)</li>
<li>其他检查</li>
</ul>
</li>
</ul>
<h3 id="e-g-后缀表达式"><a href="#e-g-后缀表达式" class="headerlink" title="e.g:后缀表达式"></a>e.g:后缀表达式</h3><p>这里有个后缀表达式示例，在消除左递归的时候，单独的term要放在最后，避免出现9-5+2 =&gt; 952-+这种错误的翻译，有兴趣可以看下实现，也可以跳过，只是介绍内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 后缀表达式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zfeiyu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParserPostfix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] source = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParserPostfix</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParserPostfix</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = s.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        term();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( source[index] == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                match(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">                term();</span><br><span class="line">                System.out.println(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(source[index] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                match(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">                term();</span><br><span class="line">                System.out.println(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">term</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Character.isDigit((<span class="keyword">char</span>)source[index]))&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)source[index]);</span><br><span class="line">            match(source[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(source[index] == t)&#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Postfix</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            ParserPostfix p = <span class="keyword">new</span> ParserPostfix(<span class="string">&quot;9+5-2 &quot;</span>);</span><br><span class="line">            p.expr();</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>结尾附以前做的结构图一张，事实上Java写编译器前端并不是一个好选择</p>
<p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/%E7%BC%96%E8%AF%91%E5%99%A8/%E6%B5%81%E7%A8%8B%E5%9B%BE%20(3).jpg" alt="结构图"></p>
]]></content>
      <tags>
        <tag>编译</tag>
        <tag>文法</tag>
      </tags>
  </entry>
  <entry>
    <title>语法分析和二义性检测-Java实现</title>
    <url>/2021/01/12/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E4%BA%8C%E4%B9%89%E6%80%A7%E6%A3%80%E6%B5%8B-Java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>全文包括编译器前端语法分析部分的Java实践，包括First、Follow、Select集的构造、LL1文法、左递归的检测以及文法二义性的检测，可以参考<a href="https://feiyuzhan.github.io/2021/01/12/%E7%BC%96%E8%AF%91%E5%99%A8%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D/#more">相关名词</a></p>
 <a id="more"></a>

<ul>
<li><p>在开始语法分析之前，想说一下上一次准备编译器前端难产的过程，因为在写到语法分析的时候构思的是递归下降的分析，但是在构建stmt、expr后在递归中要处理文法推导以及回溯越写下去越有些难以为继，这次在动笔之前特意把华保健老师的编译原理以及龙书的语法分析部分找自己感兴趣的部分看了一下，LL(1)是一个适合手工构造的文法，LL(1)从总体上看是一种分治将target缩小为单个非终结符的解析组合+前看1位解决回溯(需要First集和Follow集配合)</p>
</li>
<li><p>FIRST FOLLOW SElECT(对应华保健老师的FIRST_S)集合，这里看到一个解释的比较清晰明了的 – (摘自百度知道的回答作者袭人西)：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先要明白这三个集的作用和用途，知道了他们是用来做什么的之后，理解起来就简单一些</span><br><span class="line">First（A）集的作用是标示在替换非终结符A的时候，替换后的文法的首字母集合，语法分析程序根据这个来判断给定的语言是否是合法的，是符合规则的。</span><br><span class="line">Follow（A）的作用是标示那些可以出现在A之后的字符，语法分析程序根据这个，在A可以被替换为e（空）的时候来进行判断，看当前的文法是否是合法的。</span><br><span class="line">这里简单说明下，比如A-&gt;b,A-&gt;e(空) 当给定的语言是 bXXXXX的时候，根据第一句文法就可以判定句子合法，但是如果给的语言是cXXXXX的时候，因为A-&gt;可以替换为空，这时候就需要一句A的follow集来进行判断，若A的follow集里面含有c 则语言是合法的</span><br><span class="line">Select集的作用是将first集和follow集进行合并，如果两个文法的左端都是A，若他们的select集交集为空，表明他们是两个无关的，不会产生不确定性的文法，反之，则表明文法不是LL(1)文法</span><br></pre></td></tr></table></figure>
<ul>
<li>简单说下LL(1):即从左向右最左推导前看1，主要需要解决的问题：<ul>
<li>每个非终结符写一个分析函数Parse_None_T,分治到底部需要依赖这些分析函数确定是否匹配，大概思路如下：<ul>
<li>token = tokens[ i++ ]</li>
<li>函数体内终结符匹配则eat(index++)这个token，否则error</li>
</ul>
</li>
<li>消除左递归(否则无法从左到右递归)</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>按照上面的思路有三个基本步骤：</li>
</ul>
<ol>
<li>非终结符的Parse函数</li>
<li>First集伪代码：一个FIRST(终结符a) = {a} , 而FIRST(非终结符N)的伪代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">foreach( nonterminal N)&#123;</span><br><span class="line">    FIRST(N) = &#123; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(其中一个set的大小发生变化)&#123;</span><br><span class="line">    foreach( 产生式 p: N-&gt; β<span class="number">1</span> β<span class="number">2</span> β<span class="number">3.</span>..βn )&#123;</span><br><span class="line">        <span class="comment">//从左至右依次考虑NULLABLE带来的冲突</span></span><br><span class="line">        foreach(β<span class="number">1</span> to βn)&#123;</span><br><span class="line">            <span class="keyword">if</span>(β<span class="number">1</span> == 终结符a)&#123;</span><br><span class="line">                FIRST(N).add(a);</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(β<span class="number">1</span> == 非终结符M)&#123;</span><br><span class="line">                FIRST(N).addAll(FIRST(M));</span><br><span class="line">                <span class="comment">//如果M可以为空，继续下一个β2</span></span><br><span class="line">                <span class="keyword">if</span>( M not in NULLABLE)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Follow集伪代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">foreach( nonterminal N)&#123;</span><br><span class="line">    FIRST(N) = &#123; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(其中一个set的大小发生变化)&#123;</span><br><span class="line">    foreach( 产生式 p: N-&gt; β<span class="number">1</span> β<span class="number">2</span> β<span class="number">3.</span>..βn )&#123;</span><br><span class="line">        tmp = FOLLOW(N);</span><br><span class="line">        foreach(βn to β<span class="number">1</span>)&#123; <span class="comment">//逆序！</span></span><br><span class="line">            <span class="keyword">if</span>(βi == 终结符a)&#123;</span><br><span class="line">                tmp = &#123;a&#125;<span class="comment">//a跟在tmp后面</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(βi == 非终结符M)&#123;</span><br><span class="line">                FOLLOW(M).add(tmp);</span><br><span class="line">                <span class="comment">//如果M可以为空，继续下一个β2</span></span><br><span class="line">                <span class="keyword">if</span>( M not in NULLABLE)&#123;</span><br><span class="line">                    tmp = FIRST(M);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tmp.addAll(FIRST(M));<span class="comment">//可以为空则可以穿过FIRST集到达tmp</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>产生式First_S集伪代码：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foreach( nonterminal p)&#123;</span><br><span class="line">    First_S(p) &#x3D; &#123; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">calculte_FIRST_S(产生式 p:  N-&gt; β1 β2 β3...βn )&#123;</span><br><span class="line">        foreach(β1 to βn)&#123;</span><br><span class="line">            if(βi &#x3D;&#x3D; 终结符a)&#123;</span><br><span class="line">                FIRST_S(p).add(a);</span><br><span class="line">                return ;</span><br><span class="line">            &#125;else if(βi  &#x3D;&#x3D; 非终结符M)&#123;</span><br><span class="line">                FIRST_S(p).addAll(FIRST(M));</span><br><span class="line">                if( M not in NULLABLE)&#123;</span><br><span class="line">                    return ;</span><br><span class="line">                &#125;</span><br><span class="line">                continue to β(i+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       &#x2F;&#x2F;如果遍历到βn还没return，意味着N的跟随也需要加在FIRST_S(p)里</span><br><span class="line">        FIRST_S(p).addAll(FOLLOW(N));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>LL1伪代码：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tokens[];</span><br><span class="line">index &#x3D; 0;</span><br><span class="line">stack  s;</span><br><span class="line">while(s not empty)&#123;</span><br><span class="line">    if(s[peek] &#x3D;&#x3D; 终结符t)&#123;</span><br><span class="line">        if(t &#x3D;&#x3D; tokens[index++])&#123;</span><br><span class="line">            pop();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if(s[peek] &#x3D;&#x3D; 非终结符 T)&#123;</span><br><span class="line">        pop();</span><br><span class="line">        push( table[T , tokens[i]]);&#x2F;&#x2F;表驱动，逆序压栈</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>冲突处理：<br> 可以采用消除左递归的方法，作为一个简化版，还有一种最简单的处理是从文法定义层面去除冲突，也就是不存在前看一个符号出现2个以及以上的匹配</li>
</ol>
<ul>
<li>消除左递归<ul>
<li>对于一个文法： E-&gt; E + T | T</li>
<li>E可以展开为 E+T =&gt; (E+T)+T = &gt; (E+T)+T+T =&gt; T+T+T+…+T</li>
<li>用另一个符号 E’ 扩展 +T 的形式， 可以得到如下：</li>
<li>E+T 等价于 T+T+T+…+T 等价于 T (+T)* (这里+T可以为0次) 等价于 T + T E’| ε</li>
<li>E = TE’ ， E’ = +T E’ | ε</li>
<li>这样做的用意是将终结符提前，避免在左递归下降的时候靠前的E陷入自循环</li>
</ul>
</li>
</ul>
<h3 id="OK-LET’S-START"><a href="#OK-LET’S-START" class="headerlink" title="OK LET’S START"></a>OK LET’S START</h3><p>第一步 ：给定一个文法，然后构建自动化的第一个部分First集合</p>
<p>部分文法示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">program(单个Main函数)  → block</span><br><span class="line"></span><br><span class="line">block   →   &#123; stmts &#125;</span><br><span class="line"></span><br><span class="line">stmts   →　stmt stmts | ε</span><br><span class="line"></span><br><span class="line">stmt    →   id&#x3D; exp ;</span><br><span class="line">        </span><br><span class="line">        | type id ;</span><br><span class="line"></span><br><span class="line">        | type id &#x3D; exp ; </span><br><span class="line"></span><br><span class="line">        |  if ( bool ) stmt</span><br><span class="line"></span><br><span class="line">        |  if ( bool) stmt else_if stmt else stmt</span><br><span class="line"></span><br><span class="line">        |  if ( bool) stmt else stmt</span><br><span class="line"></span><br><span class="line">        | for(exp ; bool_exp ; exp)  block</span><br><span class="line"></span><br><span class="line">        |  while (bool_exp) stmt</span><br><span class="line"></span><br><span class="line">        |  do stmt while (bool_exp ) ;</span><br><span class="line"></span><br><span class="line">        |  break ;</span><br><span class="line"></span><br><span class="line">        |  continue ;</span><br><span class="line"></span><br><span class="line">        |  return exp ;</span><br><span class="line"></span><br><span class="line">        |  System.out.println(exp);</span><br><span class="line"></span><br><span class="line">        |  block</span><br><span class="line"></span><br><span class="line">bool_exp    →     exp &lt; exp</span><br><span class="line"></span><br><span class="line">            |     exp &lt;&#x3D; exp</span><br><span class="line"></span><br><span class="line">            |     exp &gt; exp</span><br><span class="line"></span><br><span class="line">            |     exp &gt;&#x3D; exp</span><br><span class="line"></span><br><span class="line">            |     exp &#x3D;&#x3D; exp</span><br><span class="line"></span><br><span class="line">            |     exp !&#x3D; exp</span><br><span class="line"></span><br><span class="line">exp    →     exp + term</span><br><span class="line"></span><br><span class="line">        |     exp - term</span><br><span class="line"></span><br><span class="line">        |     term</span><br><span class="line"></span><br><span class="line">term    →    term * factor</span><br><span class="line"></span><br><span class="line">        |     term &#x2F; factor</span><br><span class="line"></span><br><span class="line">        |     factor</span><br><span class="line"></span><br><span class="line">factor     → ( exp ) | id| number</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<hr>
<p>基于文法的部分左侧定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static enum type&#123;</span><br><span class="line">    &#x2F;&#x2F;程序 &#x3D;&gt; 语句 &#x3D;&gt; 方法 &#x3D;&gt; 表达式 &#x3D;&gt; 因子</span><br><span class="line"></span><br><span class="line">    PROGRAM, STMTS , STMT ,  BLOCK, </span><br><span class="line">    </span><br><span class="line">    IF, ELSE, ELSE_IF, WHILE, FOR, DO, CONTINUE, BREAK, RETURN, PRINT,</span><br><span class="line"></span><br><span class="line">    EXP, EXP_DEFINE,  EXP_BOOL , EXP_ASSGIN,  RELOP,</span><br><span class="line">    </span><br><span class="line">    TERM , FACTOR, ID, NUMBER, OPRATOR,</span><br><span class="line">    </span><br><span class="line">    INT, STRING, BOOLEAN, CHAR, NULL,</span><br><span class="line"></span><br><span class="line">    GOTO, </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>First集示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> compiler.parser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> compiler.exception.ParserException;</span><br><span class="line"><span class="keyword">import</span> compiler.lexer.Token;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 文法以及相关集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zfeiyu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Grammar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">Gtype</span></span>&#123;</span><br><span class="line">        <span class="comment">//程序 =&gt; 语句 =&gt; 方法 =&gt; 表达式 =&gt; 因子</span></span><br><span class="line"></span><br><span class="line">        PROGRAM, STMTS , STMT ,  BLOCK,</span><br><span class="line"></span><br><span class="line">        IF, ELSE, ELSE_IF, WHILE, FOR, DO, CONTINUE, BREAK, RETURN, PRINT,</span><br><span class="line"></span><br><span class="line">        EXP,  EXP_BOOL , EXP_ASSGIN,  RELOP,</span><br><span class="line">                                     <span class="comment">// + -     * /</span></span><br><span class="line">        TERM , FACTOR, ID, NUMBER, OPRATOR1, OPRATOR2,</span><br><span class="line"></span><br><span class="line">        TYPE, INT, STRING, BOOLEAN, CHAR, NULL,</span><br><span class="line"></span><br><span class="line">        GOTO,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  key =&gt; val1 val2 | val3 | null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;String,String&gt; grammar = <span class="keyword">new</span> HashMap&lt;&gt;()&#123;&#123;</span><br><span class="line">            put(<span class="string">&quot;PROGRAM&quot;</span>,<span class="string">&quot;BLOCK&quot;</span>);</span><br><span class="line">            put(<span class="string">&quot;BLOCK&quot;</span>,<span class="string">&quot;LC STMTS RC&quot;</span>);</span><br><span class="line">            put(<span class="string">&quot;STMTS&quot;</span>,<span class="string">&quot;STMT STMTS|NULL&quot;</span>);</span><br><span class="line">            put(<span class="string">&quot;STMT&quot;</span>,<span class="string">&quot;ID EQUAL EXP SEMI|&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;TYPE ID SEMI|&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;TYPE ID EQUAL EXP SEMI|&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;IF LP EXP_BOOL RP BLOCK|&quot;</span> +</span><br><span class="line"><span class="comment">//                    &quot;IF LP EXP_BOOL RP BLOCK ELSE_IF LP EXP_BOOL RP BLOCK|&quot; +</span></span><br><span class="line">                    <span class="string">&quot;ELSE BLOCK|&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;FOR LP EXP SEMI EXP_BOOL SEMI EXP RP BLOCK|&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;WHILE LP EXP_BOOL RP BLOCK|&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;BREAK SEMI|&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;CONTINUE SEMI|&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;RETURN EXP SEMI|&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;PRINT LR EXP RP|&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;BLOCK|&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;SEMI&quot;</span>);</span><br><span class="line">            put(<span class="string">&quot;EXP_BOOL&quot;</span>,<span class="string">&quot;EXP RELOP EXP&quot;</span>);</span><br><span class="line">            put(<span class="string">&quot;EXP&quot;</span>,<span class="string">&quot;EXP OPRATOR1 TERM|&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;TERM&quot;</span>);</span><br><span class="line">            put(<span class="string">&quot;TERM&quot;</span>,<span class="string">&quot;TERM OPRATOR2 FACTOR|&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;FACTOR&quot;</span>);</span><br><span class="line">            put(<span class="string">&quot;FACTOR&quot;</span>,<span class="string">&quot;ID|NUMBER|LP EXP RP&quot;</span>);</span><br><span class="line">            put(<span class="string">&quot;TYPE&quot;</span>,<span class="string">&quot;INT|STRING|BOOLEAN&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  终结符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     Set&lt;String&gt; terminalSet = <span class="keyword">new</span> HashSet&lt;&gt;()&#123;&#123;</span><br><span class="line">        add(Token.Type.ID.toString()); add(Token.Type.KEYWORD.toString()); add(Token.Type.RELOP.toString());</span><br><span class="line">        add(Token.Type.AND.toString());</span><br><span class="line">        add(Token.Type.OR.toString());</span><br><span class="line">        add(Token.Type.PLUS.toString());</span><br><span class="line">        add(Token.Type.LP.toString());</span><br><span class="line">        add(Token.Type.RP.toString());</span><br><span class="line">        add(Token.Type.LB.toString());</span><br><span class="line">        add(Token.Type.RB.toString());</span><br><span class="line">        add(Token.Type.LC.toString());</span><br><span class="line">        add(Token.Type.RC.toString());</span><br><span class="line">        add(Token.Type.COLON.toString());</span><br><span class="line">        add(Token.Type.PE.toString());</span><br><span class="line">        add(Token.Type.ME.toString());</span><br><span class="line">        add(Token.Type.SE.toString());</span><br><span class="line">        add(Token.Type.DE.toString());</span><br><span class="line">        add(Token.Type.DIVOP.toString());</span><br><span class="line">        add(Token.Type.REMAINDER.toString());</span><br><span class="line">        add(Token.Type.MINUS.toString());</span><br><span class="line">        add(Token.Type.INCOP.toString());</span><br><span class="line">        add(Token.Type.DECOP.toString());</span><br><span class="line">        add(Token.Type.POINT.toString());</span><br><span class="line">        add(Token.Type.SEMI.toString());</span><br><span class="line">        add(Token.Type.COMMA.toString());</span><br><span class="line">        add(Token.Type.EQUAL.toString());</span><br><span class="line">        add(Token.Type.STAR.toString());</span><br><span class="line">        add(<span class="string">&quot;INT&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;STRING&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;BOOLEAN&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;ID&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;NUMBER&quot;</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Set&lt;String&gt;&gt; firstSetMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; nullableSet = <span class="keyword">new</span> HashSet&lt;&gt;()&#123;&#123;</span><br><span class="line">        add(<span class="string">&quot;STMTS&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;EXP_P&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;FACTOR_P&quot;</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    Map&lt;String,Set&lt;String&gt;&gt; followSetMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAllFirstSetSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String key: firstSetMap.keySet()) &#123;</span><br><span class="line">            size += firstSetMap.get(key).size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeFirstSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//init</span></span><br><span class="line">        <span class="keyword">for</span> (String name:words) &#123;</span><br><span class="line">            <span class="keyword">if</span>(terminalSet.contains(name))&#123;</span><br><span class="line">                firstSetMap.put(name,<span class="keyword">new</span> HashSet&lt;&gt;()&#123;&#123;add(name); &#125;&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                firstSetMap.put(name,<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lastSize = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> curSize = getAllFirstSetSize();</span><br><span class="line">        <span class="keyword">while</span> (lastSize != curSize)&#123;</span><br><span class="line">            lastSize = curSize;</span><br><span class="line">            <span class="keyword">for</span> (String name: words) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!terminalSet.contains(name))&#123;</span><br><span class="line">                    doMakeFirstSet(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            curSize = getAllFirstSetSize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doMakeFirstSet</span><span class="params">(String gtype)</span></span>&#123;</span><br><span class="line">        <span class="comment">//终结符</span></span><br><span class="line">        String productions = grammar.get(gtype);</span><br><span class="line">        <span class="keyword">if</span>(productions == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里 | 要转义</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String[] pros = productions.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; firstSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * set的和的大小不发生变化则stop</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pros.length; i++) &#123;</span><br><span class="line">                String cur = pros[i].trim();</span><br><span class="line">                <span class="keyword">if</span>(cur.equals(gtype))&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String[] cutBySpace = cur.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cutBySpace.length; j++) &#123;</span><br><span class="line">                    String str = cutBySpace[j];</span><br><span class="line">                    <span class="keyword">if</span> (terminalSet.contains(str))&#123;</span><br><span class="line">                        firstSet.add(str);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//非终结符</span></span><br><span class="line">                        <span class="keyword">if</span>(str.equals(gtype))&#123;</span><br><span class="line">                            <span class="comment">//不能递归调用自身</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!firstSetMap.isEmpty() &amp;&amp; firstSetMap.get(str) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                            firstSet.addAll(firstSetMap.get(str));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!nullableSet.contains(str))&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            firstSetMap.put(gtype,firstSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="文法的问题"><a href="#文法的问题" class="headerlink" title="文法的问题"></a>文法的问题</h3><p>这里看到已经构建出了一个简单的First集，但是要注意到上面的文法并不是LL1文法，没有消除左递归，简单起见直接来改写一下文法EXP和TERM即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;            put(&quot;EXP&quot;,&quot;EXP OPRATOR1 TERM|&quot; +</span><br><span class="line">&#x2F;&#x2F;                    &quot;TERM&quot;);改写成LL1文法</span><br><span class="line"></span><br><span class="line">            put(&quot;EXP&quot;,&quot;TERM EXP_P&quot; );</span><br><span class="line">            put(&quot;EXP_P&quot;,&quot;OPRATOR1 TERM EXP_P|NULL&quot; );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;            put(&quot;TERM&quot;,&quot;TERM OPRATOR2 FACTOR|&quot; +</span><br><span class="line">&#x2F;&#x2F;                    &quot;FACTOR&quot;);改写成LL1文法</span><br><span class="line"></span><br><span class="line">            put(&quot;TERM&quot;,&quot;FACTOR TERM_P&quot; );</span><br><span class="line">            put(&quot;TERM_P&quot;,&quot;OPRATOR2 FACTOR TERM_P|NULL&quot; );</span><br></pre></td></tr></table></figure>
<p>代码输入如下，可以参照文法定义理解下FOLLOW集的意义:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DE 的First集-&gt;[DE]</span><br><span class="line">LP 的First集-&gt;[LP]</span><br><span class="line">SEMI 的First集-&gt;[SEMI]</span><br><span class="line">KEYWORD 的First集-&gt;[KEYWORD]</span><br><span class="line">TERM 的First集-&gt;[NUMBER, LP, ID]</span><br><span class="line">INT 的First集-&gt;[INT]</span><br><span class="line">MINUS 的First集-&gt;[MINUS]</span><br><span class="line">SE 的First集-&gt;[SE]</span><br><span class="line">ME 的First集-&gt;[ME]</span><br><span class="line">ID 的First集-&gt;[ID]</span><br><span class="line">DECOP 的First集-&gt;[DECOP]</span><br><span class="line">TYPE 的First集-&gt;[STRING, INT, BOOLEAN]</span><br><span class="line">EXP_BOOL 的First集-&gt;[NUMBER, LP, ID]</span><br><span class="line">COMMA 的First集-&gt;[COMMA]</span><br><span class="line">NUMBER 的First集-&gt;[NUMBER]</span><br><span class="line">OR 的First集-&gt;[OR]</span><br><span class="line">EQUAL 的First集-&gt;[EQUAL]</span><br><span class="line">BLOCK 的First集-&gt;[LC]</span><br><span class="line">FACTOR 的First集-&gt;[NUMBER, LP, ID]</span><br><span class="line">COLON 的First集-&gt;[COLON]</span><br><span class="line">STMT 的First集-&gt;[PRINT, FOR, SEMI, INT, BOOLEAN, CONTINUE, RETURN, BREAK, LC, STRING, ELSE, WHILE, ID, IF]</span><br><span class="line">BOOLEAN 的First集-&gt;[BOOLEAN]</span><br><span class="line">RB 的First集-&gt;[RB]</span><br><span class="line">RC 的First集-&gt;[RC]</span><br><span class="line">DIVOP 的First集-&gt;[DIVOP]</span><br><span class="line">OPRATOR1 的First集-&gt;[OPRATOR1]</span><br><span class="line">STMTS 的First集-&gt;[PRINT, FOR, SEMI, INT, BOOLEAN, CONTINUE, RETURN, BREAK, LC, STRING, ELSE, WHILE, ID, IF]</span><br><span class="line">OPRATOR2 的First集-&gt;[OPRATOR2]</span><br><span class="line">STAR 的First集-&gt;[STAR]</span><br><span class="line">TERM_P 的First集-&gt;[OPRATOR2]</span><br><span class="line">PE 的First集-&gt;[PE]</span><br><span class="line">REMAINDER 的First集-&gt;[REMAINDER]</span><br><span class="line">LB 的First集-&gt;[LB]</span><br><span class="line">INCOP 的First集-&gt;[INCOP]</span><br><span class="line">AND 的First集-&gt;[AND]</span><br><span class="line">LC 的First集-&gt;[LC]</span><br><span class="line">STRING 的First集-&gt;[STRING]</span><br><span class="line">EXP_P 的First集-&gt;[OPRATOR1]</span><br><span class="line">POINT 的First集-&gt;[POINT]</span><br><span class="line">EXP 的First集-&gt;[NUMBER, LP, ID]</span><br><span class="line">RELOP 的First集-&gt;[RELOP]</span><br><span class="line">RP 的First集-&gt;[RP]</span><br><span class="line">PROGRAM 的First集-&gt;[LC]</span><br><span class="line">PLUS 的First集-&gt;[PLUS]</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<hr>
<p>FOLLOW集合</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initFollowSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//给每一个非终结符创建一个空Set</span></span><br><span class="line">    <span class="keyword">for</span> (String str : words)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!terminalSet.contains(str))&#123;</span><br><span class="line">            followSetMap.put(str,<span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAllFollowSetSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String key: followSetMap.keySet()) &#123;</span><br><span class="line">        size += followSetMap.get(key).size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  在计算FOLLOW集空指针时注意检查文法定义和终结符定义</span></span><br><span class="line"><span class="comment"> *  出现未定义Set的非终结符则会报错</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeFollowSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//遍历左侧</span></span><br><span class="line">    <span class="keyword">int</span> last = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (last != getAllFollowSetSize())&#123;</span><br><span class="line">        last = getAllFollowSetSize();</span><br><span class="line">        <span class="keyword">for</span> (String left : grammar.keySet())&#123;</span><br><span class="line">            String productions = grammar.get(left);</span><br><span class="line"></span><br><span class="line">            System.out.println(left + <span class="string">&quot; -&gt; &quot;</span>+productions);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(productions == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] pros = productions.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pros.length; i++) &#123;</span><br><span class="line">                <span class="comment">//对每个产生式逆序遍历</span></span><br><span class="line">                <span class="keyword">if</span>(pros[i].equals(<span class="string">&quot;NULL&quot;</span>))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Set&lt;String&gt; tmp = followSetMap.get(left);</span><br><span class="line">                String[] eachPro = pros[i].split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = eachPro.length-<span class="number">1</span>; j &gt;=<span class="number">0</span> ; j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(eachPro[j].equals(left))&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(terminalSet.contains(eachPro[j]))&#123;</span><br><span class="line">                        <span class="comment">//终结符j会使得前面的非终结符无法get到j+1位置的FOLLOW集</span></span><br><span class="line">                        <span class="keyword">int</span> copyj = j;</span><br><span class="line">                        tmp = <span class="keyword">new</span> HashSet&lt;String&gt;()&#123;&#123;add(eachPro[copyj]);&#125;&#125;;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(eachPro[j] + <span class="string">&quot; === &quot;</span>+ left);</span><br><span class="line">                        <span class="comment">//加入前一个的FOLLOW集</span></span><br><span class="line">                        Set&lt;String&gt; notTerminlaSet = followSetMap.get(eachPro[j]);</span><br><span class="line">                        notTerminlaSet.addAll(tmp);</span><br><span class="line">                        followSetMap.put(eachPro[j],notTerminlaSet);</span><br><span class="line">                        <span class="comment">//计算下一个tmp</span></span><br><span class="line">                        <span class="keyword">if</span>(!nullableSet.contains(eachPro[j]))&#123;</span><br><span class="line">                            tmp = firstSetMap.get(eachPro[j]);</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            tmp.addAll(firstSetMap.get(eachPro[j]));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NUMBER 的FOLLOW集 -&gt; [OPRATOR1, OPRATOR2, SEMI, RP, RELOP]</span><br><span class="line">STMTS 的FOLLOW集 -&gt; [RC]</span><br><span class="line">TERM_P 的FOLLOW集 -&gt; [OPRATOR1, SEMI, RP, RELOP]</span><br><span class="line">BLOCK 的FOLLOW集 -&gt; [RC]</span><br><span class="line">FACTOR 的FOLLOW集 -&gt; [OPRATOR1, OPRATOR2, SEMI, RP, RELOP]</span><br><span class="line">TERM 的FOLLOW集 -&gt; [OPRATOR1, SEMI, RP, RELOP]</span><br><span class="line">EXP_P 的FOLLOW集 -&gt; [OPRATOR1, SEMI, RP, RELOP]</span><br><span class="line">EXP 的FOLLOW集 -&gt; [OPRATOR1, SEMI, RP, RELOP]</span><br><span class="line">TYPE 的FOLLOW集 -&gt; [ID]</span><br><span class="line">STMT 的FOLLOW集 -&gt; [RC]</span><br><span class="line">PROGRAM 的FOLLOW集 -&gt; []</span><br><span class="line">EXP_BOOL 的FOLLOW集 -&gt; [SEMI, RP]</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<hr>
<p>SELECT集：观察了以目前的文法跟First集没多大区别，但是考虑后期会添加文法，可以自动生成，扩展性不错</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initSelectSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String str : words)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!terminalSet.contains(str))&#123;</span><br><span class="line">            selectSetMap.put(str,<span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            selectSetMap.put(str,<span class="keyword">new</span> HashSet&lt;String&gt;()&#123;&#123; add(str);&#125;&#125; );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSelectSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    initSelectSet();</span><br><span class="line">    <span class="keyword">for</span> (String name:selectSetMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(terminalSet.contains(name))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String productions = grammar.get(name);</span><br><span class="line">        <span class="keyword">if</span>(productions == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] pros = productions.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; selectSet = selectSetMap.get(name);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pros.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pros[i].equals(<span class="string">&quot;NULL&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] eachPro = pros[i].split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; eachPro.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(terminalSet.contains(eachPro[j]))&#123;</span><br><span class="line">                    selectSet.add(eachPro[j]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    selectSet.addAll(firstSetMap.get(eachPro[j]));</span><br><span class="line">                    <span class="keyword">if</span>(!nullableSet.contains(eachPro[j]))&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        selectSetMap.put(name,selectSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>语法制导翻译：<br>现在有了select表，可以简单回答语法yes or no，但是要想翻译，至少还需要两个条件</p>
<ul>
<li><p>接受下一个终结符a是走了哪条推导规则</p>
</li>
<li><p>这条推导规则的语义是什么，是需要记录哪些值，这是一个赋值语句还是define语句</p>
</li>
<li><p>语法分析在递归下降时其实对我而言是有两种选择的，一种是不停递归，然后在每个递归解析中手动实现语法和语义的解析。第二种较上一种机械化一点，采用First集合、FOLLOW集、预测表回答跳转yes or no，再用执行栈和语义栈来实现语法和语义的解析，这里面的语义需要自己定义。</p>
</li>
<li><p>对于文法定义简单(大部分实现的语义都满足这点)的编译器采用第一种更简单直接，第二章则扩展性更好(虽然并不太可能会扩展)</p>
</li>
<li><p>预测表：这是语法分析第一部分的核心，栈+预测表实现了一个很有意思的基于上下文无关文法的解析</p>
</li>
<li><p>语法分析：基于语法制导翻译。如果仔细看解析过程以及抽象语法树，可以看出栈的弹出是一个基于树的”后序遍历”的过程，基于这个顺序过程可以实现符号表以及部分静态检查，剩下的检查可以使用递归下降配合实现，在这个栈+递归下降的过程中大概有：</p>
<ul>
<li>检查变量以及推导公式是否匹配</li>
<li>符号表</li>
<li>静态检查是否定义</li>
<li>类型匹配</li>
<li>部分代码生成以及desugar 等</li>
</ul>
</li>
</ul>
<hr>
<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>测试一段代码的语法分析，发现文法定义有问题</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initParse</span><span class="params">(List&lt;Token&gt; inputTokens)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取到Token流：&quot;</span>+inputTokens.toString());</span><br><span class="line">        inputTokens.add(<span class="keyword">new</span> Token(Token.Type.END,<span class="string">&quot;NULL&quot;</span>));</span><br><span class="line">        inputTokens.add(<span class="keyword">new</span> Token());</span><br><span class="line">        tokens = inputTokens.toArray(Token[]::<span class="keyword">new</span>);</span><br><span class="line">        executeStack.push(<span class="string">&quot;PARSER_END&quot;</span>);</span><br><span class="line">        executeStack.push(<span class="string">&quot;BLOCK&quot;</span>);</span><br><span class="line">        len = tokens.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminal</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gram.terminalSet.contains(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkBeforeParser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        String nextToken =read();</span><br><span class="line">        <span class="keyword">while</span> (!executeStack.peek().equals(<span class="string">&quot;PARSER_END&quot;</span>) )&#123;</span><br><span class="line">            System.out.print(cnt+<span class="string">&quot; :&quot;</span>);</span><br><span class="line">            cnt++;</span><br><span class="line">            String top = executeStack.peek();</span><br><span class="line">            <span class="comment">//如果select集查看是否合法，predict来打印推导公式</span></span><br><span class="line">            System.out.println(<span class="string">&quot;栈顶-&gt; &quot;</span>+ top+<span class="string">&quot;  + 输入-&gt; &quot;</span>+nextToken);</span><br><span class="line">            <span class="keyword">if</span>(isTerminal(top))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!nextToken.equals(top))&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ParserException(<span class="string">&quot;期望一个&quot;</span>+top+<span class="string">&quot;,实际为&quot;</span>+nextToken);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;  &quot;</span>+ top+<span class="string">&quot;-&gt;&quot;</span>+nextToken);</span><br><span class="line">                nextToken =read();</span><br><span class="line">                executeStack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!gram.predict.containsKey(top+<span class="string">&quot;@&quot;</span>+nextToken))&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ParserException(<span class="string">&quot;无法从 &quot;</span>+top+<span class="string">&quot; 推导出 &quot;</span> +nextToken +<span class="string">&quot;请检查输入....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                String production = gram.predict.get(top+<span class="string">&quot;@&quot;</span>+nextToken);</span><br><span class="line">                System.out.println(<span class="string">&quot;  &quot;</span>+production);</span><br><span class="line">                executeStack.pop();</span><br><span class="line">                <span class="keyword">if</span>(production.indexOf(<span class="string">&quot;&gt;&quot;</span>) == -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String[] toStack = (production.substring(production.indexOf(<span class="string">&quot;&gt;&quot;</span>)+<span class="number">1</span>)).split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="comment">//BLOCK-&gt;LC STMTS RC只截取STMTS RC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//                System.out.println(Arrays.toString(toStack));</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = toStack.length-<span class="number">1</span>; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">                    executeStack.push(toStack[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;语法分析结束.....&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取到Token流：[Token&#123;type&#x3D;LC, content&#x3D;&#39;&#123;&#39;&#125;, Token&#123;type&#x3D;INT, content&#x3D;&#39;int&#39;&#125;, Token&#123;type&#x3D;ID, content&#x3D;&#39;a&#39;&#125;, Token&#123;type&#x3D;EQUAL, content&#x3D;&#39;&#x3D;&#39;&#125;, Token&#123;type&#x3D;NUMBER, content&#x3D;&#39;5&#39;&#125;, Token&#123;type&#x3D;SEMI, content&#x3D;&#39;;&#39;&#125;, Token&#123;type&#x3D;INT, content&#x3D;&#39;int&#39;&#125;, Token&#123;type&#x3D;ID, content&#x3D;&#39;b&#39;&#125;, Token&#123;type&#x3D;EQUAL, content&#x3D;&#39;&#x3D;&#39;&#125;, Token&#123;type&#x3D;NUMBER, content&#x3D;&#39;3&#39;&#125;, Token&#123;type&#x3D;SEMI, content&#x3D;&#39;;&#39;&#125;, Token&#123;type&#x3D;ID, content&#x3D;&#39;a&#39;&#125;, Token&#123;type&#x3D;EQUAL, content&#x3D;&#39;&#x3D;&#39;&#125;, Token&#123;type&#x3D;ID, content&#x3D;&#39;b&#39;&#125;, Token&#123;type&#x3D;PLUS, content&#x3D;&#39;+&#39;&#125;, Token&#123;type&#x3D;ID, content&#x3D;&#39;c&#39;&#125;, Token&#123;type&#x3D;SEMI, content&#x3D;&#39;;&#39;&#125;, Token&#123;type&#x3D;RC, content&#x3D;&#39;&#125;&#39;&#125;]</span><br><span class="line">0 :栈顶-&gt; BLOCK  + 输入-&gt; LC</span><br><span class="line">  BLOCK-&gt;LC STMTS RC</span><br><span class="line">1 :栈顶-&gt; LC  + 输入-&gt; LC</span><br><span class="line">  LC-&gt;LC</span><br><span class="line">2 :栈顶-&gt; STMTS  + 输入-&gt; INT</span><br><span class="line">  STMTS-&gt;STMT STMTS</span><br><span class="line">3 :栈顶-&gt; STMT  + 输入-&gt; INT</span><br><span class="line">  STMT-&gt;DEFINE_STMT</span><br><span class="line">4 :栈顶-&gt; DEFINE_STMT  + 输入-&gt; INT</span><br><span class="line">  DEFINE_STMT-&gt;TYPE ID ASSGIN_STMT</span><br><span class="line">5 :栈顶-&gt; TYPE  + 输入-&gt; INT</span><br><span class="line">  TYPE-&gt;INT</span><br><span class="line">6 :栈顶-&gt; INT  + 输入-&gt; INT</span><br><span class="line">  INT-&gt;INT</span><br><span class="line">7 :栈顶-&gt; ID  + 输入-&gt; ID</span><br><span class="line">  ID-&gt;ID</span><br><span class="line">8 :栈顶-&gt; ASSGIN_STMT  + 输入-&gt; EQUAL</span><br><span class="line">  ASSGIN_STMT-&gt;EQUAL EXP SEMI</span><br><span class="line">9 :栈顶-&gt; EQUAL  + 输入-&gt; EQUAL</span><br><span class="line">  EQUAL-&gt;EQUAL</span><br><span class="line">10 :栈顶-&gt; EXP  + 输入-&gt; NUMBER</span><br><span class="line">  EXP-&gt;TERM EXP_P</span><br><span class="line">11 :栈顶-&gt; TERM  + 输入-&gt; NUMBER</span><br><span class="line">  TERM-&gt;FACTOR TERM_P</span><br><span class="line">12 :栈顶-&gt; FACTOR  + 输入-&gt; NUMBER</span><br><span class="line">  FACTOR-&gt;NUMBER</span><br><span class="line">13 :栈顶-&gt; NUMBER  + 输入-&gt; NUMBER</span><br><span class="line">  NUMBER-&gt;NUMBER</span><br><span class="line">14 :栈顶-&gt; TERM_P  + 输入-&gt; SEMI</span><br><span class="line">  TERM_P&#x3D;&#x3D; ε</span><br><span class="line">15 :栈顶-&gt; EXP_P  + 输入-&gt; SEMI</span><br><span class="line">  EXP_P&#x3D;&#x3D; ε</span><br><span class="line">16 :栈顶-&gt; SEMI  + 输入-&gt; SEMI</span><br><span class="line">  SEMI-&gt;SEMI</span><br><span class="line">17 :栈顶-&gt; STMTS  + 输入-&gt; INT</span><br><span class="line">  STMTS-&gt;STMT STMTS</span><br><span class="line">18 :栈顶-&gt; STMT  + 输入-&gt; INT</span><br><span class="line">  STMT-&gt;DEFINE_STMT</span><br><span class="line">19 :栈顶-&gt; DEFINE_STMT  + 输入-&gt; INT</span><br><span class="line">  DEFINE_STMT-&gt;TYPE ID ASSGIN_STMT</span><br><span class="line">20 :栈顶-&gt; TYPE  + 输入-&gt; INT</span><br><span class="line">  TYPE-&gt;INT</span><br><span class="line">21 :栈顶-&gt; INT  + 输入-&gt; INT</span><br><span class="line">  INT-&gt;INT</span><br><span class="line">22 :栈顶-&gt; ID  + 输入-&gt; ID</span><br><span class="line">  ID-&gt;ID</span><br><span class="line">23 :栈顶-&gt; ASSGIN_STMT  + 输入-&gt; EQUAL</span><br><span class="line">  ASSGIN_STMT-&gt;EQUAL EXP SEMI</span><br><span class="line">24 :栈顶-&gt; EQUAL  + 输入-&gt; EQUAL</span><br><span class="line">  EQUAL-&gt;EQUAL</span><br><span class="line">25 :栈顶-&gt; EXP  + 输入-&gt; NUMBER</span><br><span class="line">  EXP-&gt;TERM EXP_P</span><br><span class="line">26 :栈顶-&gt; TERM  + 输入-&gt; NUMBER</span><br><span class="line">  TERM-&gt;FACTOR TERM_P</span><br><span class="line">27 :栈顶-&gt; FACTOR  + 输入-&gt; NUMBER</span><br><span class="line">  FACTOR-&gt;NUMBER</span><br><span class="line">28 :栈顶-&gt; NUMBER  + 输入-&gt; NUMBER</span><br><span class="line">  NUMBER-&gt;NUMBER</span><br><span class="line">29 :栈顶-&gt; TERM_P  + 输入-&gt; SEMI</span><br><span class="line">  TERM_P&#x3D;&#x3D; ε</span><br><span class="line">30 :栈顶-&gt; EXP_P  + 输入-&gt; SEMI</span><br><span class="line">  EXP_P&#x3D;&#x3D; ε</span><br><span class="line">31 :栈顶-&gt; SEMI  + 输入-&gt; SEMI</span><br><span class="line">  SEMI-&gt;SEMI</span><br><span class="line">32 :栈顶-&gt; STMTS  + 输入-&gt; ID</span><br><span class="line">  STMTS-&gt;STMT STMTS</span><br><span class="line">33 :栈顶-&gt; STMT  + 输入-&gt; ID</span><br><span class="line">  STMT-&gt;ID ASSGIN_STMT</span><br><span class="line">34 :栈顶-&gt; ID  + 输入-&gt; ID</span><br><span class="line">  ID-&gt;ID</span><br><span class="line">35 :栈顶-&gt; ASSGIN_STMT  + 输入-&gt; EQUAL</span><br><span class="line">  ASSGIN_STMT-&gt;EQUAL EXP SEMI</span><br><span class="line">36 :栈顶-&gt; EQUAL  + 输入-&gt; EQUAL</span><br><span class="line">  EQUAL-&gt;EQUAL</span><br><span class="line">37 :栈顶-&gt; EXP  + 输入-&gt; ID</span><br><span class="line">  EXP-&gt;TERM EXP_P</span><br><span class="line">38 :栈顶-&gt; TERM  + 输入-&gt; ID</span><br><span class="line">  TERM-&gt;FACTOR TERM_P</span><br><span class="line">39 :栈顶-&gt; FACTOR  + 输入-&gt; ID</span><br><span class="line">  FACTOR-&gt;ID</span><br><span class="line">40 :栈顶-&gt; ID  + 输入-&gt; ID</span><br><span class="line">  ID-&gt;ID</span><br><span class="line">41 :栈顶-&gt; TERM_P  + 输入-&gt; PLUS</span><br><span class="line">  TERM_P&#x3D;&#x3D; ε</span><br><span class="line">42 :栈顶-&gt; EXP_P  + 输入-&gt; PLUS</span><br><span class="line">  EXP_P&#x3D;&#x3D; ε</span><br><span class="line">43 :栈顶-&gt; SEMI  + 输入-&gt; PLUS</span><br><span class="line">期望一个SEMI,实际为PLUS</span><br><span class="line">Exception in thread &quot;main&quot; compiler.exception.ParserException</span><br><span class="line">	at compiler.parser.Parser.checkBeforeParser(Parser.java:65)</span><br><span class="line">	at compiler.parser.Parser.main(Parser.java:105)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></table></figure>
<p>研究了一下代码推测是文法出现问题，尝试检测过First集和FOLLOW集的冲突</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (String key:g.followSetMap.keySet()) &#123;</span><br><span class="line">    Set&lt;String&gt; fis &#x3D; g.firstSetMap.get(key);</span><br><span class="line">    Set&lt;String&gt; fos &#x3D; g.followSetMap.get(key);</span><br><span class="line">    for(String fo: fos)&#123;</span><br><span class="line">        if(fis.contains(fo))&#123;</span><br><span class="line">            System.out.println(key+&quot;的First集合和FOLLOW集出现语法冲突：&quot;+fo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TERM_P的First集合和FOLLOW集出现语法冲突：DIVOP</span><br><span class="line">TERM_P的First集合和FOLLOW集出现语法冲突：STAR</span><br><span class="line">EXP_P的First集合和FOLLOW集出现语法冲突：PLUS</span><br><span class="line">EXP_P的First集合和FOLLOW集出现语法冲突：MINUS</span><br><span class="line">ELSE_STMT的First集合和FOLLOW集出现语法冲突：ELSE</span><br></pre></td></tr></table></figure>
<p>文法出现了二义性，ELSE_STMT为什么会出现二义性呢，因为(STMT -&gt;IF_STMT ELSE_STMT)和(IF_STMT-&gt;IF LP EXP_BOOL RP STMT)语句，展开就是STMT-&gt;IF LP EXP_BOOL RP STMT ELSE_STMT,ELSE_STMT可以为空，按照Follow集的算法，STMT的后面可以跟ELSE_STMT的FIRST集<br>没想出来咋改写，使用了个笨办法–改predict,对了，这里我把select改动了下，改为predict：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makePredict</span><span class="params">()</span></span>&#123;</span><br><span class="line">        initPredict();</span><br><span class="line">        <span class="keyword">for</span> (String left:grammar.keySet()) &#123;</span><br><span class="line">            String productions = grammar.get(left);</span><br><span class="line">            <span class="comment">//left -&gt; pros[0] | pros[1] .....</span></span><br><span class="line">            String[] pros = productions.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pros.length; i++) &#123;</span><br><span class="line">                String right = pros[i];</span><br><span class="line">                <span class="keyword">if</span>(right.equals(<span class="string">&quot;NULL&quot;</span>))&#123;</span><br><span class="line">                    Set&lt;String&gt; follow = followSetMap.get(left);</span><br><span class="line">                    <span class="keyword">for</span> (String fo:follow) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!firstSetMap.get(left).contains(fo))&#123;</span><br><span class="line">                            <span class="comment">//出现First集合和FOLLOW集冲突时默认使用First集</span></span><br><span class="line">                            predict.put(left+<span class="string">&quot;@&quot;</span>+fo,left+<span class="string">&quot;== ε&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                String[] pro = right.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pro.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(pro[j].equals(<span class="string">&quot;NULL&quot;</span>))&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Set&lt;String&gt; first = firstSetMap.get(pro[j]);</span><br><span class="line"><span class="comment">//                    System.out.println(pro[j]);</span></span><br><span class="line">                    <span class="keyword">for</span> (String fi: first) &#123;</span><br><span class="line">                        predict.put(left+<span class="string">&quot;@&quot;</span>+fi,left+<span class="string">&quot;-&gt;&quot;</span>+right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(terminalSet.contains(pro[j]))&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>predict的key是这样的，可以看示例猜下含义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXP@ID [ EXP-&gt;TERM EXP_P ]</span><br><span class="line">TERM_P@RP [ TERM_P&#x3D;&#x3D; ε ]</span><br><span class="line">PROGRAM@LC [ PROGRAM-&gt;BLOCK ]</span><br><span class="line">EXP_P@RP [ EXP_P&#x3D;&#x3D; ε ]</span><br><span class="line">JUMP_STMT@FOR [ JUMP_STMT-&gt;FOR LP EXP SEMI EXP_BOOL SEMI EXP RP STMT ]</span><br><span class="line">TERM_P@SEMI [ TERM_P&#x3D;&#x3D; ε ]</span><br><span class="line">JUMP_STMT@SEMI [ JUMP_STMT-&gt;SEMI ]</span><br><span class="line">STMT@LC [ STMT-&gt;BLOCK ]</span><br><span class="line">ASSGIN_STMT@EQUAL [ ASSGIN_STMT-&gt;EQUAL EXP SEMI ]</span><br><span class="line">TYPE@INT [ TYPE-&gt;INT ]</span><br><span class="line">EXP_BOOL@ID [ EXP_BOOL-&gt;EXP RELOP EXP ]</span><br><span class="line">DEFINE_STMT@BOOLEAN [ DEFINE_STMT-&gt;TYPE ID ASSGIN_STMT ]</span><br><span class="line">STMTS@BOOLEAN [ STMTS-&gt;STMT STMTS ]</span><br><span class="line">EXP@LP [ EXP-&gt;TERM EXP_P ]</span><br><span class="line">TERM@ID [ TERM-&gt;FACTOR TERM_P ]</span><br><span class="line">TYPE@BOOLEAN [ TYPE-&gt;BOOLEAN ]</span><br><span class="line">DEFINE_STMT@SEMI [ DEFINE_STMT-&gt;SEMI ]</span><br><span class="line">BLOCK@LC [ BLOCK-&gt;LC STMTS RC ]</span><br><span class="line">EXP_BOOL@LP [ EXP_BOOL-&gt;EXP RELOP EXP ]</span><br><span class="line">JUMP_STMT@CONTINUE [ JUMP_STMT-&gt;CONTINUE SEMI ]</span><br><span class="line">TERM_P@PLUS [ TERM_P&#x3D;&#x3D; ε ]</span><br><span class="line">STMT@STRING [ STMT-&gt;DEFINE_STMT ]</span><br><span class="line">JUMP_STMT@RETURN [ JUMP_STMT-&gt;RETURN EXP SEMI ]</span><br><span class="line">TERM@LP [ TERM-&gt;FACTOR TERM_P ]</span><br><span class="line">TERM_P@MINUS [ TERM_P&#x3D;&#x3D; ε ]</span><br><span class="line">EXP@MINUS [ EXP-&gt;TERM EXP_P ]</span><br><span class="line">STMT@SEMI [ STMT-&gt;SEMI ]</span><br><span class="line">STMT@BOOLEAN [ STMT-&gt;DEFINE_STMT ]</span><br><span class="line">EXP_P@SEMI [ EXP_P&#x3D;&#x3D; ε ]</span><br><span class="line">TERM_P@RELOP [ TERM_P&#x3D;&#x3D; ε ]</span><br><span class="line">EXP_BOOL@RELOP [ EXP_BOOL-&gt;EXP RELOP EXP ]</span><br><span class="line">STMTS@PRINT [ STMTS-&gt;STMT STMTS ]</span><br><span class="line">TERM@DIVOP [ TERM-&gt;FACTOR TERM_P ]</span><br><span class="line">STMTS@RC [ STMTS&#x3D;&#x3D; ε ]</span><br><span class="line">FACTOR@NUMBER [ FACTOR-&gt;NUMBER ]</span><br><span class="line">DEFINE_STMT@INT [ DEFINE_STMT-&gt;TYPE ID ASSGIN_STMT ]</span><br><span class="line">STMTS@STRING [ STMTS-&gt;STMT STMTS ]</span><br><span class="line">EXP_P@PLUS [ EXP_P-&gt;PLUS TERM EXP_P ]</span><br><span class="line">STMTS@INT [ STMTS-&gt;STMT STMTS ]</span><br><span class="line">EXP_P@MINUS [ EXP_P-&gt;MINUS TERM EXP_P ]</span><br><span class="line">EXP@NUMBER [ EXP-&gt;TERM EXP_P ]</span><br><span class="line">DEFINE_STMT@ID [ DEFINE_STMT-&gt;TYPE ID ASSGIN_STMT ]</span><br><span class="line">STMTS@ID [ STMTS-&gt;STMT STMTS ]</span><br><span class="line">STMTS@IF [ STMTS-&gt;STMT STMTS ]</span><br><span class="line">EXP_P@RELOP [ EXP_P&#x3D;&#x3D; ε ]</span><br><span class="line">TYPE@STRING [ TYPE-&gt;STRING ]</span><br><span class="line">EXP_BOOL@NUMBER [ EXP_BOOL-&gt;EXP RELOP EXP ]</span><br><span class="line">JUMP_STMT@WHILE [ JUMP_STMT-&gt;WHILE LP EXP_BOOL RP STMT ]</span><br><span class="line">TERM@STAR [ TERM-&gt;FACTOR TERM_P ]</span><br><span class="line">ELSE_STMT@ELSE [ ELSE_STMT-&gt;ELSE STMT ]</span><br><span class="line">FACTOR@ID [ FACTOR-&gt;ID ]</span><br><span class="line">STMT@PRINT [ STMT-&gt;PRINT LP EXP RP ]</span><br><span class="line">STMTS@SEMI [ STMTS-&gt;STMT STMTS ]</span><br><span class="line">ELSE_STMT@RC [ ELSE_STMT&#x3D;&#x3D; ε ]</span><br><span class="line">STMT@ELSE [ STMT-&gt;IF_STMT ELSE_STMT ]</span><br><span class="line">IF_STMT@IF [ IF_STMT-&gt;IF LP EXP_BOOL RP STMT ]</span><br><span class="line">STMT@INT [ STMT-&gt;DEFINE_STMT ]</span><br><span class="line">TERM_P@STAR [ TERM_P-&gt;STAR FACTOR TERM_P ]</span><br><span class="line">TERM@NUMBER [ TERM-&gt;FACTOR TERM_P ]</span><br><span class="line">TERM_P@DIVOP [ TERM_P-&gt;DIVOP FACTOR TERM_P ]</span><br><span class="line">FACTOR@LP [ FACTOR-&gt;LP EXP RP ]</span><br><span class="line">STMT@ID [ STMT-&gt;ID ASSGIN_STMT ]</span><br><span class="line">STMTS@LC [ STMTS-&gt;STMT STMTS ]</span><br><span class="line">STMT@IF [ STMT-&gt;IF_STMT ELSE_STMT ]</span><br><span class="line">EXP@PLUS [ EXP-&gt;TERM EXP_P ]</span><br><span class="line">JUMP_STMT@BREAK [ JUMP_STMT-&gt;BREAK SEMI ]</span><br><span class="line">DEFINE_STMT@STRING [ DEFINE_STMT-&gt;TYPE ID ASSGIN_STMT ]</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>这个key = 栈顶@输入记号， value = 当前执行的消去规则(同样的终结符)或推导规则</p>
<hr>
<p>这个时候已经可以回答上下文无关文法检查的 YES OR NO 了，例如下面这样一个input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">int a &#x3D; 0;</span><br><span class="line">while( a!&#x3D; 1)&#123;</span><br><span class="line">	a &#x3D; a+1 * c +d;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for( int i&#x3D; 3 ; i&lt;3 ; i &#x3D; i+2)&#123;</span><br><span class="line">	a &#x3D; a+3;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取到Token流：[Token&#123;type&#x3D;LC, content&#x3D;&#39;&#123;&#39;&#125;, Token&#123;type&#x3D;KEYWORD, content&#x3D;&#39;int&#39;&#125;, Token&#123;type&#x3D;ID, content&#x3D;&#39;a&#39;&#125;, Token&#123;type&#x3D;EQUAL, content&#x3D;&#39;&#x3D;&#39;&#125;, Token&#123;type&#x3D;NUMBER, content&#x3D;&#39;0&#39;&#125;, Token&#123;type&#x3D;SEMI, content&#x3D;&#39;;&#39;&#125;, Token&#123;type&#x3D;KEYWORD, content&#x3D;&#39;while&#39;&#125;, Token&#123;type&#x3D;LP, content&#x3D;&#39;(&#39;&#125;, Token&#123;type&#x3D;ID, content&#x3D;&#39;a&#39;&#125;, Token&#123;type&#x3D;RELOP, content&#x3D;&#39;!&#x3D;&#39;&#125;, Token&#123;type&#x3D;NUMBER, content&#x3D;&#39;1&#39;&#125;, Token&#123;type&#x3D;RP, content&#x3D;&#39;)&#39;&#125;, Token&#123;type&#x3D;LC, content&#x3D;&#39;&#123;&#39;&#125;, Token&#123;type&#x3D;ID, content&#x3D;&#39;a&#39;&#125;, Token&#123;type&#x3D;EQUAL, content&#x3D;&#39;&#x3D;&#39;&#125;, Token&#123;type&#x3D;ID, content&#x3D;&#39;a&#39;&#125;, Token&#123;type&#x3D;PLUS, content&#x3D;&#39;+&#39;&#125;, Token&#123;type&#x3D;NUMBER, content&#x3D;&#39;1&#39;&#125;, Token&#123;type&#x3D;STAR, content&#x3D;&#39;*&#39;&#125;, Token&#123;type&#x3D;ID, content&#x3D;&#39;c&#39;&#125;, Token&#123;type&#x3D;PLUS, content&#x3D;&#39;+&#39;&#125;, Token&#123;type&#x3D;ID, content&#x3D;&#39;d&#39;&#125;, Token&#123;type&#x3D;SEMI, content&#x3D;&#39;;&#39;&#125;, Token&#123;type&#x3D;RC, content&#x3D;&#39;&#125;&#39;&#125;, Token&#123;type&#x3D;KEYWORD, content&#x3D;&#39;for&#39;&#125;, Token&#123;type&#x3D;LP, content&#x3D;&#39;(&#39;&#125;, Token&#123;type&#x3D;KEYWORD, content&#x3D;&#39;int&#39;&#125;, Token&#123;type&#x3D;ID, content&#x3D;&#39;i&#39;&#125;, Token&#123;type&#x3D;EQUAL, content&#x3D;&#39;&#x3D;&#39;&#125;, Token&#123;type&#x3D;NUMBER, content&#x3D;&#39;3&#39;&#125;, Token&#123;type&#x3D;SEMI, content&#x3D;&#39;;&#39;&#125;, Token&#123;type&#x3D;ID, content&#x3D;&#39;i&#39;&#125;, Token&#123;type&#x3D;RELOP, content&#x3D;&#39;&lt;&#39;&#125;, Token&#123;type&#x3D;NUMBER, content&#x3D;&#39;3&#39;&#125;, Token&#123;type&#x3D;SEMI, content&#x3D;&#39;;&#39;&#125;, Token&#123;type&#x3D;ID, content&#x3D;&#39;i&#39;&#125;, Token&#123;type&#x3D;EQUAL, content&#x3D;&#39;&#x3D;&#39;&#125;, Token&#123;type&#x3D;ID, content&#x3D;&#39;i&#39;&#125;, Token&#123;type&#x3D;PLUS, content&#x3D;&#39;+&#39;&#125;, Token&#123;type&#x3D;NUMBER, content&#x3D;&#39;2&#39;&#125;, Token&#123;type&#x3D;RP, content&#x3D;&#39;)&#39;&#125;, Token&#123;type&#x3D;LC, content&#x3D;&#39;&#123;&#39;&#125;, Token&#123;type&#x3D;ID, content&#x3D;&#39;a&#39;&#125;, Token&#123;type&#x3D;EQUAL, content&#x3D;&#39;&#x3D;&#39;&#125;, Token&#123;type&#x3D;ID, content&#x3D;&#39;a&#39;&#125;, Token&#123;type&#x3D;PLUS, content&#x3D;&#39;+&#39;&#125;, Token&#123;type&#x3D;NUMBER, content&#x3D;&#39;3&#39;&#125;, Token&#123;type&#x3D;SEMI, content&#x3D;&#39;;&#39;&#125;, Token&#123;type&#x3D;RC, content&#x3D;&#39;&#125;&#39;&#125;, Token&#123;type&#x3D;PRINT, content&#x3D;&#39;println&#39;&#125;, Token&#123;type&#x3D;LP, content&#x3D;&#39;(&#39;&#125;, Token&#123;type&#x3D;ID, content&#x3D;&#39;a&#39;&#125;, Token&#123;type&#x3D;RP, content&#x3D;&#39;)&#39;&#125;, Token&#123;type&#x3D;SEMI, content&#x3D;&#39;;&#39;&#125;, Token&#123;type&#x3D;RC, content&#x3D;&#39;&#125;&#39;&#125;]</span><br><span class="line">0 :栈顶-&gt; BLOCK  + 输入-&gt; LC</span><br><span class="line">  BLOCK-&gt;LC STMTS RC</span><br><span class="line">1 :栈顶-&gt; LC  + 输入-&gt; LC</span><br><span class="line">  LC-&gt;LC</span><br><span class="line">2 :栈顶-&gt; STMTS  + 输入-&gt; INT</span><br><span class="line">  STMTS-&gt;STMT STMTS</span><br><span class="line">3 :栈顶-&gt; STMT  + 输入-&gt; INT</span><br><span class="line">  STMT-&gt;DEFINE_STMT</span><br><span class="line">4 :栈顶-&gt; DEFINE_STMT  + 输入-&gt; INT</span><br><span class="line">  DEFINE_STMT-&gt;TYPE ID ASSGIN_STMT</span><br><span class="line">5 :栈顶-&gt; TYPE  + 输入-&gt; INT</span><br><span class="line">  TYPE-&gt;INT</span><br><span class="line">6 :栈顶-&gt; INT  + 输入-&gt; INT</span><br><span class="line">  INT-&gt;INT</span><br><span class="line">7 :栈顶-&gt; ID  + 输入-&gt; ID</span><br><span class="line">  ID-&gt;ID</span><br><span class="line">8 :栈顶-&gt; ASSGIN_STMT  + 输入-&gt; EQUAL</span><br><span class="line">  ASSGIN_STMT-&gt;EQUAL EXP SEMI</span><br><span class="line">9 :栈顶-&gt; EQUAL  + 输入-&gt; EQUAL</span><br><span class="line">  EQUAL-&gt;EQUAL</span><br><span class="line">10 :栈顶-&gt; EXP  + 输入-&gt; NUMBER</span><br><span class="line">  EXP-&gt;TERM EXP_P</span><br><span class="line">11 :栈顶-&gt; TERM  + 输入-&gt; NUMBER</span><br><span class="line">  TERM-&gt;FACTOR TERM_P</span><br><span class="line">12 :栈顶-&gt; FACTOR  + 输入-&gt; NUMBER</span><br><span class="line">  FACTOR-&gt;NUMBER</span><br><span class="line">13 :栈顶-&gt; NUMBER  + 输入-&gt; NUMBER</span><br><span class="line">  NUMBER-&gt;NUMBER</span><br><span class="line">14 :栈顶-&gt; TERM_P  + 输入-&gt; SEMI</span><br><span class="line">  TERM_P&#x3D;&#x3D; ε</span><br><span class="line">15 :栈顶-&gt; EXP_P  + 输入-&gt; SEMI</span><br><span class="line">  EXP_P&#x3D;&#x3D; ε</span><br><span class="line">16 :栈顶-&gt; SEMI  + 输入-&gt; SEMI</span><br><span class="line">  SEMI-&gt;SEMI</span><br><span class="line">17 :栈顶-&gt; STMTS  + 输入-&gt; WHILE</span><br><span class="line">  STMTS-&gt;STMT STMTS</span><br><span class="line">18 :栈顶-&gt; STMT  + 输入-&gt; WHILE</span><br><span class="line">  STMT-&gt;JUMP_STMT</span><br><span class="line">19 :栈顶-&gt; JUMP_STMT  + 输入-&gt; WHILE</span><br><span class="line">  JUMP_STMT-&gt;WHILE LP EXP_BOOL RP STMT</span><br><span class="line">20 :栈顶-&gt; WHILE  + 输入-&gt; WHILE</span><br><span class="line">  WHILE-&gt;WHILE</span><br><span class="line">21 :栈顶-&gt; LP  + 输入-&gt; LP</span><br><span class="line">  LP-&gt;LP</span><br><span class="line">22 :栈顶-&gt; EXP_BOOL  + 输入-&gt; ID</span><br><span class="line">  EXP_BOOL-&gt;EXP RELOP EXP</span><br><span class="line">23 :栈顶-&gt; EXP  + 输入-&gt; ID</span><br><span class="line">  EXP-&gt;TERM EXP_P</span><br><span class="line">24 :栈顶-&gt; TERM  + 输入-&gt; ID</span><br><span class="line">  TERM-&gt;FACTOR TERM_P</span><br><span class="line">25 :栈顶-&gt; FACTOR  + 输入-&gt; ID</span><br><span class="line">  FACTOR-&gt;ID</span><br><span class="line">26 :栈顶-&gt; ID  + 输入-&gt; ID</span><br><span class="line">  ID-&gt;ID</span><br><span class="line">27 :栈顶-&gt; TERM_P  + 输入-&gt; RELOP</span><br><span class="line">  TERM_P&#x3D;&#x3D; ε</span><br><span class="line">28 :栈顶-&gt; EXP_P  + 输入-&gt; RELOP</span><br><span class="line">  EXP_P&#x3D;&#x3D; ε</span><br><span class="line">29 :栈顶-&gt; RELOP  + 输入-&gt; RELOP</span><br><span class="line">  RELOP-&gt;RELOP</span><br><span class="line">30 :栈顶-&gt; EXP  + 输入-&gt; NUMBER</span><br><span class="line">  EXP-&gt;TERM EXP_P</span><br><span class="line">31 :栈顶-&gt; TERM  + 输入-&gt; NUMBER</span><br><span class="line">  TERM-&gt;FACTOR TERM_P</span><br><span class="line">32 :栈顶-&gt; FACTOR  + 输入-&gt; NUMBER</span><br><span class="line">  FACTOR-&gt;NUMBER</span><br><span class="line">33 :栈顶-&gt; NUMBER  + 输入-&gt; NUMBER</span><br><span class="line">  NUMBER-&gt;NUMBER</span><br><span class="line">34 :栈顶-&gt; TERM_P  + 输入-&gt; RP</span><br><span class="line">  TERM_P&#x3D;&#x3D; ε</span><br><span class="line">35 :栈顶-&gt; EXP_P  + 输入-&gt; RP</span><br><span class="line">  EXP_P&#x3D;&#x3D; ε</span><br><span class="line">36 :栈顶-&gt; RP  + 输入-&gt; RP</span><br><span class="line">  RP-&gt;RP</span><br><span class="line">37 :栈顶-&gt; STMT  + 输入-&gt; LC</span><br><span class="line">  STMT-&gt;BLOCK</span><br><span class="line">38 :栈顶-&gt; BLOCK  + 输入-&gt; LC</span><br><span class="line">  BLOCK-&gt;LC STMTS RC</span><br><span class="line">39 :栈顶-&gt; LC  + 输入-&gt; LC</span><br><span class="line">  LC-&gt;LC</span><br><span class="line">40 :栈顶-&gt; STMTS  + 输入-&gt; ID</span><br><span class="line">  STMTS-&gt;STMT STMTS</span><br><span class="line">41 :栈顶-&gt; STMT  + 输入-&gt; ID</span><br><span class="line">  STMT-&gt;ID ASSGIN_STMT</span><br><span class="line">42 :栈顶-&gt; ID  + 输入-&gt; ID</span><br><span class="line">  ID-&gt;ID</span><br><span class="line">43 :栈顶-&gt; ASSGIN_STMT  + 输入-&gt; EQUAL</span><br><span class="line">  ASSGIN_STMT-&gt;EQUAL EXP SEMI</span><br><span class="line">44 :栈顶-&gt; EQUAL  + 输入-&gt; EQUAL</span><br><span class="line">  EQUAL-&gt;EQUAL</span><br><span class="line">45 :栈顶-&gt; EXP  + 输入-&gt; ID</span><br><span class="line">  EXP-&gt;TERM EXP_P</span><br><span class="line">46 :栈顶-&gt; TERM  + 输入-&gt; ID</span><br><span class="line">  TERM-&gt;FACTOR TERM_P</span><br><span class="line">47 :栈顶-&gt; FACTOR  + 输入-&gt; ID</span><br><span class="line">  FACTOR-&gt;ID</span><br><span class="line">48 :栈顶-&gt; ID  + 输入-&gt; ID</span><br><span class="line">  ID-&gt;ID</span><br><span class="line">49 :栈顶-&gt; TERM_P  + 输入-&gt; PLUS</span><br><span class="line">  TERM_P&#x3D;&#x3D; ε</span><br><span class="line">50 :栈顶-&gt; EXP_P  + 输入-&gt; PLUS</span><br><span class="line">  EXP_P-&gt;PLUS TERM EXP_P</span><br><span class="line">51 :栈顶-&gt; PLUS  + 输入-&gt; PLUS</span><br><span class="line">  PLUS-&gt;PLUS</span><br><span class="line">52 :栈顶-&gt; TERM  + 输入-&gt; NUMBER</span><br><span class="line">  TERM-&gt;FACTOR TERM_P</span><br><span class="line">53 :栈顶-&gt; FACTOR  + 输入-&gt; NUMBER</span><br><span class="line">  FACTOR-&gt;NUMBER</span><br><span class="line">54 :栈顶-&gt; NUMBER  + 输入-&gt; NUMBER</span><br><span class="line">  NUMBER-&gt;NUMBER</span><br><span class="line">55 :栈顶-&gt; TERM_P  + 输入-&gt; STAR</span><br><span class="line">  TERM_P-&gt;STAR FACTOR TERM_P</span><br><span class="line">56 :栈顶-&gt; STAR  + 输入-&gt; STAR</span><br><span class="line">  STAR-&gt;STAR</span><br><span class="line">57 :栈顶-&gt; FACTOR  + 输入-&gt; ID</span><br><span class="line">  FACTOR-&gt;ID</span><br><span class="line">58 :栈顶-&gt; ID  + 输入-&gt; ID</span><br><span class="line">  ID-&gt;ID</span><br><span class="line">59 :栈顶-&gt; TERM_P  + 输入-&gt; PLUS</span><br><span class="line">  TERM_P&#x3D;&#x3D; ε</span><br><span class="line">60 :栈顶-&gt; EXP_P  + 输入-&gt; PLUS</span><br><span class="line">  EXP_P-&gt;PLUS TERM EXP_P</span><br><span class="line">61 :栈顶-&gt; PLUS  + 输入-&gt; PLUS</span><br><span class="line">  PLUS-&gt;PLUS</span><br><span class="line">62 :栈顶-&gt; TERM  + 输入-&gt; ID</span><br><span class="line">  TERM-&gt;FACTOR TERM_P</span><br><span class="line">63 :栈顶-&gt; FACTOR  + 输入-&gt; ID</span><br><span class="line">  FACTOR-&gt;ID</span><br><span class="line">64 :栈顶-&gt; ID  + 输入-&gt; ID</span><br><span class="line">  ID-&gt;ID</span><br><span class="line">65 :栈顶-&gt; TERM_P  + 输入-&gt; SEMI</span><br><span class="line">  TERM_P&#x3D;&#x3D; ε</span><br><span class="line">66 :栈顶-&gt; EXP_P  + 输入-&gt; SEMI</span><br><span class="line">  EXP_P&#x3D;&#x3D; ε</span><br><span class="line">67 :栈顶-&gt; SEMI  + 输入-&gt; SEMI</span><br><span class="line">  SEMI-&gt;SEMI</span><br><span class="line">68 :栈顶-&gt; STMTS  + 输入-&gt; RC</span><br><span class="line">  STMTS&#x3D;&#x3D; ε</span><br><span class="line">69 :栈顶-&gt; RC  + 输入-&gt; RC</span><br><span class="line">  RC-&gt;RC</span><br><span class="line">70 :栈顶-&gt; STMTS  + 输入-&gt; FOR</span><br><span class="line">  STMTS-&gt;STMT STMTS</span><br><span class="line">71 :栈顶-&gt; STMT  + 输入-&gt; FOR</span><br><span class="line">  STMT-&gt;JUMP_STMT</span><br><span class="line">72 :栈顶-&gt; JUMP_STMT  + 输入-&gt; FOR</span><br><span class="line">  JUMP_STMT-&gt;FOR LP DEFINE_STMT EXP_BOOL SEMI ID EQUAL EXP RP STMT</span><br><span class="line">73 :栈顶-&gt; FOR  + 输入-&gt; FOR</span><br><span class="line">  FOR-&gt;FOR</span><br><span class="line">74 :栈顶-&gt; LP  + 输入-&gt; LP</span><br><span class="line">  LP-&gt;LP</span><br><span class="line">75 :栈顶-&gt; DEFINE_STMT  + 输入-&gt; INT</span><br><span class="line">  DEFINE_STMT-&gt;TYPE ID ASSGIN_STMT</span><br><span class="line">76 :栈顶-&gt; TYPE  + 输入-&gt; INT</span><br><span class="line">  TYPE-&gt;INT</span><br><span class="line">77 :栈顶-&gt; INT  + 输入-&gt; INT</span><br><span class="line">  INT-&gt;INT</span><br><span class="line">78 :栈顶-&gt; ID  + 输入-&gt; ID</span><br><span class="line">  ID-&gt;ID</span><br><span class="line">79 :栈顶-&gt; ASSGIN_STMT  + 输入-&gt; EQUAL</span><br><span class="line">  ASSGIN_STMT-&gt;EQUAL EXP SEMI</span><br><span class="line">80 :栈顶-&gt; EQUAL  + 输入-&gt; EQUAL</span><br><span class="line">  EQUAL-&gt;EQUAL</span><br><span class="line">81 :栈顶-&gt; EXP  + 输入-&gt; NUMBER</span><br><span class="line">  EXP-&gt;TERM EXP_P</span><br><span class="line">82 :栈顶-&gt; TERM  + 输入-&gt; NUMBER</span><br><span class="line">  TERM-&gt;FACTOR TERM_P</span><br><span class="line">83 :栈顶-&gt; FACTOR  + 输入-&gt; NUMBER</span><br><span class="line">  FACTOR-&gt;NUMBER</span><br><span class="line">84 :栈顶-&gt; NUMBER  + 输入-&gt; NUMBER</span><br><span class="line">  NUMBER-&gt;NUMBER</span><br><span class="line">85 :栈顶-&gt; TERM_P  + 输入-&gt; SEMI</span><br><span class="line">  TERM_P&#x3D;&#x3D; ε</span><br><span class="line">86 :栈顶-&gt; EXP_P  + 输入-&gt; SEMI</span><br><span class="line">  EXP_P&#x3D;&#x3D; ε</span><br><span class="line">87 :栈顶-&gt; SEMI  + 输入-&gt; SEMI</span><br><span class="line">  SEMI-&gt;SEMI</span><br><span class="line">88 :栈顶-&gt; EXP_BOOL  + 输入-&gt; ID</span><br><span class="line">  EXP_BOOL-&gt;EXP RELOP EXP</span><br><span class="line">89 :栈顶-&gt; EXP  + 输入-&gt; ID</span><br><span class="line">  EXP-&gt;TERM EXP_P</span><br><span class="line">90 :栈顶-&gt; TERM  + 输入-&gt; ID</span><br><span class="line">  TERM-&gt;FACTOR TERM_P</span><br><span class="line">91 :栈顶-&gt; FACTOR  + 输入-&gt; ID</span><br><span class="line">  FACTOR-&gt;ID</span><br><span class="line">92 :栈顶-&gt; ID  + 输入-&gt; ID</span><br><span class="line">  ID-&gt;ID</span><br><span class="line">93 :栈顶-&gt; TERM_P  + 输入-&gt; RELOP</span><br><span class="line">  TERM_P&#x3D;&#x3D; ε</span><br><span class="line">94 :栈顶-&gt; EXP_P  + 输入-&gt; RELOP</span><br><span class="line">  EXP_P&#x3D;&#x3D; ε</span><br><span class="line">95 :栈顶-&gt; RELOP  + 输入-&gt; RELOP</span><br><span class="line">  RELOP-&gt;RELOP</span><br><span class="line">96 :栈顶-&gt; EXP  + 输入-&gt; NUMBER</span><br><span class="line">  EXP-&gt;TERM EXP_P</span><br><span class="line">97 :栈顶-&gt; TERM  + 输入-&gt; NUMBER</span><br><span class="line">  TERM-&gt;FACTOR TERM_P</span><br><span class="line">98 :栈顶-&gt; FACTOR  + 输入-&gt; NUMBER</span><br><span class="line">  FACTOR-&gt;NUMBER</span><br><span class="line">99 :栈顶-&gt; NUMBER  + 输入-&gt; NUMBER</span><br><span class="line">  NUMBER-&gt;NUMBER</span><br><span class="line">100 :栈顶-&gt; TERM_P  + 输入-&gt; SEMI</span><br><span class="line">  TERM_P&#x3D;&#x3D; ε</span><br><span class="line">101 :栈顶-&gt; EXP_P  + 输入-&gt; SEMI</span><br><span class="line">  EXP_P&#x3D;&#x3D; ε</span><br><span class="line">102 :栈顶-&gt; SEMI  + 输入-&gt; SEMI</span><br><span class="line">  SEMI-&gt;SEMI</span><br><span class="line">103 :栈顶-&gt; ID  + 输入-&gt; ID</span><br><span class="line">  ID-&gt;ID</span><br><span class="line">104 :栈顶-&gt; EQUAL  + 输入-&gt; EQUAL</span><br><span class="line">  EQUAL-&gt;EQUAL</span><br><span class="line">105 :栈顶-&gt; EXP  + 输入-&gt; ID</span><br><span class="line">  EXP-&gt;TERM EXP_P</span><br><span class="line">106 :栈顶-&gt; TERM  + 输入-&gt; ID</span><br><span class="line">  TERM-&gt;FACTOR TERM_P</span><br><span class="line">107 :栈顶-&gt; FACTOR  + 输入-&gt; ID</span><br><span class="line">  FACTOR-&gt;ID</span><br><span class="line">108 :栈顶-&gt; ID  + 输入-&gt; ID</span><br><span class="line">  ID-&gt;ID</span><br><span class="line">109 :栈顶-&gt; TERM_P  + 输入-&gt; PLUS</span><br><span class="line">  TERM_P&#x3D;&#x3D; ε</span><br><span class="line">110 :栈顶-&gt; EXP_P  + 输入-&gt; PLUS</span><br><span class="line">  EXP_P-&gt;PLUS TERM EXP_P</span><br><span class="line">111 :栈顶-&gt; PLUS  + 输入-&gt; PLUS</span><br><span class="line">  PLUS-&gt;PLUS</span><br><span class="line">112 :栈顶-&gt; TERM  + 输入-&gt; NUMBER</span><br><span class="line">  TERM-&gt;FACTOR TERM_P</span><br><span class="line">113 :栈顶-&gt; FACTOR  + 输入-&gt; NUMBER</span><br><span class="line">  FACTOR-&gt;NUMBER</span><br><span class="line">114 :栈顶-&gt; NUMBER  + 输入-&gt; NUMBER</span><br><span class="line">  NUMBER-&gt;NUMBER</span><br><span class="line">115 :栈顶-&gt; TERM_P  + 输入-&gt; RP</span><br><span class="line">  TERM_P&#x3D;&#x3D; ε</span><br><span class="line">116 :栈顶-&gt; EXP_P  + 输入-&gt; RP</span><br><span class="line">  EXP_P&#x3D;&#x3D; ε</span><br><span class="line">117 :栈顶-&gt; RP  + 输入-&gt; RP</span><br><span class="line">  RP-&gt;RP</span><br><span class="line">118 :栈顶-&gt; STMT  + 输入-&gt; LC</span><br><span class="line">  STMT-&gt;BLOCK</span><br><span class="line">119 :栈顶-&gt; BLOCK  + 输入-&gt; LC</span><br><span class="line">  BLOCK-&gt;LC STMTS RC</span><br><span class="line">120 :栈顶-&gt; LC  + 输入-&gt; LC</span><br><span class="line">  LC-&gt;LC</span><br><span class="line">121 :栈顶-&gt; STMTS  + 输入-&gt; ID</span><br><span class="line">  STMTS-&gt;STMT STMTS</span><br><span class="line">122 :栈顶-&gt; STMT  + 输入-&gt; ID</span><br><span class="line">  STMT-&gt;ID ASSGIN_STMT</span><br><span class="line">123 :栈顶-&gt; ID  + 输入-&gt; ID</span><br><span class="line">  ID-&gt;ID</span><br><span class="line">124 :栈顶-&gt; ASSGIN_STMT  + 输入-&gt; EQUAL</span><br><span class="line">  ASSGIN_STMT-&gt;EQUAL EXP SEMI</span><br><span class="line">125 :栈顶-&gt; EQUAL  + 输入-&gt; EQUAL</span><br><span class="line">  EQUAL-&gt;EQUAL</span><br><span class="line">126 :栈顶-&gt; EXP  + 输入-&gt; ID</span><br><span class="line">  EXP-&gt;TERM EXP_P</span><br><span class="line">127 :栈顶-&gt; TERM  + 输入-&gt; ID</span><br><span class="line">  TERM-&gt;FACTOR TERM_P</span><br><span class="line">128 :栈顶-&gt; FACTOR  + 输入-&gt; ID</span><br><span class="line">  FACTOR-&gt;ID</span><br><span class="line">129 :栈顶-&gt; ID  + 输入-&gt; ID</span><br><span class="line">  ID-&gt;ID</span><br><span class="line">130 :栈顶-&gt; TERM_P  + 输入-&gt; PLUS</span><br><span class="line">  TERM_P&#x3D;&#x3D; ε</span><br><span class="line">131 :栈顶-&gt; EXP_P  + 输入-&gt; PLUS</span><br><span class="line">  EXP_P-&gt;PLUS TERM EXP_P</span><br><span class="line">132 :栈顶-&gt; PLUS  + 输入-&gt; PLUS</span><br><span class="line">  PLUS-&gt;PLUS</span><br><span class="line">133 :栈顶-&gt; TERM  + 输入-&gt; NUMBER</span><br><span class="line">  TERM-&gt;FACTOR TERM_P</span><br><span class="line">134 :栈顶-&gt; FACTOR  + 输入-&gt; NUMBER</span><br><span class="line">  FACTOR-&gt;NUMBER</span><br><span class="line">135 :栈顶-&gt; NUMBER  + 输入-&gt; NUMBER</span><br><span class="line">  NUMBER-&gt;NUMBER</span><br><span class="line">136 :栈顶-&gt; TERM_P  + 输入-&gt; SEMI</span><br><span class="line">  TERM_P&#x3D;&#x3D; ε</span><br><span class="line">137 :栈顶-&gt; EXP_P  + 输入-&gt; SEMI</span><br><span class="line">  EXP_P&#x3D;&#x3D; ε</span><br><span class="line">138 :栈顶-&gt; SEMI  + 输入-&gt; SEMI</span><br><span class="line">  SEMI-&gt;SEMI</span><br><span class="line">139 :栈顶-&gt; STMTS  + 输入-&gt; RC</span><br><span class="line">  STMTS&#x3D;&#x3D; ε</span><br><span class="line">140 :栈顶-&gt; RC  + 输入-&gt; RC</span><br><span class="line">  RC-&gt;RC</span><br><span class="line">141 :栈顶-&gt; STMTS  + 输入-&gt; PRINT</span><br><span class="line">  STMTS-&gt;STMT STMTS</span><br><span class="line">142 :栈顶-&gt; STMT  + 输入-&gt; PRINT</span><br><span class="line">  STMT-&gt;PRINT LP EXP RP</span><br><span class="line">143 :栈顶-&gt; PRINT  + 输入-&gt; PRINT</span><br><span class="line">  PRINT-&gt;PRINT</span><br><span class="line">144 :栈顶-&gt; LP  + 输入-&gt; LP</span><br><span class="line">  LP-&gt;LP</span><br><span class="line">145 :栈顶-&gt; EXP  + 输入-&gt; ID</span><br><span class="line">  EXP-&gt;TERM EXP_P</span><br><span class="line">146 :栈顶-&gt; TERM  + 输入-&gt; ID</span><br><span class="line">  TERM-&gt;FACTOR TERM_P</span><br><span class="line">147 :栈顶-&gt; FACTOR  + 输入-&gt; ID</span><br><span class="line">  FACTOR-&gt;ID</span><br><span class="line">148 :栈顶-&gt; ID  + 输入-&gt; ID</span><br><span class="line">  ID-&gt;ID</span><br><span class="line">149 :栈顶-&gt; TERM_P  + 输入-&gt; RP</span><br><span class="line">  TERM_P&#x3D;&#x3D; ε</span><br><span class="line">150 :栈顶-&gt; EXP_P  + 输入-&gt; RP</span><br><span class="line">  EXP_P&#x3D;&#x3D; ε</span><br><span class="line">151 :栈顶-&gt; RP  + 输入-&gt; RP</span><br><span class="line">  RP-&gt;RP</span><br><span class="line">152 :栈顶-&gt; STMTS  + 输入-&gt; SEMI</span><br><span class="line">  STMTS-&gt;STMT STMTS</span><br><span class="line">153 :栈顶-&gt; STMT  + 输入-&gt; SEMI</span><br><span class="line">  STMT-&gt;SEMI</span><br><span class="line">154 :栈顶-&gt; SEMI  + 输入-&gt; SEMI</span><br><span class="line">  SEMI-&gt;SEMI</span><br><span class="line">155 :栈顶-&gt; STMTS  + 输入-&gt; RC</span><br><span class="line">  STMTS&#x3D;&#x3D; ε</span><br><span class="line">156 :栈顶-&gt; RC  + 输入-&gt; RC</span><br><span class="line">  RC-&gt;RC</span><br><span class="line">语法分析结束.....</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<hr>
<p>接下来为了方便进行语义分析，先建立一个抽象语法树.上面这个输出结合输入，似乎只要对一个推导公式的左右建立连接，但是如何建立合适的顺序</p>
<hr>
<p>input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">int a &#x3D; 0;</span><br><span class="line">while( a!&#x3D; 1)&#123;</span><br><span class="line">	a &#x3D; a+1 * c +d;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出大概是这样：(不是太像一颗树,将就一下,可能把打印的属性缩减一下会更好)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print a tree-like....</span><br><span class="line"></span><br><span class="line">                                                BLOCK-&gt;LC STMTS RC </span><br><span class="line">                                             &#123; STMTS-&gt;STMT STMTS &#125;  </span><br><span class="line">                                          STMT-&gt;DEFINE_STMT  STMTS-&gt;STMT STMTS  </span><br><span class="line">                                       DEFINE_STMT-&gt;TYPE ID ASSGIN_STMT   STMT-&gt;JUMP_STMT   null   </span><br><span class="line">                                    TYPE-&gt;INT    a    ASSGIN_STMT-&gt;EQUAL EXP SEMI    JUMP_STMT-&gt;WHILE LP EXP_BOOL RP STMT     </span><br><span class="line">                                 INT     &#x3D;     EXP-&gt;TERM EXP_P      ;      WHILE      (       EXP_BOOL-&gt;EXP RELOP EXP       )       STMT-&gt;BLOCK        </span><br><span class="line">                              TERM-&gt;FACTOR TERM_P        null        EXP-&gt;TERM EXP_P         !&#x3D;         EXP-&gt;TERM EXP_P         BLOCK-&gt;LC STMTS RC          </span><br><span class="line">                           FACTOR-&gt;NUMBER          null          TERM-&gt;FACTOR TERM_P           null           TERM-&gt;FACTOR TERM_P           null            &#123;            STMTS-&gt;STMT STMTS            &#125;             </span><br><span class="line">                        0             FACTOR-&gt;ID             null              FACTOR-&gt;NUMBER              null              STMT-&gt;ID ASSGIN_STMT               null               </span><br><span class="line">                     a               1                a                ASSGIN_STMT-&gt;EQUAL EXP SEMI                </span><br><span class="line">                  &#x3D;                 EXP-&gt;TERM EXP_P                 ;                 </span><br><span class="line">               TERM-&gt;FACTOR TERM_P                  EXP_P-&gt;PLUS TERM EXP_P                  </span><br><span class="line">            FACTOR-&gt;ID                  null                   +                   TERM-&gt;FACTOR TERM_P                   EXP_P-&gt;PLUS TERM EXP_P                    </span><br><span class="line">         a                    FACTOR-&gt;NUMBER                    TERM_P-&gt;STAR FACTOR TERM_P                     +                     TERM-&gt;FACTOR TERM_P                     null                      </span><br><span class="line">      1                      *                      FACTOR-&gt;ID                       null                       FACTOR-&gt;ID                       null                        </span><br><span class="line">   c                        d    </span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>如果完整的是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print a tree-like....</span><br><span class="line"></span><br><span class="line">                                                root&#123;&#39;BLOCK-&gt;LC STMTS RC&#125; </span><br><span class="line">                                             LC&#123;&#39;&#123;&#125; STMTS&#123;&#39;STMTS-&gt;STMT STMTS&#125; RC&#123;&#39;&#125;&#125;  </span><br><span class="line">                                          STMT&#123;&#39;STMT-&gt;DEFINE_STMT&#125;  STMTS&#123;&#39;STMTS-&gt;STMT STMTS&#125;  </span><br><span class="line">                                       DEFINE_STMT&#123;&#39;DEFINE_STMT-&gt;TYPE ID ASSGIN_STMT&#125;   STMT&#123;&#39;STMT-&gt;JUMP_STMT&#125;   STMTS&#123;&#39;null&#125;   </span><br><span class="line">                                    TYPE&#123;&#39;TYPE-&gt;INT&#125;    ID&#123;&#39;a&#125;    ASSGIN_STMT&#123;&#39;ASSGIN_STMT-&gt;EQUAL EXP SEMI&#125;    JUMP_STMT&#123;&#39;JUMP_STMT-&gt;WHILE LP EXP_BOOL RP STMT&#125;     </span><br><span class="line">                                 INT&#123;&#39;INT&#125;     EQUAL&#123;&#39;&#x3D;&#125;     EXP&#123;&#39;EXP-&gt;TERM EXP_P&#125;      SEMI&#123;&#39;;&#125;      WHILE&#123;&#39;WHILE&#125;      LP&#123;&#39;(&#125;       EXP_BOOL&#123;&#39;EXP_BOOL-&gt;EXP RELOP EXP&#125;       RP&#123;&#39;)&#125;       STMT&#123;&#39;STMT-&gt;BLOCK&#125;        </span><br><span class="line">                              TERM&#123;&#39;TERM-&gt;FACTOR TERM_P&#125;        EXP_P&#123;&#39;null&#125;        EXP&#123;&#39;EXP-&gt;TERM EXP_P&#125;         RELOP&#123;&#39;!&#x3D;&#125;         EXP&#123;&#39;EXP-&gt;TERM EXP_P&#125;         BLOCK&#123;&#39;BLOCK-&gt;LC STMTS RC&#125;          </span><br><span class="line">                           FACTOR&#123;&#39;FACTOR-&gt;NUMBER&#125;          TERM_P&#123;&#39;null&#125;          TERM&#123;&#39;TERM-&gt;FACTOR TERM_P&#125;           EXP_P&#123;&#39;null&#125;           TERM&#123;&#39;TERM-&gt;FACTOR TERM_P&#125;           EXP_P&#123;&#39;null&#125;            LC&#123;&#39;&#123;&#125;            STMTS&#123;&#39;STMTS-&gt;STMT STMTS&#125;            RC&#123;&#39;&#125;&#125;             </span><br><span class="line">                        NUMBER&#123;&#39;0&#125;             FACTOR&#123;&#39;FACTOR-&gt;ID&#125;             TERM_P&#123;&#39;null&#125;              FACTOR&#123;&#39;FACTOR-&gt;NUMBER&#125;              TERM_P&#123;&#39;null&#125;              STMT&#123;&#39;STMT-&gt;ID ASSGIN_STMT&#125;               STMTS&#123;&#39;null&#125;               </span><br><span class="line">                     ID&#123;&#39;a&#125;               NUMBER&#123;&#39;1&#125;                ID&#123;&#39;a&#125;                ASSGIN_STMT&#123;&#39;ASSGIN_STMT-&gt;EQUAL EXP SEMI&#125;                </span><br><span class="line">                  EQUAL&#123;&#39;&#x3D;&#125;                 EXP&#123;&#39;EXP-&gt;TERM EXP_P&#125;                 SEMI&#123;&#39;;&#125;                 </span><br><span class="line">               TERM&#123;&#39;TERM-&gt;FACTOR TERM_P&#125;                  EXP_P&#123;&#39;EXP_P-&gt;PLUS TERM EXP_P&#125;                  </span><br><span class="line">            FACTOR&#123;&#39;FACTOR-&gt;ID&#125;                  TERM_P&#123;&#39;null&#125;                   PLUS&#123;&#39;+&#125;                   TERM&#123;&#39;TERM-&gt;FACTOR TERM_P&#125;                   EXP_P&#123;&#39;EXP_P-&gt;PLUS TERM EXP_P&#125;                    </span><br><span class="line">         ID&#123;&#39;a&#125;                    FACTOR&#123;&#39;FACTOR-&gt;NUMBER&#125;                    TERM_P&#123;&#39;TERM_P-&gt;STAR FACTOR TERM_P&#125;                     PLUS&#123;&#39;+&#125;                     TERM&#123;&#39;TERM-&gt;FACTOR TERM_P&#125;                     EXP_P&#123;&#39;null&#125;                      </span><br><span class="line">      NUMBER&#123;&#39;1&#125;                      STAR&#123;&#39;*&#125;                      FACTOR&#123;&#39;FACTOR-&gt;ID&#125;                       TERM_P&#123;&#39;null&#125;                       FACTOR&#123;&#39;FACTOR-&gt;ID&#125;                       TERM_P&#123;&#39;null&#125;                        </span><br><span class="line">   ID&#123;&#39;c&#125;                        ID&#123;&#39;d&#125;                        </span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>编译</tag>
        <tag>文法</tag>
        <tag>语法分析</tag>
        <tag>二义性</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔</title>
    <url>/2021/01/12/%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<p>2020.12.29下午有感</p>
 <a id="more"></a>

<p><img src="https://feiyu-1300032637.cos.ap-shanghai.myqcloud.com/hexo/sea.jpeg" alt="sea"></p>
<p>我们生来都有一双翅膀</p>
<p>最终却在这片湛蓝里流浪</p>
<hr>
<p>​                                                                                        2020.12.29下午 to 豆豆</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
